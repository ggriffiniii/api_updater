pub mod schemas {
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AboutAdditionalRoleInfoItemsRoleSetsItems {
        #[doc = "The supported additional roles with the primary role."]
        #[serde(rename = "additionalRoles", default)]
        pub additional_roles: ::std::option::Option<Vec<String>>,
        #[doc = "A primary permission role."]
        #[serde(rename = "primaryRole", default)]
        pub primary_role: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for AboutAdditionalRoleInfoItemsRoleSetsItems {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AboutAdditionalRoleInfoItems {
        #[doc = "The content type that this additional role info applies to."]
        #[serde(rename = "type", default)]
        pub r#type: ::std::option::Option<String>,
        #[doc = "The supported additional roles per primary role."]
        #[serde(rename = "roleSets", default)]
        pub role_sets:
            ::std::option::Option<Vec<crate::schemas::AboutAdditionalRoleInfoItemsRoleSetsItems>>,
    }
    impl ::field_selector::FieldSelector for AboutAdditionalRoleInfoItems {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AboutDriveThemesItems {
        #[doc = "A link to this theme's background image."]
        #[serde(rename = "backgroundImageLink", default)]
        pub background_image_link: ::std::option::Option<String>,
        #[doc = "The color of this theme as an RGB hex string."]
        #[serde(rename = "colorRgb", default)]
        pub color_rgb: ::std::option::Option<String>,
        #[doc = "The ID of the theme."]
        #[serde(rename = "id", default)]
        pub id: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for AboutDriveThemesItems {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AboutExportFormatsItems {
        #[doc = "The content type to convert from."]
        #[serde(rename = "source", default)]
        pub source: ::std::option::Option<String>,
        #[doc = "The possible content types to convert to."]
        #[serde(rename = "targets", default)]
        pub targets: ::std::option::Option<Vec<String>>,
    }
    impl ::field_selector::FieldSelector for AboutExportFormatsItems {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct AboutFeaturesItems {
        #[doc = "The name of the feature."]
        #[serde(rename = "featureName", default)]
        pub feature_name: ::std::option::Option<String>,
        #[doc = "The request limit rate for this feature, in queries per second."]
        #[serde(rename = "featureRate", default)]
        pub feature_rate: ::std::option::Option<f64>,
    }
    impl ::field_selector::FieldSelector for AboutFeaturesItems {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AboutImportFormatsItems {
        #[doc = "The imported file's content type to convert from."]
        #[serde(rename = "source", default)]
        pub source: ::std::option::Option<String>,
        #[doc = "The possible content types to convert to."]
        #[serde(rename = "targets", default)]
        pub targets: ::std::option::Option<Vec<String>>,
    }
    impl ::field_selector::FieldSelector for AboutImportFormatsItems {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AboutMaxUploadSizesItems {
        #[doc = "The file type."]
        #[serde(rename = "type", default)]
        pub r#type: ::std::option::Option<String>,
        #[doc = "The max upload size for this type."]
        #[serde(rename = "size", default)]
        #[serde(with = "crate::parsed_string")]
        pub size: ::std::option::Option<i64>,
    }
    impl ::field_selector::FieldSelector for AboutMaxUploadSizesItems {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AboutQuotaBytesByServiceItems {
        #[doc = "The storage quota bytes used by the service."]
        #[serde(rename = "bytesUsed", default)]
        #[serde(with = "crate::parsed_string")]
        pub bytes_used: ::std::option::Option<i64>,
        #[doc = "The service's name, e.g. DRIVE, GMAIL, or PHOTOS."]
        #[serde(rename = "serviceName", default)]
        pub service_name: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for AboutQuotaBytesByServiceItems {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AboutTeamDriveThemesItems {
        #[doc = "Deprecated - use driveThemes/backgroundImageLink instead."]
        #[serde(rename = "backgroundImageLink", default)]
        pub background_image_link: ::std::option::Option<String>,
        #[doc = "Deprecated - use driveThemes/colorRgb instead."]
        #[serde(rename = "colorRgb", default)]
        pub color_rgb: ::std::option::Option<String>,
        #[doc = "Deprecated - use driveThemes/id instead."]
        #[serde(rename = "id", default)]
        pub id: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for AboutTeamDriveThemesItems {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct About {
        #[doc = "Information about supported additional roles per file type. The most specific type takes precedence."]
        #[serde(rename = "additionalRoleInfo", default)]
        pub additional_role_info:
            ::std::option::Option<Vec<crate::schemas::AboutAdditionalRoleInfoItems>>,
        #[doc = "The server's build label."]
        #[serde(rename = "buildLabel", default)]
        pub build_label: ::std::option::Option<String>,
        #[doc = "Whether the user can create shared drives."]
        #[serde(rename = "canCreateDrives", default)]
        pub can_create_drives: ::std::option::Option<bool>,
        #[doc = "Deprecated - use canCreateDrives instead."]
        #[serde(rename = "canCreateTeamDrives", default)]
        pub can_create_team_drives: ::std::option::Option<bool>,
        #[doc = "The user's Apps domain, if applicable"]
        #[serde(rename = "domain", default)]
        pub domain: ::std::option::Option<String>,
        #[doc = "The domain sharing policy for the current user. Possible values are:\n\n* allowed \n* allowedWithWarning \n* incomingOnly \n* disallowed"]
        #[serde(rename = "domainSharingPolicy", default)]
        pub domain_sharing_policy: ::std::option::Option<String>,
        #[doc = "A list of themes that are supported for shared drives."]
        #[serde(rename = "driveThemes", default)]
        pub drive_themes: ::std::option::Option<Vec<crate::schemas::AboutDriveThemesItems>>,
        #[doc = "The ETag of the item."]
        #[serde(rename = "etag", default)]
        pub etag: ::std::option::Option<String>,
        #[doc = "The allowable export formats."]
        #[serde(rename = "exportFormats", default)]
        pub export_formats: ::std::option::Option<Vec<crate::schemas::AboutExportFormatsItems>>,
        #[doc = "List of additional features enabled on this account."]
        #[serde(rename = "features", default)]
        pub features: ::std::option::Option<Vec<crate::schemas::AboutFeaturesItems>>,
        #[doc = "The palette of allowable folder colors as RGB hex strings."]
        #[serde(rename = "folderColorPalette", default)]
        pub folder_color_palette: ::std::option::Option<Vec<String>>,
        #[doc = "The allowable import formats."]
        #[serde(rename = "importFormats", default)]
        pub import_formats: ::std::option::Option<Vec<crate::schemas::AboutImportFormatsItems>>,
        #[doc = "A boolean indicating whether the authenticated app is installed by the authenticated user."]
        #[serde(rename = "isCurrentAppInstalled", default)]
        pub is_current_app_installed: ::std::option::Option<bool>,
        #[doc = "This is always drive#about."]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
        #[doc = "The user's language or locale code, as defined by BCP 47, with some extensions from Unicode's LDML format (http://www.unicode.org/reports/tr35/)."]
        #[serde(rename = "languageCode", default)]
        pub language_code: ::std::option::Option<String>,
        #[doc = "The largest change id."]
        #[serde(rename = "largestChangeId", default)]
        #[serde(with = "crate::parsed_string")]
        pub largest_change_id: ::std::option::Option<i64>,
        #[doc = "List of max upload sizes for each file type. The most specific type takes precedence."]
        #[serde(rename = "maxUploadSizes", default)]
        pub max_upload_sizes: ::std::option::Option<Vec<crate::schemas::AboutMaxUploadSizesItems>>,
        #[doc = "The name of the current user."]
        #[serde(rename = "name", default)]
        pub name: ::std::option::Option<String>,
        #[doc = "The current user's ID as visible in the permissions collection."]
        #[serde(rename = "permissionId", default)]
        pub permission_id: ::std::option::Option<String>,
        #[doc = "Whether the Google Photos service is enabled for this account."]
        #[serde(rename = "photosServiceEnabled", default)]
        pub photos_service_enabled: ::std::option::Option<bool>,
        #[doc = "The amount of storage quota used by different Google services."]
        #[serde(rename = "quotaBytesByService", default)]
        pub quota_bytes_by_service:
            ::std::option::Option<Vec<crate::schemas::AboutQuotaBytesByServiceItems>>,
        #[doc = "The total number of quota bytes."]
        #[serde(rename = "quotaBytesTotal", default)]
        #[serde(with = "crate::parsed_string")]
        pub quota_bytes_total: ::std::option::Option<i64>,
        #[doc = "The number of quota bytes used by Google Drive."]
        #[serde(rename = "quotaBytesUsed", default)]
        #[serde(with = "crate::parsed_string")]
        pub quota_bytes_used: ::std::option::Option<i64>,
        #[doc = "The number of quota bytes used by all Google apps (Drive, Picasa, etc.)."]
        #[serde(rename = "quotaBytesUsedAggregate", default)]
        #[serde(with = "crate::parsed_string")]
        pub quota_bytes_used_aggregate: ::std::option::Option<i64>,
        #[doc = "The number of quota bytes used by trashed items."]
        #[serde(rename = "quotaBytesUsedInTrash", default)]
        #[serde(with = "crate::parsed_string")]
        pub quota_bytes_used_in_trash: ::std::option::Option<i64>,
        #[doc = "The type of the user's storage quota. Possible values are:\n\n* LIMITED \n* UNLIMITED"]
        #[serde(rename = "quotaType", default)]
        pub quota_type: ::std::option::Option<String>,
        #[doc = "The number of remaining change ids, limited to no more than 2500."]
        #[serde(rename = "remainingChangeIds", default)]
        #[serde(with = "crate::parsed_string")]
        pub remaining_change_ids: ::std::option::Option<i64>,
        #[doc = "The id of the root folder."]
        #[serde(rename = "rootFolderId", default)]
        pub root_folder_id: ::std::option::Option<String>,
        #[doc = "A link back to this item."]
        #[serde(rename = "selfLink", default)]
        pub self_link: ::std::option::Option<String>,
        #[doc = "Deprecated - use driveThemes instead."]
        #[serde(rename = "teamDriveThemes", default)]
        pub team_drive_themes:
            ::std::option::Option<Vec<crate::schemas::AboutTeamDriveThemesItems>>,
        #[doc = "The authenticated user."]
        #[serde(rename = "user", default)]
        pub user: ::std::option::Option<crate::schemas::User>,
    }
    impl ::field_selector::FieldSelector for About {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ActionItem {
        #[doc = "The ID of action item. E.g. comment ID of an unanswered mention in Kix document."]
        #[serde(rename = "id", default)]
        pub id: ::std::option::Option<String>,
        #[doc = "The type of action item. Type can be MENTION and SUGGESTION."]
        #[serde(rename = "type", default)]
        pub r#type: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for ActionItem {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AdminFile {
        #[doc = "ID of the shared drive the file resides in."]
        #[serde(rename = "driveId", default)]
        pub drive_id: ::std::option::Option<String>,
        #[doc = "The ID of the file."]
        #[serde(rename = "id", default)]
        pub id: ::std::option::Option<String>,
        #[doc = "This is always drive#adminFile."]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
        #[serde(rename = "parentId", default)]
        pub parent_id: ::std::option::Option<String>,
        #[doc = "Deprecated use driveId instead."]
        #[serde(rename = "teamDriveId", default)]
        pub team_drive_id: ::std::option::Option<String>,
        #[doc = "The title of this file."]
        #[serde(rename = "title", default)]
        pub title: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for AdminFile {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct AppIconsItems {
        #[doc = "Category of the icon. Allowed values are:\n\n* application - icon for the application \n* document - icon for a file associated with the app \n* documentShared - icon for a shared file associated with the app"]
        #[serde(rename = "category", default)]
        pub category: ::std::option::Option<String>,
        #[doc = "URL for the icon."]
        #[serde(rename = "iconUrl", default)]
        pub icon_url: ::std::option::Option<String>,
        #[doc = "Size of the icon. Represented as the maximum of the width and height."]
        #[serde(rename = "size", default)]
        pub size: ::std::option::Option<i32>,
    }
    impl ::field_selector::FieldSelector for AppIconsItems {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct AppRankingInfoFileExtensionScoresItems {
        #[doc = "A file's extension (e.g. \"jpg\")."]
        #[serde(rename = "type", default)]
        pub r#type: ::std::option::Option<String>,
        #[doc = "A numeric score for this app for opening this file type."]
        #[serde(rename = "score", default)]
        pub score: ::std::option::Option<f64>,
    }
    impl ::field_selector::FieldSelector for AppRankingInfoFileExtensionScoresItems {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct AppRankingInfoMimeTypeScoresItems {
        #[doc = "A file's MIME type."]
        #[serde(rename = "type", default)]
        pub r#type: ::std::option::Option<String>,
        #[doc = "A numeric score for this app for opening this file type."]
        #[serde(rename = "score", default)]
        pub score: ::std::option::Option<f64>,
    }
    impl ::field_selector::FieldSelector for AppRankingInfoMimeTypeScoresItems {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct AppRankingInfo {
        #[serde(rename = "absoluteScore", default)]
        pub absolute_score: ::std::option::Option<f64>,
        #[serde(rename = "fileExtensionScores", default)]
        pub file_extension_scores:
            ::std::option::Option<Vec<crate::schemas::AppRankingInfoFileExtensionScoresItems>>,
        #[serde(rename = "mimeTypeScores", default)]
        pub mime_type_scores:
            ::std::option::Option<Vec<crate::schemas::AppRankingInfoMimeTypeScoresItems>>,
    }
    impl ::field_selector::FieldSelector for AppRankingInfo {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct App {
        #[doc = "The amount of Application Data quota used, in bytes. May be 0 while still having Application Data."]
        #[serde(rename = "appDataQuotaBytesUsed", default)]
        #[serde(with = "crate::parsed_string")]
        pub app_data_quota_bytes_used: ::std::option::Option<i64>,
        #[doc = "Whether the app is authorized to access data on the user's Drive."]
        #[serde(rename = "authorized", default)]
        pub authorized: ::std::option::Option<bool>,
        #[doc = "The list of Chrome extension IDs associated with the app."]
        #[serde(rename = "chromeExtensionIds", default)]
        pub chrome_extension_ids: ::std::option::Option<Vec<String>>,
        #[doc = "The template url to create a new file with this app in a given folder. The template will contain {folderId} to be replaced by the folder to create the new file in."]
        #[serde(rename = "createInFolderTemplate", default)]
        pub create_in_folder_template: ::std::option::Option<String>,
        #[doc = "The url to create a new file with this app."]
        #[serde(rename = "createUrl", default)]
        pub create_url: ::std::option::Option<String>,
        #[doc = "Whether the app is an official Google Drive branded app."]
        #[serde(rename = "driveBranded", default)]
        pub drive_branded: ::std::option::Option<bool>,
        #[doc = "Deprecated (b/19710844)"]
        #[serde(rename = "driveBrandedApp", default)]
        pub drive_branded_app: ::std::option::Option<bool>,
        #[doc = "Whether the app has created items in the user's Drive."]
        #[serde(rename = "driveSource", default)]
        pub drive_source: ::std::option::Option<bool>,
        #[doc = "Whether the app has Application Data."]
        #[serde(rename = "hasAppData", default)]
        pub has_app_data: ::std::option::Option<bool>,
        #[doc = "Whether the app has drive-wide scope. An app with drive-wide scope can access all files in the user's drive."]
        #[serde(rename = "hasDriveWideScope", default)]
        pub has_drive_wide_scope: ::std::option::Option<bool>,
        #[doc = "Whether the app has a G-Suite Marketplace (GSM) listing."]
        #[serde(rename = "hasGsmListing", default)]
        pub has_gsm_listing: ::std::option::Option<bool>,
        #[doc = "Whether the app is normally supressed from the list of apps."]
        #[serde(rename = "hidden", default)]
        pub hidden: ::std::option::Option<bool>,
        #[doc = "The various icons for the app."]
        #[serde(rename = "icons", default)]
        pub icons: ::std::option::Option<Vec<crate::schemas::AppIconsItems>>,
        #[doc = "The ID of the app."]
        #[serde(rename = "id", default)]
        pub id: ::std::option::Option<String>,
        #[doc = "Whether the app is installed."]
        #[serde(rename = "installed", default)]
        pub installed: ::std::option::Option<bool>,
        #[doc = "This is always drive#app."]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
        #[doc = "A long description of the app."]
        #[serde(rename = "longDescription", default)]
        pub long_description: ::std::option::Option<String>,
        #[doc = "The name of the app."]
        #[serde(rename = "name", default)]
        pub name: ::std::option::Option<String>,
        #[doc = "The type of object this app creates (e.g. Chart). If empty, the app name should be used instead."]
        #[serde(rename = "objectType", default)]
        pub object_type: ::std::option::Option<String>,
        #[doc = "The template url for opening files with this app. The template will contain {ids} and/or {exportIds} to be replaced by the actual file ids."]
        #[serde(rename = "openUrlTemplate", default)]
        pub open_url_template: ::std::option::Option<String>,
        #[doc = "The list of origins from which this app can be served."]
        #[serde(rename = "origins", default)]
        pub origins: ::std::option::Option<Vec<String>>,
        #[doc = "The list of primary file extensions."]
        #[serde(rename = "primaryFileExtensions", default)]
        pub primary_file_extensions: ::std::option::Option<Vec<String>>,
        #[doc = "The list of primary mime types."]
        #[serde(rename = "primaryMimeTypes", default)]
        pub primary_mime_types: ::std::option::Option<Vec<String>>,
        #[doc = "The ID of the product listing for this app."]
        #[serde(rename = "productId", default)]
        pub product_id: ::std::option::Option<String>,
        #[doc = "A link to the product listing for this app."]
        #[serde(rename = "productUrl", default)]
        pub product_url: ::std::option::Option<String>,
        #[doc = "The type of the app."]
        #[serde(rename = "type", default)]
        pub r#type: ::std::option::Option<String>,
        #[doc = "Information used to rank this app's quality versus other apps."]
        #[serde(rename = "rankingInfo", default)]
        pub ranking_info: ::std::option::Option<crate::schemas::AppRankingInfo>,
        #[doc = "Whether the app is removable (also known as uninstallable or deletable). Domain-installed apps and some first-party apps are \"force installed\" and therefore cannot be uninstalled by clients."]
        #[serde(rename = "removable", default)]
        pub removable: ::std::option::Option<bool>,
        #[doc = "Whether the app must be authorized before an \"Open with\" operation can be performed."]
        #[serde(rename = "requiresAuthorizationBeforeOpenWith", default)]
        pub requires_authorization_before_open_with: ::std::option::Option<bool>,
        #[doc = "The list of secondary file extensions."]
        #[serde(rename = "secondaryFileExtensions", default)]
        pub secondary_file_extensions: ::std::option::Option<Vec<String>>,
        #[doc = "The list of secondary mime types."]
        #[serde(rename = "secondaryMimeTypes", default)]
        pub secondary_mime_types: ::std::option::Option<Vec<String>>,
        #[doc = "A short description of the app."]
        #[serde(rename = "shortDescription", default)]
        pub short_description: ::std::option::Option<String>,
        #[doc = "Deprecated (b/19710844)"]
        #[serde(rename = "source", default)]
        pub source: ::std::option::Option<bool>,
        #[doc = "Whether the app supports both My Drives and shared drives."]
        #[serde(rename = "supportsAllDrives", default)]
        pub supports_all_drives: ::std::option::Option<bool>,
        #[doc = "Whether this app supports creating new objects."]
        #[serde(rename = "supportsCreate", default)]
        pub supports_create: ::std::option::Option<bool>,
        #[doc = "Whether this app supports importing Google Docs."]
        #[serde(rename = "supportsImport", default)]
        pub supports_import: ::std::option::Option<bool>,
        #[doc = "Whether this app has indicated it works in mobile browsers."]
        #[serde(rename = "supportsMobileBrowser", default)]
        pub supports_mobile_browser: ::std::option::Option<bool>,
        #[doc = "Whether this app supports opening more than one file."]
        #[serde(rename = "supportsMultiOpen", default)]
        pub supports_multi_open: ::std::option::Option<bool>,
        #[doc = "Whether this app supports creating new files when offline."]
        #[serde(rename = "supportsOfflineCreate", default)]
        pub supports_offline_create: ::std::option::Option<bool>,
        #[doc = "Deprecated use supportsAllDrives instead."]
        #[serde(rename = "supportsTeamDrives", default)]
        pub supports_team_drives: ::std::option::Option<bool>,
        #[doc = "Whether the app is selected as the default handler for the types it supports."]
        #[serde(rename = "useByDefault", default)]
        pub use_by_default: ::std::option::Option<bool>,
    }
    impl ::field_selector::FieldSelector for App {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct AppList {
        #[doc = "List of app IDs that the user has specified to use by default. The list is in reverse-priority order (lowest to highest)."]
        #[serde(rename = "defaultAppIds", default)]
        pub default_app_ids: ::std::option::Option<Vec<String>>,
        #[doc = "The ETag of the list."]
        #[serde(rename = "etag", default)]
        pub etag: ::std::option::Option<String>,
        #[doc = "The list of apps."]
        #[serde(rename = "items", default)]
        pub items: ::std::option::Option<Vec<crate::schemas::App>>,
        #[doc = "This is always drive#appList."]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
        #[doc = "A link back to this list."]
        #[serde(rename = "selfLink", default)]
        pub self_link: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for AppList {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ApprovalCapabilities {
        #[doc = "Whether the current user can add reviewers to the Approval."]
        #[serde(rename = "canAddReviewers", default)]
        pub can_add_reviewers: ::std::option::Option<bool>,
        #[doc = "Whether the current user can cancel the Approval."]
        #[serde(rename = "canCancel", default)]
        pub can_cancel: ::std::option::Option<bool>,
        #[doc = "Whether the current user can add a comment to the Approval."]
        #[serde(rename = "canComment", default)]
        pub can_comment: ::std::option::Option<bool>,
        #[doc = "Whether the current user can modify the due date of the Approval."]
        #[serde(rename = "canModifyDueDate", default)]
        pub can_modify_due_date: ::std::option::Option<bool>,
        #[doc = "Whether the current user can review the Approval."]
        #[serde(rename = "canReview", default)]
        pub can_review: ::std::option::Option<bool>,
    }
    impl ::field_selector::FieldSelector for ApprovalCapabilities {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct Approval {
        #[doc = "The Approval ID."]
        #[serde(rename = "approvalId", default)]
        pub approval_id: ::std::option::Option<String>,
        #[doc = "Set of actions that the user may take on the Approval."]
        #[serde(rename = "capabilities", default)]
        pub capabilities: ::std::option::Option<crate::schemas::ApprovalCapabilities>,
        #[doc = "The initial comment for the Approval. This is a write-only field; it can only be set when inserting an Approval."]
        #[serde(rename = "commentText", default)]
        pub comment_text: ::std::option::Option<String>,
        #[doc = "The time at which this Approval was completed (formatted RFC 3339 timestamp)."]
        #[serde(rename = "completedDate", default)]
        pub completed_date: ::std::option::Option<::chrono::DateTime<chrono::offset::Utc>>,
        #[doc = "The time at which this Approval was created (formatted RFC 3339 timestamp)."]
        #[serde(rename = "createdDate", default)]
        pub created_date: ::std::option::Option<::chrono::DateTime<chrono::offset::Utc>>,
        #[doc = "The due date for this Approval (formatted RFC 3339 timestamp). This field can be set when inserting an Approval. Due date of an existing approval can be modified with a drive.approvals.setDueDate request."]
        #[serde(rename = "dueDate", default)]
        pub due_date: ::std::option::Option<::chrono::DateTime<chrono::offset::Utc>>,
        #[doc = "The user that requested the Approval."]
        #[serde(rename = "initiator", default)]
        pub initiator: ::std::option::Option<crate::schemas::User>,
        #[doc = "This is always drive#approval."]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
        #[doc = "Whether revisionId is the Drive item's most current revision."]
        #[serde(rename = "latest", default)]
        pub latest: ::std::option::Option<bool>,
        #[doc = "The time at which this Approval was modified (formatted RFC 3339 timestamp)."]
        #[serde(rename = "modifiedDate", default)]
        pub modified_date: ::std::option::Option<::chrono::DateTime<chrono::offset::Utc>>,
        #[doc = "The decisions that are part of the Approval."]
        #[serde(rename = "reviewerDecisions", default)]
        pub reviewer_decisions: ::std::option::Option<Vec<crate::schemas::ReviewerDecision>>,
        #[doc = "Specify the reviewers for the Approval. This is a write-only field; it can only be set when inserting an Approval."]
        #[serde(rename = "reviewerEmailAddresses", default)]
        pub reviewer_email_addresses: ::std::option::Option<Vec<String>>,
        #[doc = "Deprecated - use reviewerEmailAddresses instead."]
        #[serde(rename = "reviewerPersonNames", default)]
        pub reviewer_person_names: ::std::option::Option<Vec<String>>,
        #[doc = "Revision of the Drive item at which the Approval was initiated."]
        #[serde(rename = "revisionId", default)]
        pub revision_id: ::std::option::Option<String>,
        #[doc = "The status of the Approval."]
        #[serde(rename = "status", default)]
        pub status: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for Approval {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ApprovalChangeReviewers {
        #[doc = "The text of a comment to add to the Approval, if desired."]
        #[serde(rename = "commentText", default)]
        pub comment_text: ::std::option::Option<String>,
        #[doc = "This is always drive#approvalChangeReviewers."]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
        #[serde(rename = "reviewerEmailAddressesToAdd", default)]
        pub reviewer_email_addresses_to_add: ::std::option::Option<Vec<String>>,
        #[serde(rename = "reviewerReassignments", default)]
        pub reviewer_reassignments:
            ::std::option::Option<Vec<crate::schemas::ReviewerReassignmentTemplate>>,
    }
    impl ::field_selector::FieldSelector for ApprovalChangeReviewers {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ApprovalDecisionRequest {
        #[doc = "The text of a comment to add to the Approval, if desired."]
        #[serde(rename = "commentText", default)]
        pub comment_text: ::std::option::Option<String>,
        #[doc = "The decision being made by the requester. Supported values include:\n\n* approved \n* declined"]
        #[serde(rename = "decision", default)]
        pub decision: ::std::option::Option<String>,
        #[doc = "This is always drive#approvalDecisionRequest."]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for ApprovalDecisionRequest {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ApprovalDueDate {
        #[doc = "The due date (formatted RFC 3339 timestamp)."]
        #[serde(rename = "dueDate", default)]
        pub due_date: ::std::option::Option<::chrono::DateTime<chrono::offset::Utc>>,
        #[doc = "This is always drive#approvalDueDate."]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for ApprovalDueDate {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ApprovalEventApprovalCompleteEvent {
        #[doc = "Comment on the Approval's completion, if any."]
        #[serde(rename = "commentText", default)]
        pub comment_text: ::std::option::Option<String>,
        #[doc = "The completed status of the Approval."]
        #[serde(rename = "status", default)]
        pub status: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for ApprovalEventApprovalCompleteEvent {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ApprovalEventApprovalCreateEvent {
        #[doc = "Initial comment by the Approval creator, if any."]
        #[serde(rename = "commentText", default)]
        pub comment_text: ::std::option::Option<String>,
        #[doc = "Initial due date set by the Approval creator, if any."]
        #[serde(rename = "dueDate", default)]
        pub due_date: ::std::option::Option<::chrono::DateTime<chrono::offset::Utc>>,
        #[doc = "The initial reviewers added to the Approval."]
        #[serde(rename = "reviewers", default)]
        pub reviewers: ::std::option::Option<Vec<crate::schemas::User>>,
    }
    impl ::field_selector::FieldSelector for ApprovalEventApprovalCreateEvent {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ApprovalEventCommentEvent {
        #[doc = "The comment on the Approval. This must be present."]
        #[serde(rename = "commentText", default)]
        pub comment_text: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for ApprovalEventCommentEvent {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ApprovalEventDecisionEvent {
        #[doc = "Reviewer's comment on the decision, if any."]
        #[serde(rename = "commentText", default)]
        pub comment_text: ::std::option::Option<String>,
        #[doc = "Details of the reviewer's decision."]
        #[serde(rename = "reviewerDecision", default)]
        pub reviewer_decision: ::std::option::Option<crate::schemas::ReviewerDecision>,
    }
    impl ::field_selector::FieldSelector for ApprovalEventDecisionEvent {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ApprovalEventDueDateChangeEvent {
        #[doc = "The due date set on the Approval. Empty if the due date was cleared."]
        #[serde(rename = "dueDate", default)]
        pub due_date: ::std::option::Option<::chrono::DateTime<chrono::offset::Utc>>,
        #[doc = "The due date of the Approval prior to this due date change event."]
        #[serde(rename = "priorDueDate", default)]
        pub prior_due_date: ::std::option::Option<::chrono::DateTime<chrono::offset::Utc>>,
    }
    impl ::field_selector::FieldSelector for ApprovalEventDueDateChangeEvent {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ApprovalEventReviewerChangeEvent {
        #[doc = "The reviewers added to the Approval."]
        #[serde(rename = "addedReviewers", default)]
        pub added_reviewers: ::std::option::Option<Vec<crate::schemas::User>>,
        #[doc = "Comment on the reviewer change, if any."]
        #[serde(rename = "commentText", default)]
        pub comment_text: ::std::option::Option<String>,
        #[doc = "The reassignments made to the Approval reviewers."]
        #[serde(rename = "reassignedReviewers", default)]
        pub reassigned_reviewers:
            ::std::option::Option<Vec<crate::schemas::ReassignedReviewersTemplate>>,
    }
    impl ::field_selector::FieldSelector for ApprovalEventReviewerChangeEvent {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ApprovalEvent {
        #[doc = "The Approval is complete. This can occur when all reviewers have approved the Approval, any one reviewer has declined the Approval, or when an editor performs a drive.approvals.cancel action."]
        #[serde(rename = "approvalCompleteEvent", default)]
        pub approval_complete_event:
            ::std::option::Option<crate::schemas::ApprovalEventApprovalCompleteEvent>,
        #[serde(rename = "approvalCreateEvent", default)]
        pub approval_create_event:
            ::std::option::Option<crate::schemas::ApprovalEventApprovalCreateEvent>,
        #[doc = "Someone has commented on the Approval. This event is created when someone performs a drive.approvals.comment action."]
        #[serde(rename = "commentEvent", default)]
        pub comment_event: ::std::option::Option<crate::schemas::ApprovalEventCommentEvent>,
        #[doc = "The time at which this ApprovalEvent was created (formatted RFC 3339 timestamp)."]
        #[serde(rename = "createdDate", default)]
        pub created_date: ::std::option::Option<::chrono::DateTime<chrono::offset::Utc>>,
        #[serde(rename = "creator", default)]
        pub creator: ::std::option::Option<crate::schemas::User>,
        #[doc = "A reviewer has made a decision on the Approval. This event is created when a reviewer performs a drive.approvals.approve action."]
        #[serde(rename = "decisionEvent", default)]
        pub decision_event: ::std::option::Option<crate::schemas::ApprovalEventDecisionEvent>,
        #[serde(rename = "dueDateChangeEvent", default)]
        pub due_date_change_event:
            ::std::option::Option<crate::schemas::ApprovalEventDueDateChangeEvent>,
        #[doc = "The ApprovalEvent ID."]
        #[serde(rename = "eventId", default)]
        pub event_id: ::std::option::Option<String>,
        #[doc = "This is always drive#approvalEvent."]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
        #[doc = "Someone has changed the reviewers on the Approval. This event is created when someone performs a drive.approvals.changeReviewers action."]
        #[serde(rename = "reviewerChangeEvent", default)]
        pub reviewer_change_event:
            ::std::option::Option<crate::schemas::ApprovalEventReviewerChangeEvent>,
    }
    impl ::field_selector::FieldSelector for ApprovalEvent {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ApprovalEventList {
        #[doc = "The list of ApprovalEvents. If nextPageToken is populated, then this list may be incomplete and an additional page of results should be fetched."]
        #[serde(rename = "items", default)]
        pub items: ::std::option::Option<Vec<crate::schemas::ApprovalEvent>>,
        #[doc = "This is always drive#approvalEventList"]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
        #[doc = "The page token for the next page of ApprovalEvents. This will be absent if the end of the ApprovalEvents list has been reached. If the token is rejected for any reason, it should be discarded, and pagination should be restarted from the first page of results."]
        #[serde(rename = "nextPageToken", default)]
        pub next_page_token: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for ApprovalEventList {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ApprovalEventRequest {
        #[doc = "The text of a comment to add to the Approval, if desired."]
        #[serde(rename = "commentText", default)]
        pub comment_text: ::std::option::Option<String>,
        #[doc = "This is always drive#approvalEventRequest."]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for ApprovalEventRequest {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ApprovalList {
        #[doc = "The list of Approvals. If nextPageToken is populated, then this list may be incomplete and an additional page of results should be fetched."]
        #[serde(rename = "items", default)]
        pub items: ::std::option::Option<Vec<crate::schemas::Approval>>,
        #[doc = "This is always drive#approvalList"]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
        #[doc = "The page token for the next page of Approvals. This will be absent if the end of the Approvals list has been reached. If the token is rejected for any reason, it should be discarded, and pagination should be restarted from the first page of results."]
        #[serde(rename = "nextPageToken", default)]
        pub next_page_token: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for ApprovalList {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ApprovalSummary {
        #[doc = "The ID of the approval referenced by this summary."]
        #[serde(rename = "approvalId", default)]
        pub approval_id: ::std::option::Option<String>,
        #[doc = "This is always drive#approvalSummary."]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
        #[doc = "The status of the approval. Possible status values are: IN_PROGRESS, COMPLETED, and CANCELLED."]
        #[serde(rename = "status", default)]
        pub status: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for ApprovalSummary {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ArchiveExtractionJob {
        #[doc = "The ID of the folder to extract the contents of the archive into."]
        #[serde(rename = "destinationLocationId", default)]
        pub destination_location_id: ::std::option::Option<String>,
        #[doc = "The ETag of the file preview."]
        #[serde(rename = "etag", default)]
        pub etag: ::std::option::Option<String>,
        #[doc = "The ID for this archive file extraction job."]
        #[serde(rename = "id", default)]
        pub id: ::std::option::Option<String>,
        #[doc = "This is always drive#archiveExtractionJob."]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
        #[doc = "The ID for the archive file that is extracted."]
        #[serde(rename = "sourceFileId", default)]
        pub source_file_id: ::std::option::Option<String>,
        #[doc = "The current status of this file extraction job. Values are one of:\n\n* INITIATED \n* PREPARED \n* SUCCEEDED \n* PENDING_ROLLBACK \n* FAILED"]
        #[serde(rename = "status", default)]
        pub status: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for ArchiveExtractionJob {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ArchiveResourcePreview {
        #[doc = "The list of child resource previews of this preview."]
        #[serde(rename = "children", default)]
        pub children: ::std::option::Option<Vec<crate::schemas::ArchiveResourcePreview>>,
        #[doc = "The type of error associated with this resource. Allowed values are:\n\n* NONE \n* RESOURCE_UNREADABLE \n* RESOURCE_TOO_LARGE \n* USER_LACKS_QUOTA"]
        #[serde(rename = "errorType", default)]
        pub error_type: ::std::option::Option<String>,
        #[doc = "This is always drive#archiveResourcePreview."]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
        #[doc = "The mime type of the resource within the archive file."]
        #[serde(rename = "mimeType", default)]
        pub mime_type: ::std::option::Option<String>,
        #[doc = "The path of the resource within the archive file."]
        #[serde(rename = "path", default)]
        pub path: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for ArchiveResourcePreview {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct Attachment {
        #[doc = "The ID of the file created in Drive."]
        #[serde(rename = "fileId", default)]
        pub file_id: ::std::option::Option<String>,
        #[doc = "This is always drive#attachment."]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
        #[doc = "The message ID of the attachment. This is expected to be a hex string."]
        #[serde(rename = "messageId", default)]
        pub message_id: ::std::option::Option<String>,
        #[doc = "The part ID of the attachment."]
        #[serde(rename = "partId", default)]
        pub part_id: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for Attachment {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct BackupBackupSummaryAdditionalProperties {
        #[serde(rename = "count", default)]
        pub count: ::std::option::Option<i32>,
        #[serde(rename = "totalSize", default)]
        #[serde(with = "crate::parsed_string")]
        pub total_size: ::std::option::Option<i64>,
    }
    impl ::field_selector::FieldSelector for BackupBackupSummaryAdditionalProperties {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct Backup {
        #[doc = "The source of the backup. Possible values are: whatsapp and carbon."]
        #[serde(rename = "backupSource", default)]
        pub backup_source: ::std::option::Option<String>,
        #[doc = "A summary of the contents of this backup. A map of types to the number and total size of the files of that type."]
        #[serde(rename = "backupSummary", default)]
        pub backup_summary: ::std::option::Option<
            ::std::collections::BTreeMap<
                String,
                crate::schemas::BackupBackupSummaryAdditionalProperties,
            >,
        >,
        #[doc = "The user-facing identifier for this backup. For WhatsApp backups, this is the phone number of the WhatsApp account."]
        #[serde(rename = "externalId", default)]
        pub external_id: ::std::option::Option<String>,
        #[doc = "The current state of extraction for this backup. Extraction state can only be modified by calling startExtraction and stopExtraction. Transitions to ongoing and failed states are triggered by the completion or failure of processing in the backend.\nPossible values are:\n\n* notStarted the user hasn't started extraction \n* started the user started extraction, but the initial extraction isn't complete \n* ongoing the initial extraction has completed and ongoing extraction is enabled \n* stopped the user paused the extraction from either the started or ongoing state \n* failed there was a persistent failure in either the initial or ongoing extraction"]
        #[serde(rename = "extractionState", default)]
        pub extraction_state: ::std::option::Option<String>,
        #[doc = "The ID of the backup."]
        #[serde(rename = "id", default)]
        pub id: ::std::option::Option<String>,
        #[doc = "This is always drive#backup."]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
        #[doc = "The time of this modification."]
        #[serde(rename = "lastBackupDate", default)]
        pub last_backup_date: ::std::option::Option<String>,
        #[doc = "The ID of the target folder for the extraction of this backup."]
        #[serde(rename = "targetFolderId", default)]
        pub target_folder_id: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for Backup {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct BackupList {
        #[doc = "The list of backups."]
        #[serde(rename = "items", default)]
        pub items: ::std::option::Option<Vec<crate::schemas::Backup>>,
        #[doc = "This is always drive#backupList."]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for BackupList {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct CategoryAttributeValue {
        #[doc = "Only present if valueType is boolean."]
        #[serde(rename = "boolean", default)]
        pub boolean: ::std::option::Option<bool>,
        #[doc = "DEPRECATED: Use dateString."]
        #[serde(rename = "date", default)]
        pub date: ::std::option::Option<crate::schemas::Date>,
        #[doc = "DEPRECATED: Not implemented."]
        #[serde(rename = "dateList", default)]
        pub date_list: ::std::option::Option<Vec<crate::schemas::Date>>,
        #[doc = "Only present if valueType is dateString. RFC 3339 formatted date: YYYY-MM-DD."]
        #[serde(rename = "dateString", default)]
        pub date_string: ::std::option::Option<::chrono::NaiveDate>,
        #[doc = "DEPRECATED: Not implemented."]
        #[serde(rename = "dateTime", default)]
        #[serde(with = "crate::parsed_string")]
        pub date_time: ::std::option::Option<i64>,
        #[doc = "DEPRECATED: Not implemented."]
        #[serde(rename = "dateTimeList", default)]
        pub date_time_list: ::std::option::Option<Vec<i64>>,
        #[doc = "Only present if valueType is driveFile."]
        #[serde(rename = "driveFile", default)]
        pub drive_file: ::std::option::Option<String>,
        #[doc = "Only present if valueType is driveFileList."]
        #[serde(rename = "driveFileList", default)]
        pub drive_file_list: ::std::option::Option<Vec<String>>,
        #[doc = "The identifier of this Category Attribute Value."]
        #[serde(rename = "id", default)]
        pub id: ::std::option::Option<String>,
        #[doc = "Only present if valueType is integer."]
        #[serde(rename = "integer", default)]
        #[serde(with = "crate::parsed_string")]
        pub integer: ::std::option::Option<i64>,
        #[doc = "Only present if valueType is integerList."]
        #[serde(rename = "integerList", default)]
        pub integer_list: ::std::option::Option<Vec<i64>>,
        #[doc = "This is always drive#categoryAttributeValue."]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
        #[doc = "Only present if valueType is longText."]
        #[serde(rename = "longText", default)]
        pub long_text: ::std::option::Option<String>,
        #[doc = "Only present if valueType is money."]
        #[serde(rename = "money", default)]
        pub money: ::std::option::Option<crate::schemas::Money>,
        #[doc = "Only present if valueType is moneyList."]
        #[serde(rename = "moneyList", default)]
        pub money_list: ::std::option::Option<Vec<crate::schemas::Money>>,
        #[doc = "Only present if valueType is selection."]
        #[serde(rename = "selection", default)]
        pub selection: ::std::option::Option<String>,
        #[doc = "Only present if valueType is selectionList"]
        #[serde(rename = "selectionList", default)]
        pub selection_list: ::std::option::Option<Vec<String>>,
        #[doc = "Only present if valueType is text."]
        #[serde(rename = "text", default)]
        pub text: ::std::option::Option<String>,
        #[doc = "Only present if valueType is textList."]
        #[serde(rename = "textList", default)]
        pub text_list: ::std::option::Option<Vec<String>>,
        #[doc = "Only present if valueType is user."]
        #[serde(rename = "user", default)]
        pub user: ::std::option::Option<crate::schemas::User>,
        #[doc = "Only present if valueType is userList."]
        #[serde(rename = "userList", default)]
        pub user_list: ::std::option::Option<Vec<crate::schemas::User>>,
        #[doc = "Only present if valueType is userScoped."]
        #[serde(rename = "userScoped", default)]
        pub user_scoped: ::std::option::Option<
            ::std::collections::BTreeMap<String, crate::schemas::UserScopedAttributeValue>,
        >,
        #[doc = "The attribute type. While new values may be supported in the future, the following are currently allowed:\n\n* boolean \n* dateString \n* driveFile \n* driveFileList \n* integer \n* integerList \n* longText \n* money \n* moneyList \n* selection \n* selectionList \n* text \n* textList \n* user \n* userList \n* userScoped"]
        #[serde(rename = "valueType", default)]
        pub value_type: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for CategoryAttributeValue {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct CategoryAttributeValueDelta {
        #[doc = "A new value to add to a list of integer values if the attribute is an integer list attribute."]
        #[serde(rename = "addIntegerValues", default)]
        pub add_integer_values: ::std::option::Option<Vec<i64>>,
        #[doc = "A new value to add to a list of selection values if the attribute is a selection multi select attribute."]
        #[serde(rename = "addSelectionValues", default)]
        pub add_selection_values: ::std::option::Option<Vec<String>>,
        #[doc = "A new value to add to a list of text values if the attribute is a text list attribute."]
        #[serde(rename = "addTextValues", default)]
        pub add_text_values: ::std::option::Option<Vec<String>>,
        #[doc = "Add new values to a list of users if the attribute is a user list attribute. The values must be valid email addresses."]
        #[serde(rename = "addUserValues", default)]
        pub add_user_values: ::std::option::Option<Vec<String>>,
        #[doc = "The identifier of the Attribute Value to be modified."]
        #[serde(rename = "id", default)]
        pub id: ::std::option::Option<String>,
        #[doc = "This is always drive#categoryAttributeValueDelta"]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
        #[doc = "The new value if the attribute is a boolean attribute."]
        #[serde(rename = "setBooleanValue", default)]
        pub set_boolean_value: ::std::option::Option<bool>,
        #[doc = "The new value if the attribute is a dateString attribute. The string must be in the RFC 3339 full-date format: YYYY-MM-DD."]
        #[serde(rename = "setDateStringValue", default)]
        pub set_date_string_value: ::std::option::Option<::chrono::NaiveDate>,
        #[doc = "The new value if the attribute is an integer attribute."]
        #[serde(rename = "setIntegerValue", default)]
        #[serde(with = "crate::parsed_string")]
        pub set_integer_value: ::std::option::Option<i64>,
        #[doc = "Replaces the list of integer values with these new values if the attribute is an integer list attribute."]
        #[serde(rename = "setIntegerValues", default)]
        pub set_integer_values: ::std::option::Option<Vec<i64>>,
        #[doc = "The new value if the attribute is a long text attribute."]
        #[serde(rename = "setLongTextValue", default)]
        pub set_long_text_value: ::std::option::Option<String>,
        #[doc = "The new value if the attribute is a selection single select attribute."]
        #[serde(rename = "setSelectionValue", default)]
        pub set_selection_value: ::std::option::Option<String>,
        #[doc = "Replaces the list of selection values with these new values if the attribute is a selection multi select attribute."]
        #[serde(rename = "setSelectionValues", default)]
        pub set_selection_values: ::std::option::Option<Vec<String>>,
        #[doc = "The new value if the attribute is a text attribute."]
        #[serde(rename = "setTextValue", default)]
        pub set_text_value: ::std::option::Option<String>,
        #[doc = "Replaces the list of text values with these new values if the attribute is a text list attribute."]
        #[serde(rename = "setTextValues", default)]
        pub set_text_values: ::std::option::Option<Vec<String>>,
        #[doc = "The new value if the attribute is a user attribute. The value must be a valid email address."]
        #[serde(rename = "setUserValue", default)]
        pub set_user_value: ::std::option::Option<String>,
        #[doc = "Replaces the list of users if the attribute is a user list attribute. The values must be valid email addresses."]
        #[serde(rename = "setUserValues", default)]
        pub set_user_values: ::std::option::Option<Vec<String>>,
    }
    impl ::field_selector::FieldSelector for CategoryAttributeValueDelta {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct CategoryMetadata {
        #[doc = "The values of the Category Metadata Attributes for the file. This is a map of Attribute metadata keyed by the Attribute id."]
        #[serde(rename = "attributeValues", default)]
        pub attribute_values: ::std::option::Option<
            ::std::collections::BTreeMap<String, crate::schemas::CategoryAttributeValue>,
        >,
        #[doc = "The name of the Category."]
        #[serde(rename = "categoryName", default)]
        pub category_name: ::std::option::Option<String>,
        #[doc = "This is always drive#categoryMetadata"]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for CategoryMetadata {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct CategoryMetadataDelta {
        #[doc = "The category metadata attributes to update."]
        #[serde(rename = "categoryAttributeValueDeltas", default)]
        pub category_attribute_value_deltas:
            ::std::option::Option<Vec<crate::schemas::CategoryAttributeValueDelta>>,
        #[doc = "The name of the Category to which the update applies."]
        #[serde(rename = "categoryName", default)]
        pub category_name: ::std::option::Option<String>,
        #[doc = "This is always drive#categoryMetadataDelta"]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
        #[serde(rename = "removeCategory", default)]
        pub remove_category: ::std::option::Option<bool>,
        #[doc = "The category metadata attributes to revert to their default value."]
        #[serde(rename = "revertAttributeIds", default)]
        pub revert_attribute_ids: ::std::option::Option<Vec<String>>,
    }
    impl ::field_selector::FieldSelector for CategoryMetadataDelta {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct CategoryMetadataList {
        #[doc = "A map of the name of the Category to the Category Metadata applied to this item. DEPRECATED - use 'items' instead. This field will be deleted and will not be copied into v2 or v3. TODO(b/117280829) - remove this field once it is not used by internal clients."]
        #[serde(rename = "categoryMetadata", default)]
        pub category_metadata: ::std::option::Option<
            ::std::collections::BTreeMap<String, crate::schemas::CategoryMetadata>,
        >,
        #[doc = "The list of Category Metadata."]
        #[serde(rename = "items", default)]
        pub items: ::std::option::Option<Vec<crate::schemas::CategoryMetadata>>,
        #[doc = "This is always drive#categoryMetadataList"]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
        #[doc = "The page token for the next page of Category Metadata. This field will be absent if the end of the list has been reached. If the token is rejected for any reason, it should be discarded, and pagination should be restarted from the first page of results."]
        #[serde(rename = "nextPageToken", default)]
        pub next_page_token: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for CategoryMetadataList {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct Change {
        #[doc = "The type of the change. Possible values are file and drive."]
        #[serde(rename = "changeType", default)]
        pub change_type: ::std::option::Option<String>,
        #[doc = "Whether the file or shared drive has been removed from this list of changes, for example by deletion or loss of access."]
        #[serde(rename = "deleted", default)]
        pub deleted: ::std::option::Option<bool>,
        #[doc = "The updated state of the shared drive. Present if the changeType is drive, the user is still a member of the shared drive, and the shared drive has not been deleted."]
        #[serde(rename = "drive", default)]
        pub drive: ::std::option::Option<crate::schemas::Drive>,
        #[doc = "The ID of the shared drive associated with this change."]
        #[serde(rename = "driveId", default)]
        pub drive_id: ::std::option::Option<String>,
        #[doc = "The updated state of the file. Present if the type is file and the file has not been removed from this list of changes."]
        #[serde(rename = "file", default)]
        pub file: ::std::option::Option<crate::schemas::File>,
        #[doc = "The ID of the file associated with this change."]
        #[serde(rename = "fileId", default)]
        pub file_id: ::std::option::Option<String>,
        #[doc = "The version of the file associated with this change. See file.version."]
        #[serde(rename = "fileVersion", default)]
        #[serde(with = "crate::parsed_string")]
        pub file_version: ::std::option::Option<i64>,
        #[doc = "The ID of the change."]
        #[serde(rename = "id", default)]
        #[serde(with = "crate::parsed_string")]
        pub id: ::std::option::Option<i64>,
        #[doc = "This is always drive#change."]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
        #[doc = "The time of this modification."]
        #[serde(rename = "modificationDate", default)]
        pub modification_date: ::std::option::Option<::chrono::DateTime<chrono::offset::Utc>>,
        #[doc = "Deprecated use changeType instead."]
        #[serde(rename = "type", default)]
        pub r#type: ::std::option::Option<String>,
        #[doc = "A link back to this change."]
        #[serde(rename = "selfLink", default)]
        pub self_link: ::std::option::Option<String>,
        #[doc = "Deprecated - use drive instead."]
        #[serde(rename = "teamDrive", default)]
        pub team_drive: ::std::option::Option<crate::schemas::TeamDrive>,
        #[doc = "Deprecated - use driveId instead."]
        #[serde(rename = "teamDriveId", default)]
        pub team_drive_id: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for Change {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct ChangeList {
        #[doc = "Internal field efficiency info."]
        #[serde(rename = "efficiencyInfo", default)]
        pub efficiency_info: ::std::option::Option<crate::schemas::Efficiency>,
        #[doc = "The ETag of the list."]
        #[serde(rename = "etag", default)]
        pub etag: ::std::option::Option<String>,
        #[doc = "The list of changes. If nextPageToken is populated, then this list may be incomplete and an additional page of results should be fetched."]
        #[serde(rename = "items", default)]
        pub items: ::std::option::Option<Vec<crate::schemas::Change>>,
        #[doc = "This is always drive#changeList."]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
        #[doc = "Deprecated - use changes.getStartPageToken or newStartPageToken instead."]
        #[serde(rename = "largestChangeId", default)]
        #[serde(with = "crate::parsed_string")]
        pub largest_change_id: ::std::option::Option<i64>,
        #[doc = "The starting page token for future changes. This will be present only if the end of the current changes list has been reached."]
        #[serde(rename = "newStartPageToken", default)]
        pub new_start_page_token: ::std::option::Option<String>,
        #[doc = "A link to the next page of changes."]
        #[serde(rename = "nextLink", default)]
        pub next_link: ::std::option::Option<String>,
        #[doc = "The page token for the next page of changes. This will be absent if the end of the changes list has been reached. If the token is rejected for any reason, it should be discarded, and pagination should be restarted from the first page of results."]
        #[serde(rename = "nextPageToken", default)]
        pub next_page_token: ::std::option::Option<String>,
        #[doc = "Deprecated - use changes.getRemainingCount instead."]
        #[serde(rename = "remainingChanges", default)]
        #[serde(with = "crate::parsed_string")]
        pub remaining_changes: ::std::option::Option<i64>,
        #[doc = "A link back to this list."]
        #[serde(rename = "selfLink", default)]
        pub self_link: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for ChangeList {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct Channel {
        #[doc = "The address where notifications are delivered for this channel."]
        #[serde(rename = "address", default)]
        pub address: ::std::option::Option<String>,
        #[doc = "Date and time of notification channel expiration, expressed as a Unix timestamp, in milliseconds. Optional."]
        #[serde(rename = "expiration", default)]
        #[serde(with = "crate::parsed_string")]
        pub expiration: ::std::option::Option<i64>,
        #[doc = "A UUID or similar unique string that identifies this channel."]
        #[serde(rename = "id", default)]
        pub id: ::std::option::Option<String>,
        #[doc = "Identifies this as a notification channel used to watch for changes to a resource, which is \"api#channel\"."]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
        #[doc = "Additional parameters controlling delivery channel behavior. Optional."]
        #[serde(rename = "params", default)]
        pub params: ::std::option::Option<::std::collections::BTreeMap<String, String>>,
        #[doc = "A Boolean value to indicate whether payload is wanted. Optional."]
        #[serde(rename = "payload", default)]
        pub payload: ::std::option::Option<bool>,
        #[doc = "The type of delivery mechanism used for this channel."]
        #[serde(rename = "type", default)]
        pub r#type: ::std::option::Option<String>,
        #[doc = "An opaque ID that identifies the resource being watched on this channel. Stable across different API versions."]
        #[serde(rename = "resourceId", default)]
        pub resource_id: ::std::option::Option<String>,
        #[doc = "A version-specific identifier for the watched resource."]
        #[serde(rename = "resourceUri", default)]
        pub resource_uri: ::std::option::Option<String>,
        #[doc = "An arbitrary string delivered to the target address with each notification delivered over this channel. Optional."]
        #[serde(rename = "token", default)]
        pub token: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for Channel {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct CheckPermissionsRequest {
        #[doc = "List of files by ID to check access to for the specified email addresses and role."]
        #[serde(rename = "fileIds", default)]
        pub file_ids: ::std::option::Option<Vec<String>>,
        #[doc = "This is always drive#checkPermissionsRequest."]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
        #[doc = "List of email addresses to ensure access for the specified items and role."]
        #[serde(rename = "recipientEmailAddresses", default)]
        pub recipient_email_addresses: ::std::option::Option<Vec<String>>,
        #[serde(rename = "role", default)]
        pub role: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for CheckPermissionsRequest {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct CheckPermissionsResponseFixOptionsItemsAddCollaboratorsInfo {
        #[doc = "List of recipient email addresses for which an out-of-domain-sharing warning must be shown, stating that these email addresses are not in at least one of the Google Apps organizations that the requested items belong to."]
        #[serde(rename = "outOfDomainWarningEmailAddresses", default)]
        pub out_of_domain_warning_email_addresses: ::std::option::Option<Vec<String>>,
    }
    impl ::field_selector::FieldSelector
        for CheckPermissionsResponseFixOptionsItemsAddCollaboratorsInfo
    {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct CheckPermissionsResponseFixOptionsItemsIncreaseDomainVisibilityInfo {
        #[doc = "The name to be displayed to the user for the domain to which this domain visibility fix applies. For example \"Google.com\" (in the case of \"google.com\". Note the difference in capitalization)."]
        #[serde(rename = "domainDisplayName", default)]
        pub domain_display_name: ::std::option::Option<String>,
        #[doc = "The raw domain name for the domain to which this domain visibility fix applies. For example \"google.com\"."]
        #[serde(rename = "domainName", default)]
        pub domain_name: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector
        for CheckPermissionsResponseFixOptionsItemsIncreaseDomainVisibilityInfo
    {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct CheckPermissionsResponseFixOptionsItems {
        #[doc = "If 'option_type' is set to 'ADD_COLLABORATORS', contains relevant information about adding collaborators."]
        #[serde(rename = "addCollaboratorsInfo", default)]
        pub add_collaborators_info: ::std::option::Option<
            crate::schemas::CheckPermissionsResponseFixOptionsItemsAddCollaboratorsInfo,
        >,
        #[doc = "Roles which may be offered to the user to select from."]
        #[serde(rename = "allowedRoles", default)]
        pub allowed_roles: ::std::option::Option<Vec<String>>,
        #[doc = "The file ids this fix applies to. These are the items which will need their ACLs changed. It is not the list of items which will be readable by the recipient after the fix is applied, which may be larger."]
        #[serde(rename = "fixableFileIds", default)]
        pub fixable_file_ids: ::std::option::Option<Vec<String>>,
        #[doc = "The recipients whose access to some/all of the items will change as a result of the fix."]
        #[serde(rename = "fixableRecipientEmailAddresses", default)]
        pub fixable_recipient_email_addresses: ::std::option::Option<Vec<String>>,
        #[doc = "If true, then this option fixes access to all recipients for all files. Otherwise, the option only fixes access for either some recipients or some files."]
        #[serde(rename = "fixesEverything", default)]
        pub fixes_everything: ::std::option::Option<bool>,
        #[doc = "If 'optionType' is set to 'INCREASE_DOMAIN_VISIBILITY', contains relevant information about increasing domain visibility."]
        #[serde(rename = "increaseDomainVisibilityInfo", default)]
        pub increase_domain_visibility_info: ::std::option::Option<
            crate::schemas::CheckPermissionsResponseFixOptionsItemsIncreaseDomainVisibilityInfo,
        >,
        #[doc = "The broad class of fix being proposed."]
        #[serde(rename = "optionType", default)]
        pub option_type: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for CheckPermissionsResponseFixOptionsItems {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct CheckPermissionsResponse {
        #[doc = "A list of proposed permission fixes for the specified recipients and files."]
        #[serde(rename = "fixOptions", default)]
        pub fix_options:
            ::std::option::Option<Vec<crate::schemas::CheckPermissionsResponseFixOptionsItems>>,
        #[doc = "A summary of the overall fixability of the proposed recipients and files."]
        #[serde(rename = "fixabilitySummaryState", default)]
        pub fixability_summary_state: ::std::option::Option<String>,
        #[doc = "This is always drive#checkPermissionsResponse."]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for CheckPermissionsResponse {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ChildList {
        #[doc = "The ETag of the list."]
        #[serde(rename = "etag", default)]
        pub etag: ::std::option::Option<String>,
        #[doc = "The list of children. If nextPageToken is populated, then this list may be incomplete and an additional page of results should be fetched."]
        #[serde(rename = "items", default)]
        pub items: ::std::option::Option<Vec<crate::schemas::ChildReference>>,
        #[doc = "This is always drive#childList."]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
        #[doc = "A link to the next page of children."]
        #[serde(rename = "nextLink", default)]
        pub next_link: ::std::option::Option<String>,
        #[doc = "The page token for the next page of children. This will be absent if the end of the children list has been reached. If the token is rejected for any reason, it should be discarded, and pagination should be restarted from the first page of results."]
        #[serde(rename = "nextPageToken", default)]
        pub next_page_token: ::std::option::Option<String>,
        #[doc = "A link back to this list."]
        #[serde(rename = "selfLink", default)]
        pub self_link: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for ChildList {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ChildReference {
        #[doc = "A link to the child."]
        #[serde(rename = "childLink", default)]
        pub child_link: ::std::option::Option<String>,
        #[doc = "The ID of the child."]
        #[serde(rename = "id", default)]
        pub id: ::std::option::Option<String>,
        #[doc = "This is always drive#childReference."]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
        #[doc = "A link back to this reference."]
        #[serde(rename = "selfLink", default)]
        pub self_link: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for ChildReference {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct CommentContext {
        #[doc = "The MIME type of the context snippet."]
        #[serde(rename = "type", default)]
        pub r#type: ::std::option::Option<String>,
        #[doc = "Data representation of the segment of the file being commented on. In the case of a text file for example, this would be the actual text that the comment is about."]
        #[serde(rename = "value", default)]
        pub value: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for CommentContext {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct Comment {
        #[doc = "A region of the document represented as a JSON string. See anchor documentation for details on how to define and interpret anchor properties."]
        #[serde(rename = "anchor", default)]
        pub anchor: ::std::option::Option<String>,
        #[doc = "The user who wrote this comment."]
        #[serde(rename = "author", default)]
        pub author: ::std::option::Option<crate::schemas::User>,
        #[doc = "The ID of the comment."]
        #[serde(rename = "commentId", default)]
        pub comment_id: ::std::option::Option<String>,
        #[doc = "The plain text content used to create this comment. This is not HTML safe and should only be used as a starting point to make edits to a comment's content."]
        #[serde(rename = "content", default)]
        pub content: ::std::option::Option<String>,
        #[doc = "The context of the file which is being commented on."]
        #[serde(rename = "context", default)]
        pub context: ::std::option::Option<crate::schemas::CommentContext>,
        #[doc = "The date when this comment was first created."]
        #[serde(rename = "createdDate", default)]
        pub created_date: ::std::option::Option<::chrono::DateTime<chrono::offset::Utc>>,
        #[doc = "Whether this comment has been deleted. If a comment has been deleted the content will be cleared and this will only represent a comment that once existed."]
        #[serde(rename = "deleted", default)]
        pub deleted: ::std::option::Option<bool>,
        #[doc = "The file which this comment is addressing."]
        #[serde(rename = "fileId", default)]
        pub file_id: ::std::option::Option<String>,
        #[doc = "The title of the file which this comment is addressing."]
        #[serde(rename = "fileTitle", default)]
        pub file_title: ::std::option::Option<String>,
        #[doc = "HTML formatted content for this comment."]
        #[serde(rename = "htmlContent", default)]
        pub html_content: ::std::option::Option<String>,
        #[doc = "This is always drive#comment."]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
        #[doc = "The date when this comment or any of its replies were last modified."]
        #[serde(rename = "modifiedDate", default)]
        pub modified_date: ::std::option::Option<::chrono::DateTime<chrono::offset::Utc>>,
        #[doc = "Replies to this post."]
        #[serde(rename = "replies", default)]
        pub replies: ::std::option::Option<Vec<crate::schemas::CommentReply>>,
        #[doc = "A link back to this comment."]
        #[serde(rename = "selfLink", default)]
        pub self_link: ::std::option::Option<String>,
        #[doc = "The status of this comment. Status can be changed by posting a reply to a comment with the desired status.\n\n* \"open\" - The comment is still open. \n* \"resolved\" - The comment has been resolved by one of its replies."]
        #[serde(rename = "status", default)]
        pub status: ::std::option::Option<String>,
        #[doc = "Suggestion ID if the post is a suggestion, empty otherwise."]
        #[serde(rename = "suggestionId", default)]
        pub suggestion_id: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for Comment {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct CommentList {
        #[doc = "The list of comments. If nextPageToken is populated, then this list may be incomplete and an additional page of results should be fetched."]
        #[serde(rename = "items", default)]
        pub items: ::std::option::Option<Vec<crate::schemas::Comment>>,
        #[doc = "This is always drive#commentList."]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
        #[doc = "A link to the next page of comments."]
        #[serde(rename = "nextLink", default)]
        pub next_link: ::std::option::Option<String>,
        #[doc = "The page token for the next page of comments. This will be absent if the end of the comments list has been reached. If the token is rejected for any reason, it should be discarded, and pagination should be restarted from the first page of results."]
        #[serde(rename = "nextPageToken", default)]
        pub next_page_token: ::std::option::Option<String>,
        #[doc = "A link back to this list."]
        #[serde(rename = "selfLink", default)]
        pub self_link: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for CommentList {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct CommentReply {
        #[doc = "The user who wrote this reply."]
        #[serde(rename = "author", default)]
        pub author: ::std::option::Option<crate::schemas::User>,
        #[doc = "The plain text content used to create this reply. This is not HTML safe and should only be used as a starting point to make edits to a reply's content. This field is required on inserts if no verb is specified (resolve/reopen)."]
        #[serde(rename = "content", default)]
        pub content: ::std::option::Option<String>,
        #[doc = "The date when this reply was first created."]
        #[serde(rename = "createdDate", default)]
        pub created_date: ::std::option::Option<::chrono::DateTime<chrono::offset::Utc>>,
        #[doc = "Whether this reply has been deleted. If a reply has been deleted the content will be cleared and this will only represent a reply that once existed."]
        #[serde(rename = "deleted", default)]
        pub deleted: ::std::option::Option<bool>,
        #[doc = "HTML formatted content for this reply."]
        #[serde(rename = "htmlContent", default)]
        pub html_content: ::std::option::Option<String>,
        #[doc = "This is always drive#commentReply."]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
        #[doc = "The date when this reply was last modified."]
        #[serde(rename = "modifiedDate", default)]
        pub modified_date: ::std::option::Option<::chrono::DateTime<chrono::offset::Utc>>,
        #[doc = "The ID of the reply."]
        #[serde(rename = "replyId", default)]
        pub reply_id: ::std::option::Option<String>,
        #[doc = "The action this reply performed to the parent comment. When creating a new reply this is the action to be perform to the parent comment. Possible values are:\n\n* \"resolve\" - To resolve a comment. \n* \"reopen\" - To reopen (un-resolve) a comment."]
        #[serde(rename = "verb", default)]
        pub verb: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for CommentReply {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct CommentReplyList {
        #[doc = "The list of replies. If nextPageToken is populated, then this list may be incomplete and an additional page of results should be fetched."]
        #[serde(rename = "items", default)]
        pub items: ::std::option::Option<Vec<crate::schemas::CommentReply>>,
        #[doc = "This is always drive#commentReplyList."]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
        #[doc = "A link to the next page of replies."]
        #[serde(rename = "nextLink", default)]
        pub next_link: ::std::option::Option<String>,
        #[doc = "The page token for the next page of replies. This will be absent if the end of the replies list has been reached. If the token is rejected for any reason, it should be discarded, and pagination should be restarted from the first page of results."]
        #[serde(rename = "nextPageToken", default)]
        pub next_page_token: ::std::option::Option<String>,
        #[doc = "A link back to this list."]
        #[serde(rename = "selfLink", default)]
        pub self_link: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for CommentReplyList {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ContentRestriction {
        #[doc = "The type of the content restriction. Currently the only possible value is globalContentRestriction."]
        #[serde(rename = "type", default)]
        pub r#type: ::std::option::Option<String>,
        #[doc = "Whether the content of the file is read-only."]
        #[serde(rename = "readOnly", default)]
        pub read_only: ::std::option::Option<bool>,
        #[doc = "Reason for why the content of the file is restricted. This is only mutable on requests that also set readOnly=true."]
        #[serde(rename = "reason", default)]
        pub reason: ::std::option::Option<String>,
        #[doc = "The user who set the content restriction. Only populated if readOnly is true."]
        #[serde(rename = "restrictingUser", default)]
        pub restricting_user: ::std::option::Option<crate::schemas::User>,
        #[doc = "The time at which the content restriction was set (formatted RFC 3339 timestamp). Only populated if readOnly is true."]
        #[serde(rename = "restrictionDate", default)]
        pub restriction_date: ::std::option::Option<::chrono::DateTime<chrono::offset::Utc>>,
    }
    impl ::field_selector::FieldSelector for ContentRestriction {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct Date {
        #[doc = "The date's day. Valid values are 1 - 31, depending on the month."]
        #[serde(rename = "day", default)]
        pub day: ::std::option::Option<i32>,
        #[doc = "This is always drive#date"]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
        #[doc = "The date's month. Valid values are 1 - 12."]
        #[serde(rename = "month", default)]
        pub month: ::std::option::Option<i32>,
        #[doc = "The date's year."]
        #[serde(rename = "year", default)]
        pub year: ::std::option::Option<i32>,
    }
    impl ::field_selector::FieldSelector for Date {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct DriveBackgroundImageFile {
        #[doc = "The ID of an image file in Google Drive to use for the background image."]
        #[serde(rename = "id", default)]
        pub id: ::std::option::Option<String>,
        #[doc = "The width of the cropped image in the closed range of 0 to 1. This value represents the width of the cropped image divided by the width of the entire image. The height is computed by applying a width to height aspect ratio of 80 to 9. The resulting image must be at least 1280 pixels wide and 144 pixels high."]
        #[serde(rename = "width", default)]
        pub width: ::std::option::Option<f32>,
        #[doc = "The X coordinate of the upper left corner of the cropping area in the background image. This is a value in the closed range of 0 to 1. This value represents the horizontal distance from the left side of the entire image to the left side of the cropping area divided by the width of the entire image."]
        #[serde(rename = "xCoordinate", default)]
        pub x_coordinate: ::std::option::Option<f32>,
        #[doc = "The Y coordinate of the upper left corner of the cropping area in the background image. This is a value in the closed range of 0 to 1. This value represents the vertical distance from the top side of the entire image to the top side of the cropping area divided by the height of the entire image."]
        #[serde(rename = "yCoordinate", default)]
        pub y_coordinate: ::std::option::Option<f32>,
    }
    impl ::field_selector::FieldSelector for DriveBackgroundImageFile {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct DriveCapabilities {
        #[doc = "Whether the current user can add children to folders in this shared drive."]
        #[serde(rename = "canAddChildren", default)]
        pub can_add_children: ::std::option::Option<bool>,
        #[doc = "Whether the current user can change references to categories on this shared drive."]
        #[serde(rename = "canChangeCategoryReferences", default)]
        pub can_change_category_references: ::std::option::Option<bool>,
        #[doc = "Whether the current user can change the copyRequiresWriterPermission restriction of this shared drive."]
        #[serde(rename = "canChangeCopyRequiresWriterPermissionRestriction", default)]
        pub can_change_copy_requires_writer_permission_restriction: ::std::option::Option<bool>,
        #[doc = "Whether the current user can change the disallowDriveFileStream restriction of this shared drive."]
        #[serde(rename = "canChangeDisallowDriveFileStreamRestriction", default)]
        pub can_change_disallow_drive_file_stream_restriction: ::std::option::Option<bool>,
        #[doc = "Whether the current user can change the domainUsersOnly restriction of this shared drive."]
        #[serde(rename = "canChangeDomainUsersOnlyRestriction", default)]
        pub can_change_domain_users_only_restriction: ::std::option::Option<bool>,
        #[doc = "Whether the current user can change the background of this shared drive."]
        #[serde(rename = "canChangeDriveBackground", default)]
        pub can_change_drive_background: ::std::option::Option<bool>,
        #[doc = "Whether the current user can change the driveMembersOnly restriction of this shared drive."]
        #[serde(rename = "canChangeDriveMembersOnlyRestriction", default)]
        pub can_change_drive_members_only_restriction: ::std::option::Option<bool>,
        #[doc = "Whether the current user can comment on files in this shared drive."]
        #[serde(rename = "canComment", default)]
        pub can_comment: ::std::option::Option<bool>,
        #[doc = "Whether the current user can copy files in this shared drive."]
        #[serde(rename = "canCopy", default)]
        pub can_copy: ::std::option::Option<bool>,
        #[doc = "Whether the current user can delete children from folders in this shared drive."]
        #[serde(rename = "canDeleteChildren", default)]
        pub can_delete_children: ::std::option::Option<bool>,
        #[doc = "Whether the current user can delete this shared drive. Attempting to delete the shared drive may still fail if there are untrashed items inside the shared drive."]
        #[serde(rename = "canDeleteDrive", default)]
        pub can_delete_drive: ::std::option::Option<bool>,
        #[doc = "Whether the current user can download files in this shared drive."]
        #[serde(rename = "canDownload", default)]
        pub can_download: ::std::option::Option<bool>,
        #[doc = "Whether the current user can edit files in this shared drive."]
        #[serde(rename = "canEdit", default)]
        pub can_edit: ::std::option::Option<bool>,
        #[doc = "Whether the current user can list the children of folders in this shared drive."]
        #[serde(rename = "canListChildren", default)]
        pub can_list_children: ::std::option::Option<bool>,
        #[doc = "Whether the current user can add members to this shared drive or remove them or change their role."]
        #[serde(rename = "canManageMembers", default)]
        pub can_manage_members: ::std::option::Option<bool>,
        #[doc = "Whether files in this shared drive can be printed by the current user."]
        #[serde(rename = "canPrint", default)]
        pub can_print: ::std::option::Option<bool>,
        #[doc = "Whether the current user can read the revisions resource of files in this shared drive."]
        #[serde(rename = "canReadRevisions", default)]
        pub can_read_revisions: ::std::option::Option<bool>,
        #[doc = "Whether the current user can rename files or folders in this shared drive."]
        #[serde(rename = "canRename", default)]
        pub can_rename: ::std::option::Option<bool>,
        #[doc = "Whether the current user can rename this shared drive."]
        #[serde(rename = "canRenameDrive", default)]
        pub can_rename_drive: ::std::option::Option<bool>,
        #[doc = "Whether the current user can share files or folders in this shared drive."]
        #[serde(rename = "canShare", default)]
        pub can_share: ::std::option::Option<bool>,
        #[doc = "Whether the current user can share files or folders in this shared drive to all users, including those who are not signed in."]
        #[serde(rename = "canShareToAllUsers", default)]
        pub can_share_to_all_users: ::std::option::Option<bool>,
        #[doc = "Whether the current user can trash children from folders in this shared drive."]
        #[serde(rename = "canTrashChildren", default)]
        pub can_trash_children: ::std::option::Option<bool>,
    }
    impl ::field_selector::FieldSelector for DriveCapabilities {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct DrivePermissionsSummary {
        #[doc = "Total number of permission entries. This includes entries not in \"selectPermissions\"."]
        #[serde(rename = "entryCount", default)]
        pub entry_count: ::std::option::Option<i32>,
        #[doc = "Total number of group type permission entries. This includes entries not in \"selectPermissions\"."]
        #[serde(rename = "groupEntryCount", default)]
        pub group_entry_count: ::std::option::Option<i32>,
        #[doc = "Total number of members of this shared drive, which contains the expanded group membership counts for any groups. If the shared drive has several members a lower bound is returned instead."]
        #[serde(rename = "memberCount", default)]
        pub member_count: ::std::option::Option<i32>,
        #[doc = "A selection of at most 10 entries from the shared drive's permissions."]
        #[serde(rename = "selectPermissions", default)]
        pub select_permissions: ::std::option::Option<Vec<crate::schemas::Permission>>,
        #[doc = "Total number of user type permission entries. This includes entries not in \"selectPermissions\"."]
        #[serde(rename = "userEntryCount", default)]
        pub user_entry_count: ::std::option::Option<i32>,
    }
    impl ::field_selector::FieldSelector for DrivePermissionsSummary {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct DriveRestrictions {
        #[doc = "Whether administrative privileges on this shared drive are required to modify restrictions."]
        #[serde(rename = "adminManagedRestrictions", default)]
        pub admin_managed_restrictions: ::std::option::Option<bool>,
        #[doc = "Whether the options to copy, print, or download files inside this shared drive, should be disabled for readers and commenters. When this restriction is set to true, it will override the similarly named field to true for any file inside this shared drive."]
        #[serde(rename = "copyRequiresWriterPermission", default)]
        pub copy_requires_writer_permission: ::std::option::Option<bool>,
        #[doc = "Whether Drive File Stream is prevented from accessing items inside this shared drive."]
        #[serde(rename = "disallowDriveFileStream", default)]
        pub disallow_drive_file_stream: ::std::option::Option<bool>,
        #[doc = "Whether access to this shared drive and items inside this shared drive is restricted to users of the domain to which this shared drive belongs. This restriction may be overridden by other sharing policies controlled outside of this shared drive."]
        #[serde(rename = "domainUsersOnly", default)]
        pub domain_users_only: ::std::option::Option<bool>,
        #[doc = "Whether access to items inside this shared drive is restricted to its members."]
        #[serde(rename = "driveMembersOnly", default)]
        pub drive_members_only: ::std::option::Option<bool>,
    }
    impl ::field_selector::FieldSelector for DriveRestrictions {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct DriveRestrictionsOverride {
        #[doc = "The override status for the domainUsersOnly restriction. Possible values are notOverridden and overriddenToTrue."]
        #[serde(rename = "domainUsersOnly", default)]
        pub domain_users_only: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for DriveRestrictionsOverride {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct Drive {
        #[doc = "An image file and cropping parameters from which a background image for this shared drive is set. This is a write only field; it can only be set on drive.drives.update requests that don't set themeId. When specified, all fields of the backgroundImageFile must be set."]
        #[serde(rename = "backgroundImageFile", default)]
        pub background_image_file: ::std::option::Option<crate::schemas::DriveBackgroundImageFile>,
        #[doc = "A link to this shared drive's background image for use in Tesla's grid view."]
        #[serde(rename = "backgroundImageGridViewLink", default)]
        pub background_image_grid_view_link: ::std::option::Option<String>,
        #[doc = "A short-lived link to this shared drive's background image."]
        #[serde(rename = "backgroundImageLink", default)]
        pub background_image_link: ::std::option::Option<String>,
        #[doc = "A link to this shared drive's background image for use in Tesla's list view."]
        #[serde(rename = "backgroundImageListViewLink", default)]
        pub background_image_list_view_link: ::std::option::Option<String>,
        #[doc = "Capabilities the current user has on this shared drive."]
        #[serde(rename = "capabilities", default)]
        pub capabilities: ::std::option::Option<crate::schemas::DriveCapabilities>,
        #[serde(rename = "categoryReferences", default)]
        pub category_references: ::std::option::Option<Vec<crate::schemas::DriveCategoryReference>>,
        #[doc = "The color of this shared drive as an RGB hex string. It can only be set on a drive.drives.update request that does not set themeId."]
        #[serde(rename = "colorRgb", default)]
        pub color_rgb: ::std::option::Option<String>,
        #[doc = "The time at which the shared drive was created (RFC 3339 date-time)."]
        #[serde(rename = "createdDate", default)]
        pub created_date: ::std::option::Option<::chrono::DateTime<chrono::offset::Utc>>,
        #[doc = "User that created the shared drive, if available. Only returned when useDomainAdminAccess=true."]
        #[serde(rename = "creator", default)]
        pub creator: ::std::option::Option<crate::schemas::User>,
        #[doc = "Whether the shared drive is hidden from default view."]
        #[serde(rename = "hidden", default)]
        pub hidden: ::std::option::Option<bool>,
        #[doc = "The ID of this shared drive which is also the ID of the top level folder of this shared drive."]
        #[serde(rename = "id", default)]
        pub id: ::std::option::Option<String>,
        #[doc = "This is always drive#drive"]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
        #[doc = "The name of this shared drive."]
        #[serde(rename = "name", default)]
        pub name: ::std::option::Option<String>,
        #[doc = "The display name of the organization to which this shared drive belongs."]
        #[serde(rename = "organizationDisplayName", default)]
        pub organization_display_name: ::std::option::Option<String>,
        #[doc = "A summary of the permissions of this shared drive as an output-only field."]
        #[serde(rename = "permissionsSummary", default)]
        pub permissions_summary: ::std::option::Option<crate::schemas::DrivePermissionsSummary>,
        #[doc = "The DNS domain name of the primary domain of the organization to which this shared drive belongs."]
        #[serde(rename = "primaryDomainName", default)]
        pub primary_domain_name: ::std::option::Option<String>,
        #[doc = "The number of files contained within this shared drive, excluding the shared drive's top level folder. NOTE: this value is stale, and is only intended to be used by Cello for backfilling purposes. Do not add to public API versions. More info: go/team-drive-stats-api"]
        #[serde(rename = "recursiveFileCount", default)]
        #[serde(with = "crate::parsed_string")]
        pub recursive_file_count: ::std::option::Option<i64>,
        #[doc = "The number of folders contained within this shared drive, excluding the shared drive's top level folder. NOTE: this value is stale, and is only intended to be used by Cello for backfilling purposes. Do not add to public API versions. More info: go/team-drive-stats-api"]
        #[serde(rename = "recursiveFolderCount", default)]
        #[serde(with = "crate::parsed_string")]
        pub recursive_folder_count: ::std::option::Option<i64>,
        #[doc = "A set of restrictions that apply to this shared drive or items inside this shared drive."]
        #[serde(rename = "restrictions", default)]
        pub restrictions: ::std::option::Option<crate::schemas::DriveRestrictions>,
        #[doc = "A set of overrides for any restriction that can be overridden outside of the shared drive's restriction settings. The name of the override is identical to the name of the restriction which can be overridden."]
        #[serde(rename = "restrictionsOverride", default)]
        pub restrictions_override: ::std::option::Option<crate::schemas::DriveRestrictionsOverride>,
        #[doc = "The ID of the theme from which the background image and color will be set. The set of possible driveThemes can be retrieved from a drive.about.get response. When not specified on a drive.drives.insert request, a random theme is chosen from which the background image and color are set. This is a write-only field; it can only be set on requests that don't set colorRgb or backgroundImageFile."]
        #[serde(rename = "themeId", default)]
        pub theme_id: ::std::option::Option<String>,
        #[doc = "Whether this shared drive belongs to a domain that is trusted by the requesting user's domain."]
        #[serde(rename = "trusted", default)]
        pub trusted: ::std::option::Option<bool>,
    }
    impl ::field_selector::FieldSelector for Drive {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct DriveCategoryChangeRequest {
        #[doc = "The references to categories to add or update on the shared drive."]
        #[serde(rename = "addCategoryReferences", default)]
        pub add_category_references:
            ::std::option::Option<Vec<crate::schemas::DriveCategoryReference>>,
        #[doc = "This is always drive#driveCategoryChangeRequest."]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
        #[doc = "The category resource names to remove from the shared drive."]
        #[serde(rename = "removeCategoryReferences", default)]
        pub remove_category_references: ::std::option::Option<Vec<String>>,
    }
    impl ::field_selector::FieldSelector for DriveCategoryChangeRequest {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct DriveCategoryReference {
        #[doc = "The category resource name."]
        #[serde(rename = "category", default)]
        pub category: ::std::option::Option<String>,
        #[doc = "This is always drive#driveCategoryReference."]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for DriveCategoryReference {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct DriveList {
        #[doc = "The list of shared drives. If nextPageToken is populated, then this list may be incomplete and an additional page of results should be fetched."]
        #[serde(rename = "items", default)]
        pub items: ::std::option::Option<Vec<crate::schemas::Drive>>,
        #[doc = "This is always drive#driveList"]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
        #[doc = "The page token for the next page of shared drives. This will be absent if the end of the list has been reached. If the token is rejected for any reason, it should be discarded, and pagination should be restarted from the first page of results."]
        #[serde(rename = "nextPageToken", default)]
        pub next_page_token: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for DriveList {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct Efficiency {
        #[doc = "The inefficient Drive Service fields requested."]
        #[serde(rename = "inefficientDriveServiceFields", default)]
        pub inefficient_drive_service_fields: ::std::option::Option<Vec<String>>,
        #[doc = "This is always drive#efficiency."]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
        #[doc = "The Drive Service query strategies used to answer the request."]
        #[serde(rename = "queryStrategies", default)]
        pub query_strategies: ::std::option::Option<Vec<String>>,
        #[serde(rename = "requestWasInefficient", default)]
        pub request_was_inefficient: ::std::option::Option<bool>,
    }
    impl ::field_selector::FieldSelector for Efficiency {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct FileApprovalMetadata {
        #[doc = "Summaries of all approvals associated with this item."]
        #[serde(rename = "approvalSummaries", default)]
        pub approval_summaries: ::std::option::Option<Vec<crate::schemas::ApprovalSummary>>,
        #[doc = "The overall version of all approvals associated with this file (incremented on each approval write)."]
        #[serde(rename = "approvalVersion", default)]
        #[serde(with = "crate::parsed_string")]
        pub approval_version: ::std::option::Option<i64>,
    }
    impl ::field_selector::FieldSelector for FileApprovalMetadata {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct FileCapabilities {
        #[doc = "Whether the current user can add children to this folder. This is always false when the item is not a folder."]
        #[serde(rename = "canAddChildren", default)]
        pub can_add_children: ::std::option::Option<bool>,
        #[doc = "Whether the current user can add a parent for the item without removing an existing parent in the same request. Not populated for shared drive files."]
        #[serde(rename = "canAddMyDriveParent", default)]
        pub can_add_my_drive_parent: ::std::option::Option<bool>,
        #[doc = "Whether the current user can change the copyRequiresWriterPermission restriction of this file."]
        #[serde(rename = "canChangeCopyRequiresWriterPermission", default)]
        pub can_change_copy_requires_writer_permission: ::std::option::Option<bool>,
        #[doc = "Whether the current user can add or change a permission's expiration date on this file."]
        #[serde(rename = "canChangePermissionExpiration", default)]
        pub can_change_permission_expiration: ::std::option::Option<bool>,
        #[doc = "Deprecated"]
        #[serde(rename = "canChangeRestrictedDownload", default)]
        pub can_change_restricted_download: ::std::option::Option<bool>,
        #[doc = "Whether the current user can change whether users with writer permission can share this file."]
        #[serde(rename = "canChangeWritersCanShare", default)]
        pub can_change_writers_can_share: ::std::option::Option<bool>,
        #[doc = "Whether the current user can comment on this file."]
        #[serde(rename = "canComment", default)]
        pub can_comment: ::std::option::Option<bool>,
        #[doc = "Whether the current user can copy this file. For a shared drive item, whether the current user can copy non-folder descendants of this item, or this item itself if it is not a folder."]
        #[serde(rename = "canCopy", default)]
        pub can_copy: ::std::option::Option<bool>,
        #[doc = "Whether the current user can delete this file."]
        #[serde(rename = "canDelete", default)]
        pub can_delete: ::std::option::Option<bool>,
        #[doc = "Whether the current user can delete children of this folder. This is false when the item is not a folder. Only populated for shared drive items."]
        #[serde(rename = "canDeleteChildren", default)]
        pub can_delete_children: ::std::option::Option<bool>,
        #[doc = "Whether the current user can download this file."]
        #[serde(rename = "canDownload", default)]
        pub can_download: ::std::option::Option<bool>,
        #[doc = "Whether the current user can edit this file. Other factors may limit the type of changes a user can make to a file. For example, see canChangeCopyRequiresWriterPermission or canModifyContent."]
        #[serde(rename = "canEdit", default)]
        pub can_edit: ::std::option::Option<bool>,
        #[doc = "Whether the current user can edit the category metadata on this file."]
        #[serde(rename = "canEditCategoryMetadata", default)]
        pub can_edit_category_metadata: ::std::option::Option<bool>,
        #[doc = "Whether the current user can list the children of this folder. This is always false when the item is not a folder."]
        #[serde(rename = "canListChildren", default)]
        pub can_list_children: ::std::option::Option<bool>,
        #[doc = "Deprecated: use the canShare capability."]
        #[serde(rename = "canManageMembers", default)]
        pub can_manage_members: ::std::option::Option<bool>,
        #[doc = "Deprecated: use the canShare capability."]
        #[serde(rename = "canManageVisitors", default)]
        pub can_manage_visitors: ::std::option::Option<bool>,
        #[doc = "Whether the current user can modify the content of this file."]
        #[serde(rename = "canModifyContent", default)]
        pub can_modify_content: ::std::option::Option<bool>,
        #[doc = "Whether the current user can modify restrictions on content of this file."]
        #[serde(rename = "canModifyContentRestriction", default)]
        pub can_modify_content_restriction: ::std::option::Option<bool>,
        #[doc = "Whether the current user can move children of this folder outside of the shared drive. This is false when the item is not a folder. Only populated for items in shared drives."]
        #[serde(rename = "canMoveChildrenOutOfDrive", default)]
        pub can_move_children_out_of_drive: ::std::option::Option<bool>,
        #[doc = "Deprecated - use canMoveChildrenOutOfDrive instead."]
        #[serde(rename = "canMoveChildrenOutOfTeamDrive", default)]
        pub can_move_children_out_of_team_drive: ::std::option::Option<bool>,
        #[doc = "Whether the current user can move children of this folder within the shared drive. This is false when the item is not a folder. Only populated for items in shared drives."]
        #[serde(rename = "canMoveChildrenWithinDrive", default)]
        pub can_move_children_within_drive: ::std::option::Option<bool>,
        #[doc = "Deprecated - use canMoveChildrenWithinDrive instead."]
        #[serde(rename = "canMoveChildrenWithinTeamDrive", default)]
        pub can_move_children_within_team_drive: ::std::option::Option<bool>,
        #[doc = "Deprecated - use canMoveItemOutOfDrive instead."]
        #[serde(rename = "canMoveItemIntoTeamDrive", default)]
        pub can_move_item_into_team_drive: ::std::option::Option<bool>,
        #[doc = "Whether the current user can move this item outside of this drive by changing its parent. Note that a request to change the parent of the item may still fail depending on the new parent that is being added."]
        #[serde(rename = "canMoveItemOutOfDrive", default)]
        pub can_move_item_out_of_drive: ::std::option::Option<bool>,
        #[doc = "Deprecated - use canMoveItemOutOfDrive instead."]
        #[serde(rename = "canMoveItemOutOfTeamDrive", default)]
        pub can_move_item_out_of_team_drive: ::std::option::Option<bool>,
        #[doc = "Whether the current user can move this item within this drive. Note that a request to change the parent of the item may still fail depending on the new parent that is being added."]
        #[serde(rename = "canMoveItemWithinDrive", default)]
        pub can_move_item_within_drive: ::std::option::Option<bool>,
        #[doc = "Deprecated - use canMoveItemWithinDrive instead."]
        #[serde(rename = "canMoveItemWithinTeamDrive", default)]
        pub can_move_item_within_team_drive: ::std::option::Option<bool>,
        #[doc = "Deprecated - use canMoveItemWithinDrive or canMoveItemOutOfDrive instead."]
        #[serde(rename = "canMoveTeamDriveItem", default)]
        pub can_move_team_drive_item: ::std::option::Option<bool>,
        #[doc = "Whether the current user can print this file."]
        #[serde(rename = "canPrint", default)]
        pub can_print: ::std::option::Option<bool>,
        #[doc = "Whether the current user can read this file."]
        #[serde(rename = "canRead", default)]
        pub can_read: ::std::option::Option<bool>,
        #[doc = "Whether the current user can read all the permissions on this file."]
        #[serde(rename = "canReadAllPermissions", default)]
        pub can_read_all_permissions: ::std::option::Option<bool>,
        #[doc = "Whether the current user can read the category metadata on this file."]
        #[serde(rename = "canReadCategoryMetadata", default)]
        pub can_read_category_metadata: ::std::option::Option<bool>,
        #[doc = "Whether the current user can read the shared drive to which this file belongs. Only populated for items in shared drives."]
        #[serde(rename = "canReadDrive", default)]
        pub can_read_drive: ::std::option::Option<bool>,
        #[doc = "Whether the current user can read the revisions resource of this file. For a shared drive item, whether revisions of non-folder descendants of this item, or this item itself if it is not a folder, can be read."]
        #[serde(rename = "canReadRevisions", default)]
        pub can_read_revisions: ::std::option::Option<bool>,
        #[doc = "Deprecated - use canReadDrive instead."]
        #[serde(rename = "canReadTeamDrive", default)]
        pub can_read_team_drive: ::std::option::Option<bool>,
        #[doc = "Whether the current user can remove children from this folder. This is always false when the item is not a folder. For shared drive items, use canDeleteChildren or canTrashChildren instead."]
        #[serde(rename = "canRemoveChildren", default)]
        pub can_remove_children: ::std::option::Option<bool>,
        #[doc = "Whether the current user can remove a parent from the item without adding another parent in the same request. Not populated for shared drive files."]
        #[serde(rename = "canRemoveMyDriveParent", default)]
        pub can_remove_my_drive_parent: ::std::option::Option<bool>,
        #[doc = "Whether the current user can rename this file."]
        #[serde(rename = "canRename", default)]
        pub can_rename: ::std::option::Option<bool>,
        #[doc = "Whether the current user can request an approval on this file."]
        #[serde(rename = "canRequestApproval", default)]
        pub can_request_approval: ::std::option::Option<bool>,
        #[doc = "Whether the current user can modify the sharing settings for this file."]
        #[serde(rename = "canShare", default)]
        pub can_share: ::std::option::Option<bool>,
        #[doc = "Whether the current user can share this file with the commenter role. Only populated for shared drive items."]
        #[serde(rename = "canShareAsCommenter", default)]
        pub can_share_as_commenter: ::std::option::Option<bool>,
        #[doc = "Whether the current user can share this file with the fileOrganizer role. Only populated for shared drive items."]
        #[serde(rename = "canShareAsFileOrganizer", default)]
        pub can_share_as_file_organizer: ::std::option::Option<bool>,
        #[doc = "Whether the current user can share this file with the organizer role. Only populated for shared drive items."]
        #[serde(rename = "canShareAsOrganizer", default)]
        pub can_share_as_organizer: ::std::option::Option<bool>,
        #[doc = "Whether the current user can share this file with the owner role. Only populated for shared drive items."]
        #[serde(rename = "canShareAsOwner", default)]
        pub can_share_as_owner: ::std::option::Option<bool>,
        #[doc = "Whether the current user can share this file with the reader role. Only populated for shared drive items."]
        #[serde(rename = "canShareAsReader", default)]
        pub can_share_as_reader: ::std::option::Option<bool>,
        #[doc = "Whether the current user can share this file with the writer role. Only populated for shared drive items."]
        #[serde(rename = "canShareAsWriter", default)]
        pub can_share_as_writer: ::std::option::Option<bool>,
        #[doc = "Whether the current user can share the published view of this file with the reader role."]
        #[serde(rename = "canSharePublishedViewAsReader", default)]
        pub can_share_published_view_as_reader: ::std::option::Option<bool>,
        #[doc = "Whether the current user can share this file with all users, including those who are not signed in."]
        #[serde(rename = "canShareToAllUsers", default)]
        pub can_share_to_all_users: ::std::option::Option<bool>,
        #[doc = "Whether the current user can move this file to trash."]
        #[serde(rename = "canTrash", default)]
        pub can_trash: ::std::option::Option<bool>,
        #[doc = "Whether the current user can trash children of this folder. This is false when the item is not a folder. Only populated for shared drive items."]
        #[serde(rename = "canTrashChildren", default)]
        pub can_trash_children: ::std::option::Option<bool>,
        #[doc = "Whether the current user can restore this file from trash."]
        #[serde(rename = "canUntrash", default)]
        pub can_untrash: ::std::option::Option<bool>,
    }
    impl ::field_selector::FieldSelector for FileCapabilities {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct FileClientEncryptionDetails {
        #[doc = "The encryption state of the file. The values expected here are:\n\n* encrypted \n* unencrypted"]
        #[serde(rename = "encryptionState", default)]
        pub encryption_state: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for FileClientEncryptionDetails {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct FileContentRestriction {
        #[doc = "Whether the content of the file is read-only."]
        #[serde(rename = "readOnly", default)]
        pub read_only: ::std::option::Option<bool>,
        #[doc = "Reason for why the content of the file is restricted. This is only mutable on requests that also set readOnly=true."]
        #[serde(rename = "reason", default)]
        pub reason: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for FileContentRestriction {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct FileDriveSource {
        #[doc = "The unique identifier for the client, limited to the values in DriveSource.ClientService"]
        #[serde(rename = "clientServiceId", default)]
        pub client_service_id: ::std::option::Option<String>,
        #[doc = "An optional value carrying extra information about the client."]
        #[serde(rename = "value", default)]
        pub value: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for FileDriveSource {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct FileFolderProperties {
        #[doc = "This is a sync folder."]
        #[serde(rename = "arbitrarySyncFolder", default)]
        pub arbitrary_sync_folder: ::std::option::Option<bool>,
        #[doc = "This is a external media folder."]
        #[serde(rename = "externalMedia", default)]
        pub external_media: ::std::option::Option<bool>,
        #[doc = "This is a root directory of a machine sync."]
        #[serde(rename = "machineRoot", default)]
        pub machine_root: ::std::option::Option<bool>,
        #[doc = "This is a photo and video only folder."]
        #[serde(rename = "photosAndVideosOnly", default)]
        pub photos_and_videos_only: ::std::option::Option<bool>,
        #[doc = "This folder is part of the user's Pyncho directory, but not the root."]
        #[serde(rename = "psynchoFolder", default)]
        pub psyncho_folder: ::std::option::Option<bool>,
        #[doc = "This folder is the user's Pyncho root directory."]
        #[serde(rename = "psynchoRoot", default)]
        pub psyncho_root: ::std::option::Option<bool>,
    }
    impl ::field_selector::FieldSelector for FileFolderProperties {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct FileImageMediaMetadataLocation {
        #[doc = "The altitude stored in the image."]
        #[serde(rename = "altitude", default)]
        pub altitude: ::std::option::Option<f64>,
        #[doc = "The latitude stored in the image."]
        #[serde(rename = "latitude", default)]
        pub latitude: ::std::option::Option<f64>,
        #[doc = "The longitude stored in the image."]
        #[serde(rename = "longitude", default)]
        pub longitude: ::std::option::Option<f64>,
    }
    impl ::field_selector::FieldSelector for FileImageMediaMetadataLocation {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct FileImageMediaMetadata {
        #[doc = "The aperture used to create the photo (f-number)."]
        #[serde(rename = "aperture", default)]
        pub aperture: ::std::option::Option<f32>,
        #[doc = "The make of the camera used to create the photo."]
        #[serde(rename = "cameraMake", default)]
        pub camera_make: ::std::option::Option<String>,
        #[doc = "The model of the camera used to create the photo."]
        #[serde(rename = "cameraModel", default)]
        pub camera_model: ::std::option::Option<String>,
        #[doc = "The color space of the photo."]
        #[serde(rename = "colorSpace", default)]
        pub color_space: ::std::option::Option<String>,
        #[doc = "The date and time the photo was taken (EXIF format timestamp)."]
        #[serde(rename = "date", default)]
        pub date: ::std::option::Option<String>,
        #[doc = "The exposure bias of the photo (APEX value)."]
        #[serde(rename = "exposureBias", default)]
        pub exposure_bias: ::std::option::Option<f32>,
        #[doc = "The exposure mode used to create the photo."]
        #[serde(rename = "exposureMode", default)]
        pub exposure_mode: ::std::option::Option<String>,
        #[doc = "The length of the exposure, in seconds."]
        #[serde(rename = "exposureTime", default)]
        pub exposure_time: ::std::option::Option<f32>,
        #[doc = "Whether a flash was used to create the photo."]
        #[serde(rename = "flashUsed", default)]
        pub flash_used: ::std::option::Option<bool>,
        #[doc = "The focal length used to create the photo, in millimeters."]
        #[serde(rename = "focalLength", default)]
        pub focal_length: ::std::option::Option<f32>,
        #[doc = "The height of the image in pixels."]
        #[serde(rename = "height", default)]
        pub height: ::std::option::Option<i32>,
        #[doc = "The ISO speed used to create the photo."]
        #[serde(rename = "isoSpeed", default)]
        pub iso_speed: ::std::option::Option<i32>,
        #[doc = "The lens used to create the photo."]
        #[serde(rename = "lens", default)]
        pub lens: ::std::option::Option<String>,
        #[doc = "Geographic location information stored in the image."]
        #[serde(rename = "location", default)]
        pub location: ::std::option::Option<crate::schemas::FileImageMediaMetadataLocation>,
        #[doc = "The smallest f-number of the lens at the focal length used to create the photo (APEX value)."]
        #[serde(rename = "maxApertureValue", default)]
        pub max_aperture_value: ::std::option::Option<f32>,
        #[doc = "The metering mode used to create the photo."]
        #[serde(rename = "meteringMode", default)]
        pub metering_mode: ::std::option::Option<String>,
        #[doc = "The rotation in clockwise degrees from the image's original orientation."]
        #[serde(rename = "rotation", default)]
        pub rotation: ::std::option::Option<i32>,
        #[doc = "The type of sensor used to create the photo."]
        #[serde(rename = "sensor", default)]
        pub sensor: ::std::option::Option<String>,
        #[doc = "The distance to the subject of the photo, in meters."]
        #[serde(rename = "subjectDistance", default)]
        pub subject_distance: ::std::option::Option<i32>,
        #[doc = "The white balance mode used to create the photo."]
        #[serde(rename = "whiteBalance", default)]
        pub white_balance: ::std::option::Option<String>,
        #[doc = "The width of the image in pixels."]
        #[serde(rename = "width", default)]
        pub width: ::std::option::Option<i32>,
    }
    impl ::field_selector::FieldSelector for FileImageMediaMetadata {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct FileIndexableText {
        #[doc = "The text to be indexed for this file."]
        #[serde(rename = "text", default)]
        pub text: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for FileIndexableText {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct FileLabels {
        #[doc = "Deprecated."]
        #[serde(rename = "hidden", default)]
        pub hidden: ::std::option::Option<bool>,
        #[doc = "Whether the file has been modified by this user."]
        #[serde(rename = "modified", default)]
        pub modified: ::std::option::Option<bool>,
        #[doc = "Deprecated - use copyRequiresWriterPermission instead."]
        #[serde(rename = "restricted", default)]
        pub restricted: ::std::option::Option<bool>,
        #[doc = "Whether this file is starred by the user."]
        #[serde(rename = "starred", default)]
        pub starred: ::std::option::Option<bool>,
        #[doc = "Whether this file has been trashed. This label applies to all users accessing the file; however, only owners are allowed to see and untrash files."]
        #[serde(rename = "trashed", default)]
        pub trashed: ::std::option::Option<bool>,
        #[doc = "Whether this file has been viewed by this user."]
        #[serde(rename = "viewed", default)]
        pub viewed: ::std::option::Option<bool>,
    }
    impl ::field_selector::FieldSelector for FileLabels {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct FilePermissionsSummaryVisibilityItems {
        #[doc = "Additional roles for this user. Only commenter is currently possible."]
        #[serde(rename = "additionalRoles", default)]
        pub additional_roles: ::std::option::Option<Vec<String>>,
        #[doc = "The domain of the entity the permission refers to. This is present when the visibility type is domain."]
        #[serde(rename = "domain", default)]
        pub domain: ::std::option::Option<String>,
        #[doc = "The domain name of the entity the permission refers to. This is present when the visibility type is domain."]
        #[serde(rename = "domainDisplayName", default)]
        pub domain_display_name: ::std::option::Option<String>,
        #[doc = "The ID of the permission that corresponds to this visibility."]
        #[serde(rename = "permissionId", default)]
        pub permission_id: ::std::option::Option<String>,
        #[doc = "The type of the visibility. Possible values are:\n\n* domain \n* anyone"]
        #[serde(rename = "type", default)]
        pub r#type: ::std::option::Option<String>,
        #[doc = "The primary role for this user. While new values may be supported in the future, the following are currently possible:\n\n* reader \n* writer"]
        #[serde(rename = "role", default)]
        pub role: ::std::option::Option<String>,
        #[doc = "Whether the link is required for the permission."]
        #[serde(rename = "withLink", default)]
        pub with_link: ::std::option::Option<bool>,
    }
    impl ::field_selector::FieldSelector for FilePermissionsSummaryVisibilityItems {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct FilePermissionsSummary {
        #[doc = "Total number of permission entries. This includes entries not in \"selectPermissions\"."]
        #[serde(rename = "entryCount", default)]
        pub entry_count: ::std::option::Option<i32>,
        #[doc = "A selection of at most 10 entries from permissions on this file."]
        #[serde(rename = "selectPermissions", default)]
        pub select_permissions: ::std::option::Option<Vec<crate::schemas::Permission>>,
        #[doc = "Visibility of the document (e.g. link shared to anyone, domain shared)."]
        #[serde(rename = "visibility", default)]
        pub visibility:
            ::std::option::Option<Vec<crate::schemas::FilePermissionsSummaryVisibilityItems>>,
    }
    impl ::field_selector::FieldSelector for FilePermissionsSummary {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct FilePreview2 {
        #[doc = "The time at which preview link expires (formatted RFC 3339 timestamp)."]
        #[serde(rename = "expiryDate", default)]
        pub expiry_date: ::std::option::Option<::chrono::DateTime<chrono::offset::Utc>>,
        #[doc = "A short-lived Senna upload URL."]
        #[serde(rename = "link", default)]
        pub link: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for FilePreview2 {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct FilePublishingInfo {
        #[doc = "Whether the file has been published."]
        #[serde(rename = "published", default)]
        pub published: ::std::option::Option<bool>,
        #[doc = "The URL for the published view of the file."]
        #[serde(rename = "publishedUrl", default)]
        pub published_url: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for FilePublishingInfo {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct FileShortcutDetails {
        #[doc = "The file that the shortcut points to. The nested file resource will be populated with the same fields requested for the shortcut resource. The field will be absent if the target cannot be retrieved because it has been deleted or is inaccessible to the requester. The targetLookupStatus field will indicate the status of the target lookup. Note that a shortcut is not allowed to point to another shortcut, so this field can only return a single nested target file."]
        #[serde(rename = "targetFile", default)]
        pub target_file: ::std::option::Option<Box<crate::schemas::File>>,
        #[doc = "The ID of the file that this shortcut points to."]
        #[serde(rename = "targetId", default)]
        pub target_id: ::std::option::Option<String>,
        #[doc = "The status of the shortcut target lookup operation, as a canonical code. The values expected here are:\n\n* ok</code \n* notFound \n* permissionDenied"]
        #[serde(rename = "targetLookupStatus", default)]
        pub target_lookup_status: ::std::option::Option<String>,
        #[doc = "The MIME type of the file that this shortcut points to. The value of this field is a snapshot and is only populated when a shortcut is created."]
        #[serde(rename = "targetMimeType", default)]
        pub target_mime_type: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for FileShortcutDetails {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct FileSource {
        #[doc = "The unique identifier for the client, limited to the values in DriveSource.ClientService"]
        #[serde(rename = "client_service_id", default)]
        pub client_service_id: ::std::option::Option<String>,
        #[doc = "An optional value carrying extra information about the client."]
        #[serde(rename = "value", default)]
        pub value: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for FileSource {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct FileTemplateData {
        #[doc = "Categories for template. For domain templates, this is a list of strings each of which represent one category available for the domain."]
        #[serde(rename = "category", default)]
        pub category: ::std::option::Option<Vec<String>>,
        #[doc = "Description for template."]
        #[serde(rename = "description", default)]
        pub description: ::std::option::Option<String>,
        #[doc = "Gallery state for template which decides whether the template should be shown in the templates gallery or not. This can be one of: 1. AVAILABLE 2. UNAVAILABLE."]
        #[serde(rename = "galleryState", default)]
        pub gallery_state: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for FileTemplateData {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct FileThumbnail {
        #[doc = "The URL-safe Base64 encoded bytes of the thumbnail image. It should conform to RFC 4648 section 5."]
        #[serde(rename = "image", default)]
        pub image: ::std::option::Option<crate::bytes::Bytes>,
        #[doc = "The MIME type of the thumbnail."]
        #[serde(rename = "mimeType", default)]
        pub mime_type: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for FileThumbnail {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct FileVideoMediaMetadata {
        #[doc = "The duration of the video in milliseconds."]
        #[serde(rename = "durationMillis", default)]
        #[serde(with = "crate::parsed_string")]
        pub duration_millis: ::std::option::Option<i64>,
        #[doc = "The height of the video in pixels."]
        #[serde(rename = "height", default)]
        pub height: ::std::option::Option<i32>,
        #[doc = "The width of the video in pixels."]
        #[serde(rename = "width", default)]
        pub width: ::std::option::Option<i32>,
    }
    impl ::field_selector::FieldSelector for FileVideoMediaMetadata {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct File {
        #[doc = "Action items for the current user on this file."]
        #[serde(rename = "actionItems", default)]
        pub action_items: ::std::option::Option<Vec<crate::schemas::ActionItem>>,
        #[doc = "A link for opening the file in a relevant Google editor or viewer."]
        #[serde(rename = "alternateLink", default)]
        pub alternate_link: ::std::option::Option<String>,
        #[doc = "If set, this item will be sync'd to Photos with a flag indicating it should always be shown even if Google Drive objects are filtered out. This is intended for use only by the Google Drive/Photos unified uploader, and will be enforced by a whitelist."]
        #[serde(rename = "alwaysShowInPhotos", default)]
        pub always_show_in_photos: ::std::option::Option<bool>,
        #[doc = "Whether this file is in the appdata folder."]
        #[serde(rename = "appDataContents", default)]
        pub app_data_contents: ::std::option::Option<bool>,
        #[doc = "Names of categories that have been applied to the file."]
        #[serde(rename = "appliedCategories", default)]
        pub applied_categories: ::std::option::Option<Vec<String>>,
        #[doc = "Metadata regarding Approvals associated with this file."]
        #[serde(rename = "approvalMetadata", default)]
        pub approval_metadata: ::std::option::Option<crate::schemas::FileApprovalMetadata>,
        #[doc = "The apps that are authorized to this file. This is only populated when the drive.apps scope is used."]
        #[serde(rename = "authorizedAppIds", default)]
        pub authorized_app_ids: ::std::option::Option<Vec<String>>,
        #[doc = "A list of DLP detector names for the file with blocking consequences."]
        #[serde(rename = "blockingDetectors", default)]
        pub blocking_detectors: ::std::option::Option<Vec<String>>,
        #[doc = "Deprecated: use capabilities/canComment."]
        #[serde(rename = "canComment", default)]
        pub can_comment: ::std::option::Option<bool>,
        #[doc = "Capabilities the current user has on this file. Each capability corresponds to a fine-grained action that a user may take."]
        #[serde(rename = "capabilities", default)]
        pub capabilities: ::std::option::Option<crate::schemas::FileCapabilities>,
        #[doc = "Category Metadata that have been applied to the file, keyed by the category name. To include Category Metadata on a file, both this field must be requested, and the categoryMetadataNames query param must be populated with the desired Category Metadata to include. For example: categoryMetadataNames='category_1,category_5', fields='categoryMetadata'"]
        #[serde(rename = "categoryMetadata", default)]
        pub category_metadata: ::std::option::Option<
            ::std::collections::BTreeMap<String, crate::schemas::CategoryMetadata>,
        >,
        #[doc = "Deprecated: value is no longer being written on updates and cannot be trusted. This used to return whether this file has been changed since this user last viewed it."]
        #[serde(rename = "changed", default)]
        pub changed: ::std::option::Option<bool>,
        #[doc = "Client Side Encryption related details. Contains details about the encryption state of the file and details regarding the encryption mechanism that clients need to use when decrypting the contents of this item. This will only be present on files and not on folders or shortcuts."]
        #[serde(rename = "clientEncryptionDetails", default)]
        pub client_encryption_details:
            ::std::option::Option<crate::schemas::FileClientEncryptionDetails>,
        #[doc = "Whether the comments import has finished for the head revision."]
        #[serde(rename = "commentsImported", default)]
        pub comments_imported: ::std::option::Option<bool>,
        #[doc = "Whether this folder contains children that are unsubscribed."]
        #[serde(rename = "containsUnsubscribedChildren", default)]
        pub contains_unsubscribed_children: ::std::option::Option<bool>,
        #[doc = "Deprecated: Use contentRestrictions."]
        #[serde(rename = "contentRestriction", default)]
        pub content_restriction: ::std::option::Option<crate::schemas::FileContentRestriction>,
        #[doc = "Restrictions for accessing the content of the file. Only populated if such a restriction exists."]
        #[serde(rename = "contentRestrictions", default)]
        pub content_restrictions: ::std::option::Option<Vec<crate::schemas::ContentRestriction>>,
        #[doc = "Whether the options to copy, print, or download this file, should be disabled for readers and commenters."]
        #[serde(rename = "copyRequiresWriterPermission", default)]
        pub copy_requires_writer_permission: ::std::option::Option<bool>,
        #[doc = "Deprecated: use capabilities/canCopy."]
        #[serde(rename = "copyable", default)]
        pub copyable: ::std::option::Option<bool>,
        #[doc = "The time at which this file was created, possibly as specified by the uploading client (formatted RFC 3339 timestamp)."]
        #[serde(rename = "createdDate", default)]
        pub created_date: ::std::option::Option<::chrono::DateTime<chrono::offset::Utc>>,
        #[doc = "User that created the item, if available."]
        #[serde(rename = "creator", default)]
        pub creator: ::std::option::Option<crate::schemas::User>,
        #[doc = "The ID of the application that was used to create this file."]
        #[serde(rename = "creatorAppId", default)]
        pub creator_app_id: ::std::option::Option<String>,
        #[doc = "A link to open this file with the user's default app for this file. Only populated when the drive.apps[.readonly] scope is used."]
        #[serde(rename = "defaultOpenWithLink", default)]
        pub default_open_with_link: ::std::option::Option<String>,
        #[doc = "Whether the file is parented under root or any of its subfolders. Note that this field is not completely reliable as there can be propagation delays. Not populated for shared drive files."]
        #[serde(rename = "descendantOfRoot", default)]
        pub descendant_of_root: ::std::option::Option<bool>,
        #[doc = "A short description of the file."]
        #[serde(rename = "description", default)]
        pub description: ::std::option::Option<String>,
        #[doc = "A list of DLP detector names for the file. These detectors have consequence, for example blocking sharing. DLP detectors without consequences will not appear in this list. Consider using blockingDetectors and warningDetectors instead if the type of consequence is important."]
        #[serde(rename = "detectors", default)]
        pub detectors: ::std::option::Option<Vec<String>>,
        #[serde(rename = "downloadUrl", default)]
        pub download_url: ::std::option::Option<String>,
        #[doc = "ID of the shared drive the file resides in. Only populated for items in shared drives."]
        #[serde(rename = "driveId", default)]
        pub drive_id: ::std::option::Option<String>,
        #[doc = "The client that created an item."]
        #[serde(rename = "driveSource", default)]
        pub drive_source: ::std::option::Option<crate::schemas::FileDriveSource>,
        #[doc = "Deprecated: use capabilities/canEdit."]
        #[serde(rename = "editable", default)]
        pub editable: ::std::option::Option<bool>,
        #[doc = "Internal field efficiency info."]
        #[serde(rename = "efficiencyInfo", default)]
        pub efficiency_info: ::std::option::Option<crate::schemas::Efficiency>,
        #[doc = "A link for embedding the file."]
        #[serde(rename = "embedLink", default)]
        pub embed_link: ::std::option::Option<String>,
        #[doc = "Whether this file is embedded within a package. Applications must be whitelisted to read this field."]
        #[serde(rename = "embedded", default)]
        pub embedded: ::std::option::Option<bool>,
        #[doc = "On write, the ID of the embedding parent file in which to embed this file. If the parent file belongs to a package the file is added to the same package, otherwise a new package is created with the ID of the parent file. On Read, the file ID of the embedding parent of this file within a package. Only present if the file is embedded in a package. Applications must be whitelisted to write or read this field."]
        #[serde(rename = "embeddingParent", default)]
        pub embedding_parent: ::std::option::Option<String>,
        #[doc = "ETag of the file."]
        #[serde(rename = "etag", default)]
        pub etag: ::std::option::Option<String>,
        #[doc = "Whether this file has been explicitly trashed, as opposed to recursively trashed."]
        #[serde(rename = "explicitlyTrashed", default)]
        pub explicitly_trashed: ::std::option::Option<bool>,
        #[doc = "Links for exporting Google Docs to specific formats."]
        #[serde(rename = "exportLinks", default)]
        pub export_links: ::std::option::Option<::std::collections::BTreeMap<String, String>>,
        #[doc = "The final component of fullFileExtension with trailing text that does not appear to be part of the extension removed. This field is only populated for files with content stored in Google Drive; it is not populated for Google Docs or shortcut files."]
        #[serde(rename = "fileExtension", default)]
        pub file_extension: ::std::option::Option<String>,
        #[doc = "The size of the file in bytes. This field is only populated for files with content stored in Google Drive; it is not populated for Google Docs or shortcut files."]
        #[serde(rename = "fileSize", default)]
        #[serde(with = "crate::parsed_string")]
        pub file_size: ::std::option::Option<i64>,
        #[doc = "Whether the file is flagged for abuse."]
        #[serde(rename = "flaggedForAbuse", default)]
        pub flagged_for_abuse: ::std::option::Option<bool>,
        #[doc = "Folder color (palette index) if the file is a folder. Not populated for shared drive files."]
        #[serde(rename = "folderColor", default)]
        #[serde(with = "crate::parsed_string")]
        pub folder_color: ::std::option::Option<i64>,
        #[doc = "Folder color as an RGB hex string if the file is a folder. The list of supported colors is available in the folderColorPalette field of the About resource. If an unsupported color is specified, it will be changed to the closest color in the palette. Not populated for shared drive files."]
        #[serde(rename = "folderColorRgb", default)]
        pub folder_color_rgb: ::std::option::Option<String>,
        #[doc = "Additional attributes for a folder. DEPRECATED: use folderProperties instead"]
        #[serde(rename = "folderFeatures", default)]
        pub folder_features: ::std::option::Option<Vec<String>>,
        #[serde(rename = "folderProperties", default)]
        pub folder_properties: ::std::option::Option<crate::schemas::FileFolderProperties>,
        #[doc = "The full file extension; extracted from the title. May contain multiple concatenated extensions, such as \"tar.gz\". Removing an extension from the title does not clear this field; however, changing the extension on the title does update this field. This field is only populated for files with content stored in Google Drive; it is not populated for Google Docs or shortcut files."]
        #[serde(rename = "fullFileExtension", default)]
        pub full_file_extension: ::std::option::Option<String>,
        #[doc = "Whether this file is a Google+ photo or video. Deleting such a file also deletes it from Google+."]
        #[serde(rename = "gplusMedia", default)]
        pub gplus_media: ::std::option::Option<bool>,
        #[doc = "Whether the file has an Apps Script add-on attached."]
        #[serde(rename = "hasAppsScriptAddOn", default)]
        pub has_apps_script_add_on: ::std::option::Option<bool>,
        #[doc = "Whether any users are granted file access directly on this file. This field is only populated for shared drive files."]
        #[serde(rename = "hasAugmentedPermissions", default)]
        pub has_augmented_permissions: ::std::option::Option<bool>,
        #[doc = "Whether the folder has one or more child folders."]
        #[serde(rename = "hasChildFolders", default)]
        pub has_child_folders: ::std::option::Option<bool>,
        #[doc = "Whether the file has a comment."]
        #[serde(rename = "hasComment", default)]
        pub has_comment: ::std::option::Option<bool>,
        #[doc = "Whether the file has legacy blob comments."]
        #[serde(rename = "hasLegacyBlobComments", default)]
        pub has_legacy_blob_comments: ::std::option::Option<bool>,
        #[doc = "Whether the file has permissions for a view."]
        #[serde(rename = "hasPermissionsForViews", default)]
        pub has_permissions_for_views: ::std::option::Option<bool>,
        #[doc = "Whether a DLP detector exists with a restrict download consequence."]
        #[serde(rename = "hasPreventDownloadConsequence", default)]
        pub has_prevent_download_consequence: ::std::option::Option<bool>,
        #[doc = "Whether this file has a thumbnail. This does not indicate whether the requesting app has access to the thumbnail. To check access, look for the presence of the thumbnailLink field."]
        #[serde(rename = "hasThumbnail", default)]
        pub has_thumbnail: ::std::option::Option<bool>,
        #[doc = "Whether there is a visitor entry on this file for any user. This field is only populated for shared drive files."]
        #[serde(rename = "hasVisitorPermissions", default)]
        pub has_visitor_permissions: ::std::option::Option<bool>,
        #[doc = "The creation date of the file's head revision (formatted RFC 3339 timestamp). This will only be populated for files with content stored in Google Drive; it is not populated for Google Docs or shortcut files."]
        #[serde(rename = "headRevisionCreationDate", default)]
        pub head_revision_creation_date:
            ::std::option::Option<::chrono::DateTime<chrono::offset::Utc>>,
        #[doc = "The ID of the file's head revision. This field is only populated for files with content stored in Google Drive; it is not populated for Google Docs or shortcut files."]
        #[serde(rename = "headRevisionId", default)]
        pub head_revision_id: ::std::option::Option<String>,
        #[doc = "A link to the file's icon."]
        #[serde(rename = "iconLink", default)]
        pub icon_link: ::std::option::Option<String>,
        #[doc = "The ID of the file."]
        #[serde(rename = "id", default)]
        pub id: ::std::option::Option<String>,
        #[doc = "Metadata about image media. This will only be present for image types, and its contents will depend on what can be parsed from the image content."]
        #[serde(rename = "imageMediaMetadata", default)]
        pub image_media_metadata: ::std::option::Option<crate::schemas::FileImageMediaMetadata>,
        #[doc = "Indexable text attributes for the file (can only be written)"]
        #[serde(rename = "indexableText", default)]
        pub indexable_text: ::std::option::Option<crate::schemas::FileIndexableText>,
        #[doc = "Whether the file was created or opened by the requesting app."]
        #[serde(rename = "isAppAuthorized", default)]
        pub is_app_authorized: ::std::option::Option<bool>,
        #[doc = "Whether lossy compression has been applied to the original file contents."]
        #[serde(rename = "isCompressed", default)]
        pub is_compressed: ::std::option::Option<bool>,
        #[doc = "The type of file. This is always drive#file."]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
        #[doc = "A group of labels for the file."]
        #[serde(rename = "labels", default)]
        pub labels: ::std::option::Option<crate::schemas::FileLabels>,
        #[doc = "The last user to modify this file."]
        #[serde(rename = "lastModifyingUser", default)]
        pub last_modifying_user: ::std::option::Option<crate::schemas::User>,
        #[doc = "Name of the last user to modify this file."]
        #[serde(rename = "lastModifyingUserName", default)]
        pub last_modifying_user_name: ::std::option::Option<String>,
        #[doc = "Last time this file was viewed by the user (formatted RFC 3339 timestamp)."]
        #[serde(rename = "lastViewedByMeDate", default)]
        pub last_viewed_by_me_date: ::std::option::Option<::chrono::DateTime<chrono::offset::Utc>>,
        #[doc = "The local ID used when creating this file."]
        #[serde(rename = "localId", default)]
        pub local_id: ::std::option::Option<crate::schemas::FileLocalId>,
        #[doc = "Deprecated."]
        #[serde(rename = "markedViewedByMeDate", default)]
        pub marked_viewed_by_me_date:
            ::std::option::Option<::chrono::DateTime<chrono::offset::Utc>>,
        #[doc = "An MD5 checksum for the content of this file. This field is only populated for files with content stored in Google Drive; it is not populated for Google Docs or shortcut files."]
        #[serde(rename = "md5Checksum", default)]
        pub md_5_checksum: ::std::option::Option<String>,
        #[doc = "The MIME type of the file. This is only mutable on update when uploading new content. This field can be left blank, and the mimetype will be determined from the uploaded content's MIME type."]
        #[serde(rename = "mimeType", default)]
        pub mime_type: ::std::option::Option<String>,
        #[doc = "Last time this file was modified by the user (formatted RFC 3339 timestamp). Note that setting modifiedDate will also update the modifiedByMe date for the user which set the date."]
        #[serde(rename = "modifiedByMeDate", default)]
        pub modified_by_me_date: ::std::option::Option<::chrono::DateTime<chrono::offset::Utc>>,
        #[doc = "Last time this file was modified by anyone (formatted RFC 3339 timestamp). This is only mutable on update when the setModifiedDate parameter is set."]
        #[serde(rename = "modifiedDate", default)]
        pub modified_date: ::std::option::Option<::chrono::DateTime<chrono::offset::Utc>>,
        #[doc = "A map of the id of each of the user's apps to a link to open this file with that app. Only populated when the drive.apps[.readonly] scope is used."]
        #[serde(rename = "openWithLinks", default)]
        pub open_with_links: ::std::option::Option<::std::collections::BTreeMap<String, String>>,
        #[doc = "The displayable name of the organization to which this file belongs."]
        #[serde(rename = "organizationDisplayName", default)]
        pub organization_display_name: ::std::option::Option<String>,
        #[doc = "The size in bytes of the original file contents before lossy compression was applied. Only populated if the file contents are not identical to the original file contents."]
        #[serde(rename = "originalFileSize", default)]
        #[serde(with = "crate::parsed_string")]
        pub original_file_size: ::std::option::Option<i64>,
        #[doc = "The original filename of the uploaded content if available, or else the original value of the title field. This is only available for files with binary content in Google Drive."]
        #[serde(rename = "originalFilename", default)]
        pub original_filename: ::std::option::Option<String>,
        #[doc = "The MD5 checksum (as a hex-encoded string) of the original file contents before lossy compression was applied. Only populated if the file contents are not identical to the original file contents."]
        #[serde(rename = "originalMd5Checksum", default)]
        pub original_md_5_checksum: ::std::option::Option<String>,
        #[doc = "Whether the file is owned by the current user. Not populated for shared drive files."]
        #[serde(rename = "ownedByMe", default)]
        pub owned_by_me: ::std::option::Option<bool>,
        #[doc = "Name(s) of the owner(s) of this file. Not populated for shared drive files."]
        #[serde(rename = "ownerNames", default)]
        pub owner_names: ::std::option::Option<Vec<String>>,
        #[doc = "The owner(s) of this file. Not populated for shared drive files."]
        #[serde(rename = "owners", default)]
        pub owners: ::std::option::Option<Vec<crate::schemas::User>>,
        #[doc = "The total size of the package in which this file is embedded. Only present when the file is embedded within a package. Applications must be whitelisted to read this field."]
        #[serde(rename = "packageFileSize", default)]
        #[serde(with = "crate::parsed_string")]
        pub package_file_size: ::std::option::Option<i64>,
        #[doc = "The package ID of the file, which is the same as the ID of the root file of this package. Only present if the file is embedded in a package. Applications must be whitelisted to read this field."]
        #[serde(rename = "packageId", default)]
        pub package_id: ::std::option::Option<String>,
        #[doc = "The type of the ShadowDoc (go/shadowdocsdd) associated with the file. Possible values are:\n\n* docs \n* sheets \n* slides"]
        #[serde(rename = "pairedDocType", default)]
        pub paired_doc_type: ::std::option::Option<String>,
        #[doc = "Collection of parent folders which contain this file.\nIf not specified as part of an insert request, the file will be placed directly in the user's My Drive folder. If not specified as part of a copy request, the file will inherit any discoverable parents of the source file. Update requests can also use the addParents and removeParents parameters to modify the parents list."]
        #[serde(rename = "parents", default)]
        pub parents: ::std::option::Option<Vec<crate::schemas::ParentReference>>,
        #[doc = "Whether the current user is passively subscribed to this item."]
        #[serde(rename = "passivelySubscribed", default)]
        pub passively_subscribed: ::std::option::Option<bool>,
        #[doc = "List of permission IDs for users with access to this file."]
        #[serde(rename = "permissionIds", default)]
        pub permission_ids: ::std::option::Option<Vec<String>>,
        #[doc = "The list of permissions for users with access to this file. Not populated for shared drive files."]
        #[serde(rename = "permissions", default)]
        pub permissions: ::std::option::Option<Vec<crate::schemas::Permission>>,
        #[doc = "A summary of the permissions on this file. This is an output-only field."]
        #[serde(rename = "permissionsSummary", default)]
        pub permissions_summary: ::std::option::Option<crate::schemas::FilePermissionsSummary>,
        #[doc = "For image and video files, the status of the lossy compression."]
        #[serde(rename = "photosCompressionStatus", default)]
        pub photos_compression_status: ::std::option::Option<String>,
        #[doc = "For image and video files, the storage policy for the file."]
        #[serde(rename = "photosStoragePolicy", default)]
        pub photos_storage_policy: ::std::option::Option<String>,
        #[doc = "Resource to use for go/senna previews."]
        #[serde(rename = "preview", default)]
        pub preview: ::std::option::Option<crate::schemas::FilePreview2>,
        #[doc = "The DNS domain name of the primary domain of the organization to which this file belongs."]
        #[serde(rename = "primaryDomainName", default)]
        pub primary_domain_name: ::std::option::Option<String>,
        #[doc = "The parent folder of the document that is also root or a subfolder of root. Note that this field is not completely reliable as there can be propagation delays. Not populated for shared drive files."]
        #[serde(rename = "primarySyncParentId", default)]
        pub primary_sync_parent_id: ::std::option::Option<String>,
        #[doc = "The list of properties."]
        #[serde(rename = "properties", default)]
        pub properties: ::std::option::Option<Vec<crate::schemas::Property>>,
        #[doc = "Publish information related to a view."]
        #[serde(rename = "publishingInfo", default)]
        pub publishing_info: ::std::option::Option<crate::schemas::FilePublishingInfo>,
        #[doc = "The number of quota bytes used by this file."]
        #[serde(rename = "quotaBytesUsed", default)]
        #[serde(with = "crate::parsed_string")]
        pub quota_bytes_used: ::std::option::Option<i64>,
        #[doc = "Deprecated: use capabilities/canRead."]
        #[serde(rename = "readable", default)]
        pub readable: ::std::option::Option<bool>,
        #[doc = "Whether a reader can see comments on the file."]
        #[serde(rename = "readersCanSeeComments", default)]
        pub readers_can_see_comments: ::std::option::Option<bool>,
        #[doc = "An RFC 3339 timestamp which is used as the sorting field for the sort order of the same name."]
        #[serde(rename = "recency", default)]
        pub recency: ::std::option::Option<::chrono::DateTime<chrono::offset::Utc>>,
        #[doc = "The reason for the current recency. Possible values are:\n\n* createdByMe \n* modifiedByMe \n* modified \n* viewedByMe"]
        #[serde(rename = "recencyReason", default)]
        pub recency_reason: ::std::option::Option<String>,
        #[doc = "Recursive number of sub-items for this folder. Zero for non-folders and empty folders."]
        #[serde(rename = "recursiveFileCount", default)]
        #[serde(with = "crate::parsed_string")]
        pub recursive_file_count: ::std::option::Option<i64>,
        #[doc = "File size in bytes for this file and all sub-items."]
        #[serde(rename = "recursiveFileSize", default)]
        #[serde(with = "crate::parsed_string")]
        pub recursive_file_size: ::std::option::Option<i64>,
        #[doc = "The number of bytes charged to the requesting user's quota for this file and all sub-items."]
        #[serde(rename = "recursiveQuotaBytesUsed", default)]
        #[serde(with = "crate::parsed_string")]
        pub recursive_quota_bytes_used: ::std::option::Option<i64>,
        #[doc = "A link back to this file."]
        #[serde(rename = "selfLink", default)]
        pub self_link: ::std::option::Option<String>,
        #[doc = "The time at which this file was created from the perspective of the server (formatted RFC 3339 timestamp)."]
        #[serde(rename = "serverCreatedDate", default)]
        pub server_created_date: ::std::option::Option<::chrono::DateTime<chrono::offset::Utc>>,
        #[doc = "The SHA1 checksums associated with this file. Cosmo doesn't store SHA1 for files, so this is only populated for files returned from a query using the sha1 query term. Photos and videos that are compressed will have both an original and a high quality checksum. Original quality photos and videos will only have one checksum."]
        #[serde(rename = "sha1Checksums", default)]
        pub sha_1_checksums: ::std::option::Option<Vec<String>>,
        #[doc = "A link to the sharing UI for this file."]
        #[serde(rename = "shareLink", default)]
        pub share_link: ::std::option::Option<String>,
        #[doc = "Deprecated: use capabilities/canShare."]
        #[serde(rename = "shareable", default)]
        pub shareable: ::std::option::Option<bool>,
        #[doc = "Whether the file has been shared. Not populated for shared drive files."]
        #[serde(rename = "shared", default)]
        pub shared: ::std::option::Option<bool>,
        #[doc = "Time at which this file was shared with the user (formatted RFC 3339 timestamp)."]
        #[serde(rename = "sharedWithMeDate", default)]
        pub shared_with_me_date: ::std::option::Option<::chrono::DateTime<chrono::offset::Utc>>,
        #[doc = "User that shared the item with the current user, if available."]
        #[serde(rename = "sharingUser", default)]
        pub sharing_user: ::std::option::Option<crate::schemas::User>,
        #[doc = "Shortcut file details. Only populated for shortcut files, which have the mimeType field set to application/vnd.google-apps.shortcut."]
        #[serde(rename = "shortcutDetails", default)]
        pub shortcut_details: ::std::option::Option<Box<crate::schemas::FileShortcutDetails>>,
        #[doc = "Deprecated: This field is being moved into shortcutDetails, however it's still read during creation."]
        #[serde(rename = "shortcutTargetId", default)]
        pub shortcut_target_id: ::std::option::Option<String>,
        #[doc = "Deprecated: This field is being moved into shortcutDetails."]
        #[serde(rename = "shortcutTargetMimeType", default)]
        pub shortcut_target_mime_type: ::std::option::Option<String>,
        #[doc = "The client that created an item. Deprecated: use driveSource"]
        #[serde(rename = "source", default)]
        pub source: ::std::option::Option<crate::schemas::FileSource>,
        #[doc = "The ID of the application that was used to create this file. This may be a superset of creatorAppId, but for the Drive Sources work, we weren't interested in merging the two fields."]
        #[serde(rename = "sourceAppId", default)]
        pub source_app_id: ::std::option::Option<String>,
        #[doc = "Field not implemented, subject to change."]
        #[serde(rename = "sources", default)]
        pub sources: ::std::option::Option<::serde_json::Value>,
        #[doc = "The list of spaces which contain the file. Supported values are 'drive', 'appDataFolder', 'photos' and 'androidBackup'."]
        #[serde(rename = "spaces", default)]
        pub spaces: ::std::option::Option<Vec<String>>,
        #[doc = "Compression is underway or being attempted and the final \"isCompressed\" state is TBD."]
        #[serde(rename = "storagePolicyPending", default)]
        pub storage_policy_pending: ::std::option::Option<bool>,
        #[doc = "Whether the current user is subscribed to this item."]
        #[serde(rename = "subscribed", default)]
        pub subscribed: ::std::option::Option<bool>,
        #[doc = "A list of roles supported by this file type. Possible values are:\n\n* owner \n* organizer \n* fileOrganizer \n* writer \n* commenter \n* reader \n* published_reader"]
        #[serde(rename = "supportedRoles", default)]
        pub supported_roles: ::std::option::Option<Vec<String>>,
        #[doc = "Deprecated - use driveId instead."]
        #[serde(rename = "teamDriveId", default)]
        pub team_drive_id: ::std::option::Option<String>,
        #[doc = "Template Data attached to a Google document. This data is present if document is a template."]
        #[serde(rename = "templateData", default)]
        pub template_data: ::std::option::Option<crate::schemas::FileTemplateData>,
        #[doc = "A thumbnail for the file. This will only be used if a standard thumbnail cannot be generated."]
        #[serde(rename = "thumbnail", default)]
        pub thumbnail: ::std::option::Option<crate::schemas::FileThumbnail>,
        #[doc = "A short-lived link to the file's thumbnail. Typically lasts on the order of hours. Only populated when the requesting app can access the file's content."]
        #[serde(rename = "thumbnailLink", default)]
        pub thumbnail_link: ::std::option::Option<String>,
        #[doc = "The thumbnail version for use in thumbnail cache invalidation."]
        #[serde(rename = "thumbnailVersion", default)]
        #[serde(with = "crate::parsed_string")]
        pub thumbnail_version: ::std::option::Option<i64>,
        #[doc = "The title of this file. Note that for immutable items such as the top level folders of shared drives, My Drive root folder, and Application Data folder the title is constant."]
        #[serde(rename = "title", default)]
        pub title: ::std::option::Option<String>,
        #[doc = "The time that the item was trashed (formatted RFC 3339 timestamp). Only populated for shared drive files."]
        #[serde(rename = "trashedDate", default)]
        pub trashed_date: ::std::option::Option<::chrono::DateTime<chrono::offset::Utc>>,
        #[doc = "If the file has been explicitly trashed, the user who trashed it. Only populated for shared drive files."]
        #[serde(rename = "trashingUser", default)]
        pub trashing_user: ::std::option::Option<crate::schemas::User>,
        #[doc = "The permissions for the authenticated user on this file. Includes a subset of the associated permissions resource. The \"role\" field is always populated. The partial resource uses an ID of \"me\" that differs from the full resource."]
        #[serde(rename = "userPermission", default)]
        pub user_permission: ::std::option::Option<crate::schemas::Permission>,
        #[doc = "A monotonically increasing version number for the file. This reflects every change made to the file on the server, even those not visible to the requesting user."]
        #[serde(rename = "version", default)]
        #[serde(with = "crate::parsed_string")]
        pub version: ::std::option::Option<i64>,
        #[doc = "Metadata about video media. This will only be present for video types."]
        #[serde(rename = "videoMediaMetadata", default)]
        pub video_media_metadata: ::std::option::Option<crate::schemas::FileVideoMediaMetadata>,
        #[doc = "A list of DLP detector names for the file with warning consequences."]
        #[serde(rename = "warningDetectors", default)]
        pub warning_detectors: ::std::option::Option<Vec<String>>,
        #[doc = "A link for downloading the content of the file in a browser using cookie based authentication. In cases where the content is shared publicly, the content can be downloaded without any credentials."]
        #[serde(rename = "webContentLink", default)]
        pub web_content_link: ::std::option::Option<String>,
        #[doc = "A link only available on public folders for viewing their static web assets (HTML, CSS, JS, etc) via Google Drive's Website Hosting."]
        #[serde(rename = "webViewLink", default)]
        pub web_view_link: ::std::option::Option<String>,
        #[doc = "IDs of Workspaces to which the file belongs."]
        #[serde(rename = "workspaceIds", default)]
        pub workspace_ids: ::std::option::Option<Vec<String>>,
        #[doc = "Whether writers can share the document with other users. Not populated for shared drive files."]
        #[serde(rename = "writersCanShare", default)]
        pub writers_can_share: ::std::option::Option<bool>,
    }
    impl ::field_selector::FieldSelector for File {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct FileList {
        #[doc = "Internal field efficiency info."]
        #[serde(rename = "efficiencyInfo", default)]
        pub efficiency_info: ::std::option::Option<crate::schemas::Efficiency>,
        #[doc = "The ETag of the list."]
        #[serde(rename = "etag", default)]
        pub etag: ::std::option::Option<String>,
        #[doc = "Whether the search process was incomplete. If true, then some search results may be missing, since all documents were not searched. This may occur when searching multiple drives with the \"allDrives\" corpora, but all corpora could not be searched. When this happens, it is suggested that clients narrow their query by choosing a different corpus such as \"default\" or \"drive\"."]
        #[serde(rename = "incompleteSearch", default)]
        pub incomplete_search: ::std::option::Option<bool>,
        #[doc = "The list of files. If nextPageToken is populated, then this list may be incomplete and an additional page of results should be fetched."]
        #[serde(rename = "items", default)]
        pub items: ::std::option::Option<Vec<crate::schemas::File>>,
        #[doc = "This is always drive#fileList."]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
        #[doc = "A link to the next page of files."]
        #[serde(rename = "nextLink", default)]
        pub next_link: ::std::option::Option<String>,
        #[doc = "The page token for the next page of files. This will be absent if the end of the files list has been reached. If the token is rejected for any reason, it should be discarded, and pagination should be restarted from the first page of results."]
        #[serde(rename = "nextPageToken", default)]
        pub next_page_token: ::std::option::Option<String>,
        #[doc = "A link back to this list."]
        #[serde(rename = "selfLink", default)]
        pub self_link: ::std::option::Option<String>,
        #[doc = "Spell response data. An example of this would be a correction in the spelling of a query that will likely return more results."]
        #[serde(rename = "spellResponse", default)]
        pub spell_response: ::std::option::Option<crate::schemas::SpellResponseTemplate>,
        #[doc = "List of suggested alternate \"q\" parameter values to use. These alternates are determined by applying natural language processing to the user's input to turn an unstructured query into a structured query."]
        #[serde(rename = "suggestedNlpQueries", default)]
        pub suggested_nlp_queries: ::std::option::Option<Vec<String>>,
    }
    impl ::field_selector::FieldSelector for FileList {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct FileLocalId {
        #[doc = "This is always drive#fileLocalId"]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
        #[doc = "The type of the file this local ID represents."]
        #[serde(rename = "space", default)]
        pub space: ::std::option::Option<String>,
        #[doc = "A per-app-user identifier when combined with space and version."]
        #[serde(rename = "value", default)]
        pub value: ::std::option::Option<String>,
        #[doc = "The version of the conversion protocol used to generate the ID from the file ID."]
        #[serde(rename = "version", default)]
        pub version: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for FileLocalId {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct FilePreview {
        #[doc = "The list of contents of an archive file."]
        #[serde(rename = "archivePreview", default)]
        pub archive_preview: ::std::option::Option<Vec<crate::schemas::ArchiveResourcePreview>>,
        #[doc = "The ETag of the file preview."]
        #[serde(rename = "etag", default)]
        pub etag: ::std::option::Option<String>,
        #[doc = "This is always drive#filePreview."]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
        #[doc = "A link back to this file preview."]
        #[serde(rename = "selfLink", default)]
        pub self_link: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for FilePreview {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct FixPermissionsRequest {
        #[doc = "List of IDs of files whose permissions should be fixed with the specified fix option type."]
        #[serde(rename = "fileIds", default)]
        pub file_ids: ::std::option::Option<Vec<String>>,
        #[doc = "The type of fix to execute for the specified files."]
        #[serde(rename = "fixOptionType", default)]
        pub fix_option_type: ::std::option::Option<String>,
        #[doc = "This is always drive#fixPermissionsRequest."]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
        #[doc = "List of email address to add to the permissions of the specified files if the 'ADD_COLLABORATORS' fix option type is specified."]
        #[serde(rename = "recipientEmailAddresses", default)]
        pub recipient_email_addresses: ::std::option::Option<Vec<String>>,
        #[doc = "Role that should be applied to the files' collaborators (if 'ADD_COLLABORATORS' fix option type is specified) or to users accessing the files via a visible file link (for visibility-related fix option types)."]
        #[serde(rename = "role", default)]
        pub role: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for FixPermissionsRequest {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct GeneratedIds {
        #[doc = "The IDs generated for the requesting user in the specified space."]
        #[serde(rename = "ids", default)]
        pub ids: ::std::option::Option<Vec<String>>,
        #[doc = "This is always drive#generatedIds"]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
        #[doc = "The type of items which can be created with these IDs."]
        #[serde(rename = "type", default)]
        pub r#type: ::std::option::Option<String>,
        #[doc = "The space in which items can be created with these IDs."]
        #[serde(rename = "space", default)]
        pub space: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for GeneratedIds {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct MigrateToDrivePreFlightRequest {
        #[doc = "A token to continue processing a pre-flight request. If the token is rejected for any reason, it should be discarded, and the pre-flight request should be restarted without providing a token."]
        #[serde(rename = "continuationToken", default)]
        pub continuation_token: ::std::option::Option<String>,
        #[doc = "ID of the destination folder. Must be in a shared drive."]
        #[serde(rename = "destinationFolderId", default)]
        pub destination_folder_id: ::std::option::Option<String>,
        #[doc = "This is always drive#migrateToDrivePreFlightRequest."]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
        #[doc = "A set of IDs of files or folders to obtain pre-flight information for."]
        #[serde(rename = "sourceIds", default)]
        pub source_ids: ::std::option::Option<Vec<String>>,
    }
    impl ::field_selector::FieldSelector for MigrateToDrivePreFlightRequest {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct MigrateToDrivePreFlightResponse {
        #[doc = "A continuation token present when additional results can be processed."]
        #[serde(rename = "continuationToken", default)]
        pub continuation_token: ::std::option::Option<String>,
        #[doc = "This is always drive#migrateToDrivePreFlightResponse."]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for MigrateToDrivePreFlightResponse {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct MigrateToTeamDrivePreFlightRequest {
        #[doc = "A token to continue processing a pre-flight request. If the token is rejected for any reason, it should be discarded, and the pre-flight request should be restarted without providing a token."]
        #[serde(rename = "continuationToken", default)]
        pub continuation_token: ::std::option::Option<String>,
        #[doc = "ID of the destination folder. Must be in a Team Drive."]
        #[serde(rename = "destinationFolderId", default)]
        pub destination_folder_id: ::std::option::Option<String>,
        #[doc = "This is always drive#migrateToTeamDrivePreFlightRequest."]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
        #[doc = "A set of IDs of files or folders to obtain pre-flight information for."]
        #[serde(rename = "sourceIds", default)]
        pub source_ids: ::std::option::Option<Vec<String>>,
    }
    impl ::field_selector::FieldSelector for MigrateToTeamDrivePreFlightRequest {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct MigrateToTeamDrivePreFlightResponse {
        #[doc = "A continuation token present when additional results can be processed."]
        #[serde(rename = "continuationToken", default)]
        pub continuation_token: ::std::option::Option<String>,
        #[doc = "This is always drive#migrateToTeamDrivePreFlightResponse."]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for MigrateToTeamDrivePreFlightResponse {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct Money {
        #[doc = "The amount of money."]
        #[serde(rename = "amount", default)]
        pub amount: ::std::option::Option<String>,
        #[doc = "The 3-letter currency code defined in ISO 4217."]
        #[serde(rename = "currencyCode", default)]
        pub currency_code: ::std::option::Option<String>,
        #[doc = "This is always drive#money"]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for Money {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct NextDocPrediction {
        #[doc = "Deprecated: Clients should not depend on this field being present. The explanation code of why this document was predicted. This field is more intended for logging and analysis, rather than for direct display to the user."]
        #[serde(rename = "explanationCode", default)]
        pub explanation_code: ::std::option::Option<i32>,
        #[doc = "The localized (using the provided locale) explanation message for why this document was predicted. The intention is that this message may be shown to the user."]
        #[serde(rename = "explanationMessage", default)]
        pub explanation_message: ::std::option::Option<String>,
        #[doc = "The file resource for the document that was predicted."]
        #[serde(rename = "file", default)]
        pub file: ::std::option::Option<crate::schemas::File>,
        #[doc = "This is always drive#nextDocPrediction."]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
        #[doc = "Deprecated: Clients should not depend on this field being present. The sources of the prediction."]
        #[serde(rename = "predictionSources", default)]
        pub prediction_sources: ::std::option::Option<Vec<::serde_json::Value>>,
        #[doc = "The score of this prediction for the target."]
        #[serde(rename = "score", default)]
        pub score: ::std::option::Option<f64>,
    }
    impl ::field_selector::FieldSelector for NextDocPrediction {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(Debug, Clone, PartialEq, Default, :: serde :: Deserialize, :: serde :: Serialize)]
    pub struct NextDocPredictionList {
        #[doc = "Deprecated: Clients should not depend on this field being present. The experiment IDs associated with the prediction."]
        #[serde(rename = "experimentIds", default)]
        pub experiment_ids: ::std::option::Option<Vec<::serde_json::Value>>,
        #[doc = "The list of predicted items."]
        #[serde(rename = "items", default)]
        pub items: ::std::option::Option<Vec<crate::schemas::NextDocPrediction>>,
        #[doc = "This is always drive#nextDocPredictionList."]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
        #[doc = "A link back to this list."]
        #[serde(rename = "selfLink", default)]
        pub self_link: ::std::option::Option<String>,
        #[doc = "A tag for the purpose of logging and analysis."]
        #[serde(rename = "tag", default)]
        pub tag: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for NextDocPredictionList {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct NotificationAccessRequestData {
        #[doc = "ID of the item in Drive."]
        #[serde(rename = "fileId", default)]
        pub file_id: ::std::option::Option<String>,
        #[doc = "User that will receive access. This may be different from the requester, who could be requesting access on behalf of the grantee."]
        #[serde(rename = "granteeUser", default)]
        pub grantee_user: ::std::option::Option<crate::schemas::User2>,
        #[doc = "Access request message."]
        #[serde(rename = "message", default)]
        pub message: ::std::option::Option<String>,
        #[doc = "The requested new level of access. Possible values are:\n\n* reader \n* commenter \n* writer \n* owner \n* organizer"]
        #[serde(rename = "requestedRole", default)]
        pub requested_role: ::std::option::Option<String>,
        #[doc = "User who made the access request."]
        #[serde(rename = "requesterUser", default)]
        pub requester_user: ::std::option::Option<crate::schemas::User2>,
        #[doc = "Link to open the item's sharing dialog in Drive."]
        #[serde(rename = "shareUrl", default)]
        pub share_url: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for NotificationAccessRequestData {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct NotificationCommentDataCommentDetailsItems {
        #[doc = "The assignee of a todo. Only set if the commentType is \"todo\"."]
        #[serde(rename = "assigneeUser", default)]
        pub assignee_user: ::std::option::Option<crate::schemas::User2>,
        #[doc = "User that created the comment."]
        #[serde(rename = "authorUser", default)]
        pub author_user: ::std::option::Option<crate::schemas::User2>,
        #[doc = "The quoted text that the comment references. Only set if the comment quotes text."]
        #[serde(rename = "commentQuote", default)]
        pub comment_quote: ::std::option::Option<String>,
        #[doc = "The text of the comment."]
        #[serde(rename = "commentText", default)]
        pub comment_text: ::std::option::Option<String>,
        #[doc = "The type of the comment. Possible values are:\n\n* comment \n* suggestion \n* todo"]
        #[serde(rename = "commentType", default)]
        pub comment_type: ::std::option::Option<String>,
        #[doc = "Deprecated."]
        #[serde(rename = "isRecipientAssigenee", default)]
        pub is_recipient_assigenee: ::std::option::Option<bool>,
        #[doc = "Whether the recipient is also the todo assignee."]
        #[serde(rename = "isRecipientAssignee", default)]
        pub is_recipient_assignee: ::std::option::Option<bool>,
        #[doc = "Whether the recipient of the notification was @mentioned in the comment."]
        #[serde(rename = "isRecipientMentioned", default)]
        pub is_recipient_mentioned: ::std::option::Option<bool>,
    }
    impl ::field_selector::FieldSelector for NotificationCommentDataCommentDetailsItems {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct NotificationCommentData {
        #[doc = "The number of comments that are batched in this notification."]
        #[serde(rename = "commentCount", default)]
        #[serde(with = "crate::parsed_string")]
        pub comment_count: ::std::option::Option<i64>,
        #[doc = "Details about each comment in the thread."]
        #[serde(rename = "commentDetails", default)]
        pub comment_details:
            ::std::option::Option<Vec<crate::schemas::NotificationCommentDataCommentDetailsItems>>,
        #[doc = "Link to the comment in Drive."]
        #[serde(rename = "commentUrl", default)]
        pub comment_url: ::std::option::Option<String>,
        #[doc = "The list of users that made comments in this notification."]
        #[serde(rename = "commenters", default)]
        pub commenters: ::std::option::Option<Vec<crate::schemas::User2>>,
        #[doc = "ID of the item in Drive that is being commented on."]
        #[serde(rename = "fileId", default)]
        pub file_id: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for NotificationCommentData {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct NotificationShareDataDriveItemsItems {
        #[doc = "Link to open the shared item in Drive."]
        #[serde(rename = "alternateLink", default)]
        pub alternate_link: ::std::option::Option<String>,
        #[doc = "ID of the shared item in Drive."]
        #[serde(rename = "fileId", default)]
        pub file_id: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for NotificationShareDataDriveItemsItems {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct NotificationShareData {
        #[doc = "Deprecated."]
        #[serde(rename = "alternate_link", default)]
        pub alternate_link: ::std::option::Option<String>,
        #[doc = "Drive IDs of all shared items."]
        #[serde(rename = "driveItems", default)]
        pub drive_items:
            ::std::option::Option<Vec<crate::schemas::NotificationShareDataDriveItemsItems>>,
        #[doc = "Deprecated."]
        #[serde(rename = "fileId", default)]
        pub file_id: ::std::option::Option<String>,
        #[doc = "User created share message."]
        #[serde(rename = "message", default)]
        pub message: ::std::option::Option<String>,
        #[doc = "User who shared the Drive items."]
        #[serde(rename = "senderUser", default)]
        pub sender_user: ::std::option::Option<crate::schemas::User2>,
    }
    impl ::field_selector::FieldSelector for NotificationShareData {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct NotificationStorageData {
        #[doc = "Date when the storage quota is scheduled to expire (formatted RFC 3339 timestamp)."]
        #[serde(rename = "expirationDate", default)]
        pub expiration_date: ::std::option::Option<::chrono::DateTime<chrono::offset::Utc>>,
        #[doc = "The size of the quota adjust that is scheduled to expire."]
        #[serde(rename = "expiringQuotaBytes", default)]
        #[serde(with = "crate::parsed_string")]
        pub expiring_quota_bytes: ::std::option::Option<i64>,
        #[doc = "The total amount of quota the user currently has."]
        #[serde(rename = "quotaBytesTotal", default)]
        #[serde(with = "crate::parsed_string")]
        pub quota_bytes_total: ::std::option::Option<i64>,
        #[doc = "The total number of bytes the user currently uses."]
        #[serde(rename = "quotaBytesUsed", default)]
        #[serde(with = "crate::parsed_string")]
        pub quota_bytes_used: ::std::option::Option<i64>,
        #[doc = "The type for the storage usage notification. Possible values are:\n\n* normalUsage \n* highUsage \n* overQuota \n* overQuotaCritical"]
        #[serde(rename = "storageAlertType", default)]
        pub storage_alert_type: ::std::option::Option<String>,
        #[doc = "The total amount of quota that will remain after the expiration, assuming no other quota adjustments."]
        #[serde(rename = "totalQuotaBytesAfterExpiration", default)]
        #[serde(with = "crate::parsed_string")]
        pub total_quota_bytes_after_expiration: ::std::option::Option<i64>,
    }
    impl ::field_selector::FieldSelector for NotificationStorageData {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct Notification {
        #[doc = "Additional content for Access Request notifications."]
        #[serde(rename = "accessRequestData", default)]
        pub access_request_data:
            ::std::option::Option<crate::schemas::NotificationAccessRequestData>,
        #[serde(rename = "commentData", default)]
        pub comment_data: ::std::option::Option<crate::schemas::NotificationCommentData>,
        #[doc = "Create time for this notification (formatted RFC 3339 timestamp)."]
        #[serde(rename = "createdDate", default)]
        pub created_date: ::std::option::Option<::chrono::DateTime<chrono::offset::Utc>>,
        #[doc = "A localized notification description."]
        #[serde(rename = "description", default)]
        pub description: ::std::option::Option<String>,
        #[doc = "The ID of the notification."]
        #[serde(rename = "id", default)]
        pub id: ::std::option::Option<String>,
        #[doc = "This is always drive#notification."]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
        #[doc = "The type of this notification. Possible values are:\n\n* share \n* accessRequest \n* storageAlert \n* comment"]
        #[serde(rename = "notificationType", default)]
        pub notification_type: ::std::option::Option<String>,
        #[doc = "Additional content for Share notifications."]
        #[serde(rename = "shareData", default)]
        pub share_data: ::std::option::Option<crate::schemas::NotificationShareData>,
        #[serde(rename = "storageData", default)]
        pub storage_data: ::std::option::Option<crate::schemas::NotificationStorageData>,
        #[doc = "A localized notification title."]
        #[serde(rename = "title", default)]
        pub title: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for Notification {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ParentList {
        #[doc = "The ETag of the list."]
        #[serde(rename = "etag", default)]
        pub etag: ::std::option::Option<String>,
        #[doc = "The list of parents."]
        #[serde(rename = "items", default)]
        pub items: ::std::option::Option<Vec<crate::schemas::ParentReference>>,
        #[doc = "This is always drive#parentList."]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
        #[doc = "A link back to this list."]
        #[serde(rename = "selfLink", default)]
        pub self_link: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for ParentList {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ParentReference {
        #[doc = "The ID of the parent."]
        #[serde(rename = "id", default)]
        pub id: ::std::option::Option<String>,
        #[doc = "Whether or not the parent is the root folder."]
        #[serde(rename = "isRoot", default)]
        pub is_root: ::std::option::Option<bool>,
        #[doc = "This is always drive#parentReference."]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
        #[doc = "A link to the parent."]
        #[serde(rename = "parentLink", default)]
        pub parent_link: ::std::option::Option<String>,
        #[doc = "A link back to this reference."]
        #[serde(rename = "selfLink", default)]
        pub self_link: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for ParentReference {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct PermissionCapabilities {
        #[doc = "Whether the current user can add the role of commenter for this permission."]
        #[serde(rename = "canAddAsCommenter", default)]
        pub can_add_as_commenter: ::std::option::Option<bool>,
        #[doc = "Whether the current user can add the role of fileOrganizer for this permission."]
        #[serde(rename = "canAddAsFileOrganizer", default)]
        pub can_add_as_file_organizer: ::std::option::Option<bool>,
        #[doc = "Whether the current user can add the role of organizer for this permission."]
        #[serde(rename = "canAddAsOrganizer", default)]
        pub can_add_as_organizer: ::std::option::Option<bool>,
        #[doc = "Whether the current user can add the role of OWNER for this permission."]
        #[serde(rename = "canAddAsOwner", default)]
        pub can_add_as_owner: ::std::option::Option<bool>,
        #[doc = "Whether the current user can add the role of reader for this permission."]
        #[serde(rename = "canAddAsReader", default)]
        pub can_add_as_reader: ::std::option::Option<bool>,
        #[doc = "Whether the current user can add the role of writer for this permission."]
        #[serde(rename = "canAddAsWriter", default)]
        pub can_add_as_writer: ::std::option::Option<bool>,
        #[doc = "Whether the current user can change the Role for this permission to commenter."]
        #[serde(rename = "canChangeToCommenter", default)]
        pub can_change_to_commenter: ::std::option::Option<bool>,
        #[doc = "Whether the current user can change the Role for this permission to fileOrganizer."]
        #[serde(rename = "canChangeToFileOrganizer", default)]
        pub can_change_to_file_organizer: ::std::option::Option<bool>,
        #[doc = "Whether the current user can change the Role for this permission to organizer."]
        #[serde(rename = "canChangeToOrganizer", default)]
        pub can_change_to_organizer: ::std::option::Option<bool>,
        #[doc = "Whether the current user can change the Role for this permission to owner."]
        #[serde(rename = "canChangeToOwner", default)]
        pub can_change_to_owner: ::std::option::Option<bool>,
        #[doc = "Whether the current user can change the Role for this permission to reader."]
        #[serde(rename = "canChangeToReader", default)]
        pub can_change_to_reader: ::std::option::Option<bool>,
        #[doc = "Whether the current user can change this Permission to a role of reader on the published view."]
        #[serde(rename = "canChangeToReaderOnPublishedView", default)]
        pub can_change_to_reader_on_published_view: ::std::option::Option<bool>,
        #[doc = "Whether the current user can change the Role for this permission to writer."]
        #[serde(rename = "canChangeToWriter", default)]
        pub can_change_to_writer: ::std::option::Option<bool>,
        #[doc = "Whether the current user can remove this permission."]
        #[serde(rename = "canRemove", default)]
        pub can_remove: ::std::option::Option<bool>,
    }
    impl ::field_selector::FieldSelector for PermissionCapabilities {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct PermissionPermissionDetailsItems {
        #[doc = "Additional roles for this user. Only commenter is currently possible, though more may be supported in the future."]
        #[serde(rename = "additionalRoles", default)]
        pub additional_roles: ::std::option::Option<Vec<String>>,
        #[doc = "Whether this permission is inherited. This field is always populated. This is an output-only field."]
        #[serde(rename = "inherited", default)]
        pub inherited: ::std::option::Option<bool>,
        #[doc = "The ID of the item from which this permission is inherited. This is an output-only field and is only populated for members of the shared drive."]
        #[serde(rename = "inheritedFrom", default)]
        pub inherited_from: ::std::option::Option<String>,
        #[doc = "The permission type for this user. While new values may be added in future, the following are currently possible:\n\n* file \n* member"]
        #[serde(rename = "permissionType", default)]
        pub permission_type: ::std::option::Option<String>,
        #[doc = "The primary role for this user. While new values may be added in the future, the following are currently possible:\n\n* organizer \n* fileOrganizer \n* writer \n* reader"]
        #[serde(rename = "role", default)]
        pub role: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for PermissionPermissionDetailsItems {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct PermissionTeamDrivePermissionDetailsItems {
        #[doc = "Deprecated - use permissionDetails/additionalRoles instead."]
        #[serde(rename = "additionalRoles", default)]
        pub additional_roles: ::std::option::Option<Vec<String>>,
        #[doc = "Deprecated - use permissionDetails/inherited instead."]
        #[serde(rename = "inherited", default)]
        pub inherited: ::std::option::Option<bool>,
        #[doc = "Deprecated - use permissionDetails/inheritedFrom instead."]
        #[serde(rename = "inheritedFrom", default)]
        pub inherited_from: ::std::option::Option<String>,
        #[doc = "Deprecated - use permissionDetails/role instead."]
        #[serde(rename = "role", default)]
        pub role: ::std::option::Option<String>,
        #[doc = "Deprecated - use permissionDetails/permissionType instead."]
        #[serde(rename = "teamDrivePermissionType", default)]
        pub team_drive_permission_type: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for PermissionTeamDrivePermissionDetailsItems {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct Permission {
        #[doc = "Additional roles for this user. Only commenter is currently allowed, though more may be supported in the future."]
        #[serde(rename = "additionalRoles", default)]
        pub additional_roles: ::std::option::Option<Vec<String>>,
        #[doc = "The unique identifier for the audience. Only populated for audience type permissions."]
        #[serde(rename = "audienceId", default)]
        pub audience_id: ::std::option::Option<String>,
        #[doc = "Deprecated."]
        #[serde(rename = "authKey", default)]
        pub auth_key: ::std::option::Option<String>,
        #[doc = "Capabilities the current user has for this permission. Must be explicitly requested."]
        #[serde(rename = "capabilities", default)]
        pub capabilities: ::std::option::Option<crate::schemas::PermissionCapabilities>,
        #[doc = "The identifier for the customer with which this permission is associated. Only populated for audience type permissions."]
        #[serde(rename = "customerId", default)]
        pub customer_id: ::std::option::Option<String>,
        #[doc = "Whether the account associated with this permission has been deleted. This field only pertains to user and group permissions."]
        #[serde(rename = "deleted", default)]
        pub deleted: ::std::option::Option<bool>,
        #[doc = "The domain name of the entity this permission refers to. This is an output-only field which is present when the permission type is user, group or domain."]
        #[serde(rename = "domain", default)]
        pub domain: ::std::option::Option<String>,
        #[doc = "The email address of the user or group this permission refers to. This is an output-only field which is present when the permission type is user or group."]
        #[serde(rename = "emailAddress", default)]
        pub email_address: ::std::option::Option<String>,
        #[doc = "The ETag of the permission."]
        #[serde(rename = "etag", default)]
        pub etag: ::std::option::Option<String>,
        #[doc = "The time at which this permission will expire (RFC 3339 date-time). Expiration dates have the following restrictions:\n\n* They can only be set on user and group permissions \n* The date must be in the future \n* The date cannot be more than a year in the future"]
        #[serde(rename = "expirationDate", default)]
        pub expiration_date: ::std::option::Option<::chrono::DateTime<chrono::offset::Utc>>,
        #[doc = "The ID of the user this permission refers to, and identical to the permissionId in the About and Files resources. When making a drive.permissions.insert request, exactly one of the id or value fields must be specified unless the permission type is anyone, in which case both id and value are ignored."]
        #[serde(rename = "id", default)]
        pub id: ::std::option::Option<String>,
        #[doc = "A reason indicating why this permission is not applicable."]
        #[serde(rename = "inapplicableReason", default)]
        pub inapplicable_reason: ::std::option::Option<String>,
        #[doc = "This is always drive#permission."]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
        #[doc = "The name for this permission."]
        #[serde(rename = "name", default)]
        pub name: ::std::option::Option<String>,
        #[doc = "Details of whether the permissions on this shared drive item are inherited or directly on this item. This is an output-only field which is present only for shared drive items."]
        #[serde(rename = "permissionDetails", default)]
        pub permission_details:
            ::std::option::Option<Vec<crate::schemas::PermissionPermissionDetailsItems>>,
        #[doc = "A link to the profile photo, if available."]
        #[serde(rename = "photoLink", default)]
        pub photo_link: ::std::option::Option<String>,
        #[doc = "The account type. Allowed values are:\n\n* user \n* group \n* domain \n* audience \n* anyone"]
        #[serde(rename = "type", default)]
        pub r#type: ::std::option::Option<String>,
        #[doc = "The primary role for this user. While new values may be supported in the future, the following are currently allowed:\n\n* owner \n* organizer \n* fileOrganizer \n* writer \n* reader"]
        #[serde(rename = "role", default)]
        pub role: ::std::option::Option<String>,
        #[doc = "A list of roles that can be set as the effective role for this permission. Possible values are:\n\n* owner \n* organizer \n* fileOrganizer \n* writer \n* commenter \n* reader \n* published_reader \n* none"]
        #[serde(rename = "selectableRoles", default)]
        pub selectable_roles: ::std::option::Option<Vec<String>>,
        #[doc = "A link back to this permission."]
        #[serde(rename = "selfLink", default)]
        pub self_link: ::std::option::Option<String>,
        #[doc = "Deprecated - use permissionDetails instead."]
        #[serde(rename = "teamDrivePermissionDetails", default)]
        pub team_drive_permission_details:
            ::std::option::Option<Vec<crate::schemas::PermissionTeamDrivePermissionDetailsItems>>,
        #[doc = "The user's ID. This is an output-only field which is present when the permission type is user."]
        #[serde(rename = "userId", default)]
        pub user_id: ::std::option::Option<String>,
        #[doc = "The email address or domain name for the entity. This is used during inserts and is not populated in responses. When making a drive.permissions.insert request, exactly one of the id or value fields must be specified unless the permission type is anyone, in which case both id and value are ignored."]
        #[serde(rename = "value", default)]
        pub value: ::std::option::Option<String>,
        #[doc = "Indicates the view for this permission. Only populated for permissions that belong to a view. published is the only supported value."]
        #[serde(rename = "view", default)]
        pub view: ::std::option::Option<String>,
        #[doc = "Whether the link is required for this permission."]
        #[serde(rename = "withLink", default)]
        pub with_link: ::std::option::Option<bool>,
    }
    impl ::field_selector::FieldSelector for Permission {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct PermissionId {
        #[doc = "The permission ID."]
        #[serde(rename = "id", default)]
        pub id: ::std::option::Option<String>,
        #[doc = "This is always drive#permissionId."]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for PermissionId {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct PermissionList {
        #[doc = "The ETag of the list."]
        #[serde(rename = "etag", default)]
        pub etag: ::std::option::Option<String>,
        #[doc = "The list of permissions. If nextPageToken is populated, then this list may be incomplete and an additional page of results should be fetched."]
        #[serde(rename = "items", default)]
        pub items: ::std::option::Option<Vec<crate::schemas::Permission>>,
        #[doc = "This is always drive#permissionList."]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
        #[doc = "The page token for the next page of permissions. This field will be absent if the end of the permissions list has been reached. If the token is rejected for any reason, it should be discarded, and pagination should be restarted from the first page of results."]
        #[serde(rename = "nextPageToken", default)]
        pub next_page_token: ::std::option::Option<String>,
        #[doc = "A link back to this list."]
        #[serde(rename = "selfLink", default)]
        pub self_link: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for PermissionList {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct Property {
        #[doc = "The app that owns the property."]
        #[serde(rename = "appId", default)]
        pub app_id: ::std::option::Option<String>,
        #[doc = "ETag of the property."]
        #[serde(rename = "etag", default)]
        pub etag: ::std::option::Option<String>,
        #[doc = "The key of this property."]
        #[serde(rename = "key", default)]
        pub key: ::std::option::Option<String>,
        #[doc = "This is always drive#property."]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
        #[doc = "The link back to this property."]
        #[serde(rename = "selfLink", default)]
        pub self_link: ::std::option::Option<String>,
        #[doc = "The value of this property."]
        #[serde(rename = "value", default)]
        pub value: ::std::option::Option<String>,
        #[doc = "The visibility of this property."]
        #[serde(rename = "visibility", default)]
        pub visibility: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for Property {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct PropertyList {
        #[doc = "The ETag of the list."]
        #[serde(rename = "etag", default)]
        pub etag: ::std::option::Option<String>,
        #[doc = "The list of properties."]
        #[serde(rename = "items", default)]
        pub items: ::std::option::Option<Vec<crate::schemas::Property>>,
        #[doc = "This is always drive#propertyList."]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
        #[doc = "The link back to this list."]
        #[serde(rename = "selfLink", default)]
        pub self_link: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for PropertyList {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ReassignedReviewersTemplate {
        #[doc = "The reviewer added to the approval."]
        #[serde(rename = "addedReviewer", default)]
        pub added_reviewer: ::std::option::Option<crate::schemas::User>,
        #[doc = "The reviewer removed from the Approval."]
        #[serde(rename = "removedReviewer", default)]
        pub removed_reviewer: ::std::option::Option<crate::schemas::User>,
    }
    impl ::field_selector::FieldSelector for ReassignedReviewersTemplate {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct RemainingCount {
        #[doc = "This is always drive#remainingCount."]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
        #[doc = "The page token for the next page of results. This will be absent if all changes have been counted. If the token is rejected for any reason, it should be discarded, and pagination should be restarted from the first page of results."]
        #[serde(rename = "nextPageToken", default)]
        pub next_page_token: ::std::option::Option<String>,
        #[doc = "The estimated number of remaining changes for the user or shared drive. Limited to no more than the maxResults value defined in the request. If further changes remain, a nextPageToken will be available and the sum of the remainingCount values from all pages will reflect the total number of estimated changes available."]
        #[serde(rename = "remainingCount", default)]
        #[serde(with = "crate::parsed_string")]
        pub remaining_count: ::std::option::Option<i64>,
    }
    impl ::field_selector::FieldSelector for RemainingCount {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ReviewerDecisionCapabilities {
        #[doc = "Whether the current user can reassign this review to another user."]
        #[serde(rename = "canReassign", default)]
        pub can_reassign: ::std::option::Option<bool>,
    }
    impl ::field_selector::FieldSelector for ReviewerDecisionCapabilities {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ReviewerDecision {
        #[doc = "Set of actions that the user may take on the ReviewerDecision."]
        #[serde(rename = "capabilities", default)]
        pub capabilities: ::std::option::Option<crate::schemas::ReviewerDecisionCapabilities>,
        #[doc = "A reviewer's decision for the Approval."]
        #[serde(rename = "decision", default)]
        pub decision: ::std::option::Option<String>,
        #[doc = "This is always drive#reviewerDecision."]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
        #[doc = "The user responsible for this decision."]
        #[serde(rename = "reviewer", default)]
        pub reviewer: ::std::option::Option<crate::schemas::User>,
    }
    impl ::field_selector::FieldSelector for ReviewerDecision {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ReviewerReassignmentTemplate {
        #[doc = "The email address of the reviewer to whom the Approval is being reassigned."]
        #[serde(rename = "reviewerEmailAddressToAdd", default)]
        pub reviewer_email_address_to_add: ::std::option::Option<String>,
        #[doc = "The email address of the reviewer to remove from the Approval."]
        #[serde(rename = "reviewerEmailAddressToRemove", default)]
        pub reviewer_email_address_to_remove: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for ReviewerReassignmentTemplate {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct RevisionPreview {
        #[doc = "The time at which preview link expires (formatted RFC 3339 timestamp)."]
        #[serde(rename = "expiryDate", default)]
        pub expiry_date: ::std::option::Option<::chrono::DateTime<chrono::offset::Utc>>,
        #[doc = "A short-lived Senna upload URL."]
        #[serde(rename = "link", default)]
        pub link: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for RevisionPreview {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct Revision {
        #[doc = "Short term download URL for the file. This will only be populated on files with content stored in Drive."]
        #[serde(rename = "downloadUrl", default)]
        pub download_url: ::std::option::Option<String>,
        #[doc = "The ETag of the revision."]
        #[serde(rename = "etag", default)]
        pub etag: ::std::option::Option<String>,
        #[doc = "Links for exporting Google Docs to specific formats."]
        #[serde(rename = "exportLinks", default)]
        pub export_links: ::std::option::Option<::std::collections::BTreeMap<String, String>>,
        #[doc = "The size of the revision in bytes. This will only be populated on files with content stored in Drive."]
        #[serde(rename = "fileSize", default)]
        #[serde(with = "crate::parsed_string")]
        pub file_size: ::std::option::Option<i64>,
        #[doc = "The ID of the revision."]
        #[serde(rename = "id", default)]
        pub id: ::std::option::Option<String>,
        #[doc = "This is always drive#revision."]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
        #[doc = "The last user to modify this revision."]
        #[serde(rename = "lastModifyingUser", default)]
        pub last_modifying_user: ::std::option::Option<crate::schemas::User>,
        #[doc = "Name of the last user to modify this revision."]
        #[serde(rename = "lastModifyingUserName", default)]
        pub last_modifying_user_name: ::std::option::Option<String>,
        #[doc = "An MD5 checksum for the content of this revision. This will only be populated on files with content stored in Drive."]
        #[serde(rename = "md5Checksum", default)]
        pub md_5_checksum: ::std::option::Option<String>,
        #[doc = "The MIME type of the revision."]
        #[serde(rename = "mimeType", default)]
        pub mime_type: ::std::option::Option<String>,
        #[doc = "Last time this revision was modified (client-settable, formatted RFC 3339 timestamp)."]
        #[serde(rename = "modifiedDate", default)]
        pub modified_date: ::std::option::Option<::chrono::DateTime<chrono::offset::Utc>>,
        #[doc = "The original filename when this revision was created. This will only be populated on files with content stored in Drive."]
        #[serde(rename = "originalFilename", default)]
        pub original_filename: ::std::option::Option<String>,
        #[doc = "Whether this revision is pinned to prevent automatic purging. This will only be populated and can only be modified on files with content stored in Drive which are not Google Docs. Revisions can also be pinned when they are created through the drive.files.insert/update/copy by using the pinned query parameter."]
        #[serde(rename = "pinned", default)]
        pub pinned: ::std::option::Option<bool>,
        #[doc = "Resource to use for go/senna previews."]
        #[serde(rename = "preview", default)]
        pub preview: ::std::option::Option<crate::schemas::RevisionPreview>,
        #[doc = "Whether subsequent revisions will be automatically republished. This is only populated and can only be modified for Google Docs."]
        #[serde(rename = "publishAuto", default)]
        pub publish_auto: ::std::option::Option<bool>,
        #[doc = "Whether this revision is published. This is only populated and can only be modified for Google Docs."]
        #[serde(rename = "published", default)]
        pub published: ::std::option::Option<bool>,
        #[doc = "A link to the published revision."]
        #[serde(rename = "publishedLink", default)]
        pub published_link: ::std::option::Option<String>,
        #[doc = "Whether this revision is published outside the domain. This is only populated and can only be modified for Google Docs."]
        #[serde(rename = "publishedOutsideDomain", default)]
        pub published_outside_domain: ::std::option::Option<bool>,
        #[doc = "A link back to this revision."]
        #[serde(rename = "selfLink", default)]
        pub self_link: ::std::option::Option<String>,
        #[doc = "Last time this revision was modified (server-maintained, formatted RFC 3339 timestamp)."]
        #[serde(rename = "serverModifiedDate", default)]
        pub server_modified_date: ::std::option::Option<::chrono::DateTime<chrono::offset::Utc>>,
    }
    impl ::field_selector::FieldSelector for Revision {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct RevisionList {
        #[doc = "The ETag of the list."]
        #[serde(rename = "etag", default)]
        pub etag: ::std::option::Option<String>,
        #[doc = "The list of revisions. If nextPageToken is populated, then this list may be incomplete and an additional page of results should be fetched."]
        #[serde(rename = "items", default)]
        pub items: ::std::option::Option<Vec<crate::schemas::Revision>>,
        #[doc = "This is always drive#revisionList."]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
        #[doc = "The page token for the next page of revisions. This field will be absent if the end of the revisions list has been reached. If the token is rejected for any reason, it should be discarded and pagination should be restarted from the first page of results."]
        #[serde(rename = "nextPageToken", default)]
        pub next_page_token: ::std::option::Option<String>,
        #[doc = "A link back to this list."]
        #[serde(rename = "selfLink", default)]
        pub self_link: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for RevisionList {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct SendAccessRequest {
        #[doc = "List of email addresses for whom access to the file is requested. If unspecified, access is requested for the current user."]
        #[serde(rename = "emailAddresses", default)]
        pub email_addresses: ::std::option::Option<Vec<String>>,
        #[doc = "This is always drive#requestAccessRequest."]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
        #[doc = "An optional message to be included in the request."]
        #[serde(rename = "message", default)]
        pub message: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for SendAccessRequest {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct Setting {
        #[doc = "ETag of the setting."]
        #[serde(rename = "etag", default)]
        pub etag: ::std::option::Option<String>,
        #[doc = "The key of this setting."]
        #[serde(rename = "key", default)]
        pub key: ::std::option::Option<String>,
        #[doc = "This is always drive#setting."]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
        #[doc = "The namespace of this setting."]
        #[serde(rename = "namespace", default)]
        pub namespace: ::std::option::Option<String>,
        #[doc = "The link back to this setting."]
        #[serde(rename = "selfLink", default)]
        pub self_link: ::std::option::Option<String>,
        #[doc = "The value of this setting."]
        #[serde(rename = "value", default)]
        pub value: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for Setting {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct SettingList {
        #[doc = "The ETag of the list."]
        #[serde(rename = "etag", default)]
        pub etag: ::std::option::Option<String>,
        #[doc = "The list of settings."]
        #[serde(rename = "items", default)]
        pub items: ::std::option::Option<Vec<crate::schemas::Setting>>,
        #[doc = "This is always drive#settingList."]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
        #[doc = "The link back to this list."]
        #[serde(rename = "selfLink", default)]
        pub self_link: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for SettingList {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct ShareNotificationRequest {
        #[doc = "List of email addresses to which notifications should be sent."]
        #[serde(rename = "emailAddresses", default)]
        pub email_addresses: ::std::option::Option<Vec<String>>,
        #[doc = "When set, attaches the content to the notification with the specified mime type."]
        #[serde(rename = "includeContentAsAttachmentMimeType", default)]
        pub include_content_as_attachment_mime_type: ::std::option::Option<String>,
        #[doc = "Whether the content of the file should be inlined in the notification."]
        #[serde(rename = "includeContentInline", default)]
        pub include_content_inline: ::std::option::Option<bool>,
        #[doc = "This is always drive#shareNotificationRequest."]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
        #[doc = "An optional message to be included in the notification."]
        #[serde(rename = "message", default)]
        pub message: ::std::option::Option<String>,
        #[doc = "The message template to use when sending a notification. Supported templates include:\n\n* invite \n* collaborators \n* activityNudge \n* publish"]
        #[serde(rename = "messageTemplate", default)]
        pub message_template: ::std::option::Option<String>,
        #[doc = "Whether to also send the notification to the requester."]
        #[serde(rename = "notifyRequester", default)]
        pub notify_requester: ::std::option::Option<bool>,
        #[doc = "An optional subject."]
        #[serde(rename = "subject", default)]
        pub subject: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for ShareNotificationRequest {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct SpellResponseTemplateSpellCorrectionsItemsSpellFragmentsItems {
        #[serde(rename = "correction", default)]
        pub correction: ::std::option::Option<String>,
        #[serde(rename = "original", default)]
        pub original: ::std::option::Option<String>,
        #[serde(rename = "status", default)]
        pub status: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector
        for SpellResponseTemplateSpellCorrectionsItemsSpellFragmentsItems
    {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct SpellResponseTemplateSpellCorrectionsItems {
        #[doc = "A list of spell fragments for a correction. The full query is represented by the fragments. Each fragment will have a status of CORRECT, INCORRECT, or SUSPICIOUS."]
        #[serde(rename = "spellFragments", default)]
        pub spell_fragments: ::std::option::Option<
            Vec<crate::schemas::SpellResponseTemplateSpellCorrectionsItemsSpellFragmentsItems>,
        >,
    }
    impl ::field_selector::FieldSelector for SpellResponseTemplateSpellCorrectionsItems {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct SpellResponseTemplate {
        #[doc = "A list of suggested corrections. It may be possible for the original to match the correction in which case the status of all fragments will be set to CORRECT."]
        #[serde(rename = "spellCorrections", default)]
        pub spell_corrections:
            ::std::option::Option<Vec<crate::schemas::SpellResponseTemplateSpellCorrectionsItems>>,
    }
    impl ::field_selector::FieldSelector for SpellResponseTemplate {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct StartPageToken {
        #[doc = "Identifies what kind of resource this is. Value: the fixed string \"drive#startPageToken\"."]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
        #[doc = "The starting page token for listing changes."]
        #[serde(rename = "startPageToken", default)]
        pub start_page_token: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for StartPageToken {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct SyncPhotoWithSha1Request {
        #[doc = "This is always drive#syncPhotoWithSha1Request."]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
        #[doc = "Sha1 checksum of the Photo to sync."]
        #[serde(rename = "sha1Checksum", default)]
        pub sha_1_checksum: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for SyncPhotoWithSha1Request {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct TeamDriveBackgroundImageFile {
        #[doc = "The ID of an image file in Drive to use for the background image."]
        #[serde(rename = "id", default)]
        pub id: ::std::option::Option<String>,
        #[doc = "The width of the cropped image in the closed range of 0 to 1. This value represents the width of the cropped image divided by the width of the entire image. The height is computed by applying a width to height aspect ratio of 80 to 9. The resulting image must be at least 1280 pixels wide and 144 pixels high."]
        #[serde(rename = "width", default)]
        pub width: ::std::option::Option<f32>,
        #[doc = "The X coordinate of the upper left corner of the cropping area in the background image. This is a value in the closed range of 0 to 1. This value represents the horizontal distance from the left side of the entire image to the left side of the cropping area divided by the width of the entire image."]
        #[serde(rename = "xCoordinate", default)]
        pub x_coordinate: ::std::option::Option<f32>,
        #[doc = "The Y coordinate of the upper left corner of the cropping area in the background image. This is a value in the closed range of 0 to 1. This value represents the vertical distance from the top side of the entire image to the top side of the cropping area divided by the height of the entire image."]
        #[serde(rename = "yCoordinate", default)]
        pub y_coordinate: ::std::option::Option<f32>,
    }
    impl ::field_selector::FieldSelector for TeamDriveBackgroundImageFile {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct TeamDriveCapabilities {
        #[doc = "Whether the current user can add children to folders in this Team Drive."]
        #[serde(rename = "canAddChildren", default)]
        pub can_add_children: ::std::option::Option<bool>,
        #[doc = "Whether the current user can change references to categories on this Team Drive."]
        #[serde(rename = "canChangeCategoryReferences", default)]
        pub can_change_category_references: ::std::option::Option<bool>,
        #[doc = "Whether the current user can change the copyRequiresWriterPermission restriction of this Team Drive."]
        #[serde(rename = "canChangeCopyRequiresWriterPermissionRestriction", default)]
        pub can_change_copy_requires_writer_permission_restriction: ::std::option::Option<bool>,
        #[doc = "Whether the current user can change the disallowDriveFileStream restriction of this Team Drive."]
        #[serde(rename = "canChangeDisallowDriveFileStreamRestriction", default)]
        pub can_change_disallow_drive_file_stream_restriction: ::std::option::Option<bool>,
        #[doc = "Whether the current user can change the domainUsersOnly restriction of this Team Drive."]
        #[serde(rename = "canChangeDomainUsersOnlyRestriction", default)]
        pub can_change_domain_users_only_restriction: ::std::option::Option<bool>,
        #[doc = "Whether the current user can change the background of this Team Drive."]
        #[serde(rename = "canChangeTeamDriveBackground", default)]
        pub can_change_team_drive_background: ::std::option::Option<bool>,
        #[doc = "Whether the current user can change the teamMembersOnly restriction of this Team Drive."]
        #[serde(rename = "canChangeTeamMembersOnlyRestriction", default)]
        pub can_change_team_members_only_restriction: ::std::option::Option<bool>,
        #[doc = "Whether the current user can comment on files in this Team Drive."]
        #[serde(rename = "canComment", default)]
        pub can_comment: ::std::option::Option<bool>,
        #[doc = "Whether the current user can copy files in this Team Drive."]
        #[serde(rename = "canCopy", default)]
        pub can_copy: ::std::option::Option<bool>,
        #[doc = "Whether the current user can delete children from folders in this Team Drive."]
        #[serde(rename = "canDeleteChildren", default)]
        pub can_delete_children: ::std::option::Option<bool>,
        #[doc = "Whether the current user can delete this Team Drive. Attempting to delete the Team Drive may still fail if there are untrashed items inside the Team Drive."]
        #[serde(rename = "canDeleteTeamDrive", default)]
        pub can_delete_team_drive: ::std::option::Option<bool>,
        #[doc = "Whether the current user can download files in this Team Drive."]
        #[serde(rename = "canDownload", default)]
        pub can_download: ::std::option::Option<bool>,
        #[doc = "Whether the current user can edit files in this Team Drive"]
        #[serde(rename = "canEdit", default)]
        pub can_edit: ::std::option::Option<bool>,
        #[doc = "Whether the current user can list the children of folders in this Team Drive."]
        #[serde(rename = "canListChildren", default)]
        pub can_list_children: ::std::option::Option<bool>,
        #[doc = "Deprecated: use the canShare capability."]
        #[serde(rename = "canManageMemberUpgrades", default)]
        pub can_manage_member_upgrades: ::std::option::Option<bool>,
        #[doc = "Whether the current user can add members to this Team Drive or remove them or change their role."]
        #[serde(rename = "canManageMembers", default)]
        pub can_manage_members: ::std::option::Option<bool>,
        #[doc = "Deprecated: use the canShare capability."]
        #[serde(rename = "canManageVisitors", default)]
        pub can_manage_visitors: ::std::option::Option<bool>,
        #[doc = "Whether files in this Team Drive can be printed by the current user."]
        #[serde(rename = "canPrint", default)]
        pub can_print: ::std::option::Option<bool>,
        #[doc = "Whether the current user can read the revisions resource of files in this Team Drive."]
        #[serde(rename = "canReadRevisions", default)]
        pub can_read_revisions: ::std::option::Option<bool>,
        #[doc = "Deprecated - use canDeleteChildren or canTrashChildren instead."]
        #[serde(rename = "canRemoveChildren", default)]
        pub can_remove_children: ::std::option::Option<bool>,
        #[doc = "Whether the current user can rename files or folders in this Team Drive."]
        #[serde(rename = "canRename", default)]
        pub can_rename: ::std::option::Option<bool>,
        #[doc = "Whether the current user can rename this Team Drive."]
        #[serde(rename = "canRenameTeamDrive", default)]
        pub can_rename_team_drive: ::std::option::Option<bool>,
        #[doc = "Whether the current user can share files or folders in this Team Drive."]
        #[serde(rename = "canShare", default)]
        pub can_share: ::std::option::Option<bool>,
        #[doc = "Deprecated - use restrictions.domainUsersOnly and restrictionsOverride.domainUsersOnly instead."]
        #[serde(rename = "canShareOutsideDomain", default)]
        pub can_share_outside_domain: ::std::option::Option<bool>,
        #[doc = "Whether the current user can share files or folders in this Team Drive to all users, including those who are not signed in."]
        #[serde(rename = "canShareToAllUsers", default)]
        pub can_share_to_all_users: ::std::option::Option<bool>,
        #[doc = "Whether the current user can trash children from folders in this Team Drive."]
        #[serde(rename = "canTrashChildren", default)]
        pub can_trash_children: ::std::option::Option<bool>,
    }
    impl ::field_selector::FieldSelector for TeamDriveCapabilities {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct TeamDrivePermissionsSummary {
        #[doc = "Total number of permission entries. This includes entries not in \"selectPermissions\"."]
        #[serde(rename = "entryCount", default)]
        pub entry_count: ::std::option::Option<i32>,
        #[doc = "Total number of group type permission entries. This includes entries not in \"selectPermissions\"."]
        #[serde(rename = "groupEntryCount", default)]
        pub group_entry_count: ::std::option::Option<i32>,
        #[doc = "Total number of members of this Team Drive, which contains the expanded group membership counts for any groups. If the Team Drive has several members a lower bound is returned instead."]
        #[serde(rename = "memberCount", default)]
        pub member_count: ::std::option::Option<i32>,
        #[doc = "A selection of at most 10 entries from the Team Drive's permissions."]
        #[serde(rename = "selectPermissions", default)]
        pub select_permissions: ::std::option::Option<Vec<crate::schemas::Permission>>,
        #[doc = "Total number of user type permission entries. This includes entries not in \"selectPermissions\"."]
        #[serde(rename = "userEntryCount", default)]
        pub user_entry_count: ::std::option::Option<i32>,
    }
    impl ::field_selector::FieldSelector for TeamDrivePermissionsSummary {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct TeamDriveRestrictions {
        #[doc = "Whether administrative privileges on this Team Drive are required to modify restrictions."]
        #[serde(rename = "adminManagedRestrictions", default)]
        pub admin_managed_restrictions: ::std::option::Option<bool>,
        #[doc = "Whether the options to copy, print, or download files inside this Team Drive, should be disabled for readers and commenters. When this restriction is set to true, it will override the similarly named field to true for any file inside this Team Drive."]
        #[serde(rename = "copyRequiresWriterPermission", default)]
        pub copy_requires_writer_permission: ::std::option::Option<bool>,
        #[doc = "Whether Drive File Stream is prevented from accessing items inside this Team Drive."]
        #[serde(rename = "disallowDriveFileStream", default)]
        pub disallow_drive_file_stream: ::std::option::Option<bool>,
        #[doc = "Whether access to this Team Drive and items inside this Team Drive is restricted to users of the domain to which this Team Drive belongs. This restriction may be overridden by other sharing policies controlled outside of this Team Drive."]
        #[serde(rename = "domainUsersOnly", default)]
        pub domain_users_only: ::std::option::Option<bool>,
        #[doc = "Whether access to items inside this Team Drive is restricted to members of this Team Drive."]
        #[serde(rename = "teamMembersOnly", default)]
        pub team_members_only: ::std::option::Option<bool>,
    }
    impl ::field_selector::FieldSelector for TeamDriveRestrictions {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct TeamDriveRestrictionsOverride {
        #[doc = "The override status for the domainUsersOnly restriction. Possible values are notOverridden and overriddenToTrue."]
        #[serde(rename = "domainUsersOnly", default)]
        pub domain_users_only: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for TeamDriveRestrictionsOverride {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct TeamDrive {
        #[doc = "An image file and cropping parameters from which a background image for this Team Drive is set. This is a write only field; it can only be set on drive.teamdrives.update requests that don't set themeId. When specified, all fields of the backgroundImageFile must be set."]
        #[serde(rename = "backgroundImageFile", default)]
        pub background_image_file:
            ::std::option::Option<crate::schemas::TeamDriveBackgroundImageFile>,
        #[doc = "A link to this Team Drive's background image for use in Tesla's grid view."]
        #[serde(rename = "backgroundImageGridViewLink", default)]
        pub background_image_grid_view_link: ::std::option::Option<String>,
        #[doc = "Deprecated"]
        #[serde(rename = "backgroundImageId", default)]
        pub background_image_id: ::std::option::Option<String>,
        #[doc = "A short-lived link to this Team Drive's background image."]
        #[serde(rename = "backgroundImageLink", default)]
        pub background_image_link: ::std::option::Option<String>,
        #[doc = "A link to this Team Drive's background image for use in Tesla's list view."]
        #[serde(rename = "backgroundImageListViewLink", default)]
        pub background_image_list_view_link: ::std::option::Option<String>,
        #[doc = "Capabilities the current user has on this Team Drive."]
        #[serde(rename = "capabilities", default)]
        pub capabilities: ::std::option::Option<crate::schemas::TeamDriveCapabilities>,
        #[serde(rename = "categoryReferences", default)]
        pub category_references:
            ::std::option::Option<Vec<crate::schemas::TeamDriveCategoryReference>>,
        #[doc = "The color of this Team Drive as an RGB hex string. It can only be set on a drive.teamdrives.update request that does not set themeId."]
        #[serde(rename = "colorRgb", default)]
        pub color_rgb: ::std::option::Option<String>,
        #[doc = "The time at which the Team Drive was created (RFC 3339 date-time)."]
        #[serde(rename = "createdDate", default)]
        pub created_date: ::std::option::Option<::chrono::DateTime<chrono::offset::Utc>>,
        #[doc = "User that created the Team Drive, if available. Only returned when useDomainAdminAccess=true."]
        #[serde(rename = "creator", default)]
        pub creator: ::std::option::Option<crate::schemas::User>,
        #[doc = "Deprecated - use restrictionsOverride.domainUsersOnly instead."]
        #[serde(rename = "domainAllowsSharingOutside", default)]
        pub domain_allows_sharing_outside: ::std::option::Option<bool>,
        #[doc = "Whether the Team Drive is hidden from default view."]
        #[serde(rename = "hidden", default)]
        pub hidden: ::std::option::Option<bool>,
        #[doc = "The ID of this Team Drive which is also the ID of the top level folder of this Team Drive."]
        #[serde(rename = "id", default)]
        pub id: ::std::option::Option<String>,
        #[doc = "This is always drive#teamDrive"]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
        #[doc = "The name of this Team Drive."]
        #[serde(rename = "name", default)]
        pub name: ::std::option::Option<String>,
        #[doc = "The display name of the organization to which this Team Drive belongs."]
        #[serde(rename = "organizationDisplayName", default)]
        pub organization_display_name: ::std::option::Option<String>,
        #[doc = "A summary of the permissions of this Team Drive as an output-only field."]
        #[serde(rename = "permissionsSummary", default)]
        pub permissions_summary: ::std::option::Option<crate::schemas::TeamDrivePermissionsSummary>,
        #[doc = "The DNS domain name of the primary domain of the organization to which this Team Drive belongs."]
        #[serde(rename = "primaryDomainName", default)]
        pub primary_domain_name: ::std::option::Option<String>,
        #[doc = "The number of files contained within this Team Drive, excluding the Team Drive's top level folder. NOTE: this value is stale, and is only intended to be used by Cello for backfilling purposes. Do not add to public API versions. More info: go/team-drive-stats-api"]
        #[serde(rename = "recursiveFileCount", default)]
        #[serde(with = "crate::parsed_string")]
        pub recursive_file_count: ::std::option::Option<i64>,
        #[doc = "The number of folders contained within this Team Drive, excluding the Team Drive's top level folder. NOTE: this value is stale, and is only intended to be used by Cello for backfilling purposes. Do not add to public API versions. More info: go/team-drive-stats-api"]
        #[serde(rename = "recursiveFolderCount", default)]
        #[serde(with = "crate::parsed_string")]
        pub recursive_folder_count: ::std::option::Option<i64>,
        #[doc = "A set of restrictions that apply to this Team Drive or items inside this Team Drive."]
        #[serde(rename = "restrictions", default)]
        pub restrictions: ::std::option::Option<crate::schemas::TeamDriveRestrictions>,
        #[doc = "A set of overrides for any restriction that can be overridden outside of the Team Drive's restriction settings. The name of the override is identical to the name of the restriction which can be overridden."]
        #[serde(rename = "restrictionsOverride", default)]
        pub restrictions_override:
            ::std::option::Option<crate::schemas::TeamDriveRestrictionsOverride>,
        #[doc = "The ID of the theme from which the background image and color will be set. The set of possible teamDriveThemes can be retrieved from a drive.about.get response. When not specified on a drive.teamdrives.insert request, a random theme is chosen from which the background image and color are set. This is a write-only field; it can only be set on requests that don't set colorRgb or backgroundImageFile."]
        #[serde(rename = "themeId", default)]
        pub theme_id: ::std::option::Option<String>,
        #[doc = "Whether this Team Drive belongs to a domain that is trusted by the requesting user's domain."]
        #[serde(rename = "trusted", default)]
        pub trusted: ::std::option::Option<bool>,
    }
    impl ::field_selector::FieldSelector for TeamDrive {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct TeamDriveCategoryChangeRequest {
        #[doc = "The references to categories to add or update on the Team Drive."]
        #[serde(rename = "addCategoryReferences", default)]
        pub add_category_references:
            ::std::option::Option<Vec<crate::schemas::TeamDriveCategoryReference>>,
        #[doc = "This is always drive#teamDriveCategoryChangeRequest."]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
        #[doc = "The category resource names to remove from the Team Drive."]
        #[serde(rename = "removeCategoryReferences", default)]
        pub remove_category_references: ::std::option::Option<Vec<String>>,
    }
    impl ::field_selector::FieldSelector for TeamDriveCategoryChangeRequest {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct TeamDriveCategoryReference {
        #[doc = "The Category resource name."]
        #[serde(rename = "category", default)]
        pub category: ::std::option::Option<String>,
        #[doc = "This is always drive#teamDriveCategoryReference."]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for TeamDriveCategoryReference {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug, Clone, PartialEq, PartialOrd, Default, :: serde :: Deserialize, :: serde :: Serialize,
    )]
    pub struct TeamDriveList {
        #[doc = "The list of Team Drives. If nextPageToken is populated, then this list may be incomplete and an additional page of results should be fetched."]
        #[serde(rename = "items", default)]
        pub items: ::std::option::Option<Vec<crate::schemas::TeamDrive>>,
        #[doc = "This is always drive#teamDriveList"]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
        #[doc = "The page token for the next page of Team Drives. This will be absent if the end of the Team Drives list has been reached. If the token is rejected for any reason, it should be discarded, and pagination should be restarted from the first page of results."]
        #[serde(rename = "nextPageToken", default)]
        pub next_page_token: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for TeamDriveList {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct UpdateCategoryMetadata {
        #[serde(rename = "categoryMetadata", default)]
        pub category_metadata: ::std::option::Option<Vec<crate::schemas::CategoryMetadataDelta>>,
        #[doc = "This is always drive#updateCategoryMetadata"]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for UpdateCategoryMetadata {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct UserDomainSharingSettings {
        #[doc = "Maximum allowed role when sharing with all users."]
        #[serde(rename = "maxAllUsersRole", default)]
        pub max_all_users_role: ::std::option::Option<String>,
        #[doc = "Maximum allowed role when sharing with all users inside the domain."]
        #[serde(rename = "maxDomainRole", default)]
        pub max_domain_role: ::std::option::Option<String>,
        #[doc = "Deprecated."]
        #[serde(rename = "shareInPolicy", default)]
        pub share_in_policy: ::std::option::Option<String>,
        #[doc = "Policy for sharing with a user outside the domain."]
        #[serde(rename = "shareOutPolicy", default)]
        pub share_out_policy: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for UserDomainSharingSettings {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct UserPicture {
        #[doc = "A URL that points to a profile picture of this user."]
        #[serde(rename = "url", default)]
        pub url: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for UserPicture {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct User {
        #[doc = "A plain text displayable name for this user."]
        #[serde(rename = "displayName", default)]
        pub display_name: ::std::option::Option<String>,
        #[doc = "The domain name of this user or group"]
        #[serde(rename = "domain", default)]
        pub domain: ::std::option::Option<String>,
        #[doc = "The sharing settings for the domain of this user or group"]
        #[serde(rename = "domainSharingSettings", default)]
        pub domain_sharing_settings:
            ::std::option::Option<crate::schemas::UserDomainSharingSettings>,
        #[doc = "The email address of the user."]
        #[serde(rename = "emailAddress", default)]
        pub email_address: ::std::option::Option<String>,
        #[doc = "The user's ID."]
        #[serde(rename = "id", default)]
        pub id: ::std::option::Option<String>,
        #[doc = "Whether this user is the same as the authenticated user for whom the request was made."]
        #[serde(rename = "isAuthenticatedUser", default)]
        pub is_authenticated_user: ::std::option::Option<bool>,
        #[doc = "This is always drive#user."]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
        #[doc = "The ID of the user's permission resources the permissions collection."]
        #[serde(rename = "permissionId", default)]
        pub permission_id: ::std::option::Option<String>,
        #[doc = "The user's profile picture."]
        #[serde(rename = "picture", default)]
        pub picture: ::std::option::Option<crate::schemas::UserPicture>,
    }
    impl ::field_selector::FieldSelector for User {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct User2 {
        #[doc = "A plain text displayable name for this user."]
        #[serde(rename = "displayName", default)]
        pub display_name: ::std::option::Option<String>,
        #[doc = "The email address of the user."]
        #[serde(rename = "emailAddress", default)]
        pub email_address: ::std::option::Option<String>,
        #[doc = "The user's ID"]
        #[serde(rename = "id", default)]
        pub id: ::std::option::Option<String>,
        #[doc = "This is always driveNotification#user."]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for User2 {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct UserScopedAttributeValue {
        #[doc = "Only present if valueType is boolean."]
        #[serde(rename = "boolean", default)]
        pub boolean: ::std::option::Option<bool>,
        #[doc = "DEPRECATED: Use dateString."]
        #[serde(rename = "date", default)]
        pub date: ::std::option::Option<crate::schemas::Date>,
        #[doc = "DEPRECATED: Not implemented."]
        #[serde(rename = "dateList", default)]
        pub date_list: ::std::option::Option<Vec<crate::schemas::Date>>,
        #[doc = "Only present if valueType is date. RFC 3339 formatted date: YYYY-MM-DD."]
        #[serde(rename = "dateString", default)]
        pub date_string: ::std::option::Option<::chrono::NaiveDate>,
        #[doc = "DEPRECATED: Not implemented."]
        #[serde(rename = "dateTime", default)]
        #[serde(with = "crate::parsed_string")]
        pub date_time: ::std::option::Option<i64>,
        #[doc = "DEPRECATED: Not implemented."]
        #[serde(rename = "dateTimeList", default)]
        pub date_time_list: ::std::option::Option<Vec<i64>>,
        #[doc = "Only present if valueType is driveFile."]
        #[serde(rename = "driveFile", default)]
        pub drive_file: ::std::option::Option<String>,
        #[doc = "Only present if valueType is driveFileList."]
        #[serde(rename = "driveFileList", default)]
        pub drive_file_list: ::std::option::Option<Vec<String>>,
        #[doc = "Only present if valueType is integer."]
        #[serde(rename = "integer", default)]
        #[serde(with = "crate::parsed_string")]
        pub integer: ::std::option::Option<i64>,
        #[doc = "Only present if valueType is integerList."]
        #[serde(rename = "integerList", default)]
        pub integer_list: ::std::option::Option<Vec<i64>>,
        #[doc = "This is always drive#userScopedAttributeValue"]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
        #[doc = "Only present if valueType is money."]
        #[serde(rename = "money", default)]
        pub money: ::std::option::Option<crate::schemas::Money>,
        #[doc = "Only present if valueType is moneyList."]
        #[serde(rename = "moneyList", default)]
        pub money_list: ::std::option::Option<Vec<crate::schemas::Money>>,
        #[doc = "The user to whom this value applies."]
        #[serde(rename = "scopedUser", default)]
        pub scoped_user: ::std::option::Option<crate::schemas::User>,
        #[doc = "Only present if valueType is selection."]
        #[serde(rename = "selection", default)]
        pub selection: ::std::option::Option<String>,
        #[doc = "Only present if valueType is selectionList."]
        #[serde(rename = "selectionList", default)]
        pub selection_list: ::std::option::Option<Vec<String>>,
        #[doc = "Only present if valueType is text."]
        #[serde(rename = "text", default)]
        pub text: ::std::option::Option<String>,
        #[doc = "Only present if valueType is textList."]
        #[serde(rename = "textList", default)]
        pub text_list: ::std::option::Option<Vec<String>>,
        #[doc = "Only present if valueType is user."]
        #[serde(rename = "user", default)]
        pub user: ::std::option::Option<crate::schemas::User>,
        #[doc = "Only present if valueType is userList."]
        #[serde(rename = "userList", default)]
        pub user_list: ::std::option::Option<Vec<crate::schemas::User>>,
        #[doc = "The attribute type. While new values may be supported in the future, the following are currently allowed:\n\n* boolean \n* dateString \n* driveFile \n* driveFileList \n* integer \n* integerList \n* money \n* moneyList \n* selection \n* selectionList \n* text \n* textList \n* user \n* userList"]
        #[serde(rename = "valueType", default)]
        pub value_type: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for UserScopedAttributeValue {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct Workspace {
        #[doc = "The time at which this Workspace was created (formatted RFC 3339 timestamp)."]
        #[serde(rename = "createdDate", default)]
        pub created_date: ::std::option::Option<::chrono::DateTime<chrono::offset::Utc>>,
        #[doc = "The ID of a Workspace."]
        #[serde(rename = "id", default)]
        pub id: ::std::option::Option<String>,
        #[doc = "This is always drive#workspace."]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
        #[doc = "The time at which this Workspace was modifed (formatted RFC 3339 timestamp)."]
        #[serde(rename = "modifiedDate", default)]
        pub modified_date: ::std::option::Option<::chrono::DateTime<chrono::offset::Utc>>,
        #[doc = "The state of the Workspace."]
        #[serde(rename = "state", default)]
        pub state: ::std::option::Option<String>,
        #[doc = "The Workspace title."]
        #[serde(rename = "title", default)]
        pub title: ::std::option::Option<String>,
        #[doc = "Token provided by a suggested workspace. Must be set when accepting the suggestion."]
        #[serde(rename = "workspaceToken", default)]
        pub workspace_token: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for Workspace {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
    #[derive(
        Debug,
        Clone,
        PartialEq,
        Hash,
        PartialOrd,
        Ord,
        Eq,
        Default,
        :: serde :: Deserialize,
        :: serde :: Serialize,
    )]
    pub struct WorkspaceList {
        #[doc = "The list of Workspaces. If nextPageToken is populated, then this list may be incomplete and an additional page of results should be fetched."]
        #[serde(rename = "items", default)]
        pub items: ::std::option::Option<Vec<crate::schemas::Workspace>>,
        #[doc = "This is always drive#workspaceList"]
        #[serde(rename = "kind", default)]
        pub kind: ::std::option::Option<String>,
        #[doc = "The page token for the next page of Workspaces. This will be absent if the end of the Workspaces list has been reached. If the token is rejected for any reason, it should be discarded, and pagination should be restarted from the first page of results."]
        #[serde(rename = "nextPageToken", default)]
        pub next_page_token: ::std::option::Option<String>,
    }
    impl ::field_selector::FieldSelector for WorkspaceList {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
}
pub mod params {
    #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
    pub enum Alt {
        #[doc = "Responses with Content-Type of application/json"]
        Json,
        #[doc = "Upload/Download media content"]
        Media,
    }
    impl Alt {
        pub fn as_str(self) -> &'static str {
            match self {
                Alt::Json => "json",
                Alt::Media => "media",
            }
        }
    }
    impl ::std::fmt::Display for Alt {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl ::serde::Serialize for Alt {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::ser::Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }
    impl<'de> ::serde::Deserialize<'de> for Alt {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::de::Deserializer<'de>,
        {
            let value: &'de str = <&str>::deserialize(deserializer)?;
            Ok(match value {
                "json" => Alt::Json,
                "media" => Alt::Media,
                _ => {
                    return Err(::serde::de::Error::custom(format!(
                        "invalid enum for #name: {}",
                        value
                    )))
                }
            })
        }
    }
    impl ::field_selector::FieldSelector for Alt {
        fn field_selector_with_ident(ident: &str, selector: &mut String) {
            match selector.chars().rev().nth(0) {
                Some(',') | None => {}
                _ => selector.push_str(","),
            }
            selector.push_str(ident);
        }
    }
}
pub struct Client<A> {
    reqwest: ::reqwest::Client,
    auth: ::std::sync::Mutex<A>,
}
impl<A: yup_oauth2::GetToken> Client<A> {
    pub fn new(auth: A) -> Self {
        Client {
            reqwest: ::reqwest::Client::builder().timeout(None).build().unwrap(),
            auth: ::std::sync::Mutex::new(auth),
        }
    }
    #[doc = "Actions that can be performed on the about resource"]
    pub fn about(&self) -> crate::resources::about::AboutActions<A> {
        crate::resources::about::AboutActions {
            reqwest: &self.reqwest,
            auth: &self.auth,
        }
    }
    #[doc = "Actions that can be performed on the admin resource"]
    pub fn admin(&self) -> crate::resources::admin::AdminActions<A> {
        crate::resources::admin::AdminActions {
            reqwest: &self.reqwest,
            auth: &self.auth,
        }
    }
    #[doc = "Actions that can be performed on the approvalevents resource"]
    pub fn approvalevents(&self) -> crate::resources::approvalevents::ApprovaleventsActions<A> {
        crate::resources::approvalevents::ApprovaleventsActions {
            reqwest: &self.reqwest,
            auth: &self.auth,
        }
    }
    #[doc = "Actions that can be performed on the approvals resource"]
    pub fn approvals(&self) -> crate::resources::approvals::ApprovalsActions<A> {
        crate::resources::approvals::ApprovalsActions {
            reqwest: &self.reqwest,
            auth: &self.auth,
        }
    }
    #[doc = "Actions that can be performed on the apps resource"]
    pub fn apps(&self) -> crate::resources::apps::AppsActions<A> {
        crate::resources::apps::AppsActions {
            reqwest: &self.reqwest,
            auth: &self.auth,
        }
    }
    #[doc = "Actions that can be performed on the attachments resource"]
    pub fn attachments(&self) -> crate::resources::attachments::AttachmentsActions<A> {
        crate::resources::attachments::AttachmentsActions {
            reqwest: &self.reqwest,
            auth: &self.auth,
        }
    }
    #[doc = "Actions that can be performed on the backups resource"]
    pub fn backups(&self) -> crate::resources::backups::BackupsActions<A> {
        crate::resources::backups::BackupsActions {
            reqwest: &self.reqwest,
            auth: &self.auth,
        }
    }
    #[doc = "Actions that can be performed on the changes resource"]
    pub fn changes(&self) -> crate::resources::changes::ChangesActions<A> {
        crate::resources::changes::ChangesActions {
            reqwest: &self.reqwest,
            auth: &self.auth,
        }
    }
    #[doc = "Actions that can be performed on the channels resource"]
    pub fn channels(&self) -> crate::resources::channels::ChannelsActions<A> {
        crate::resources::channels::ChannelsActions {
            reqwest: &self.reqwest,
            auth: &self.auth,
        }
    }
    #[doc = "Actions that can be performed on the children resource"]
    pub fn children(&self) -> crate::resources::children::ChildrenActions<A> {
        crate::resources::children::ChildrenActions {
            reqwest: &self.reqwest,
            auth: &self.auth,
        }
    }
    #[doc = "Actions that can be performed on the comments resource"]
    pub fn comments(&self) -> crate::resources::comments::CommentsActions<A> {
        crate::resources::comments::CommentsActions {
            reqwest: &self.reqwest,
            auth: &self.auth,
        }
    }
    #[doc = "Actions that can be performed on the drives resource"]
    pub fn drives(&self) -> crate::resources::drives::DrivesActions<A> {
        crate::resources::drives::DrivesActions {
            reqwest: &self.reqwest,
            auth: &self.auth,
        }
    }
    #[doc = "Actions that can be performed on the files resource"]
    pub fn files(&self) -> crate::resources::files::FilesActions<A> {
        crate::resources::files::FilesActions {
            reqwest: &self.reqwest,
            auth: &self.auth,
        }
    }
    #[doc = "Actions that can be performed on the nextdocpredictions resource"]
    pub fn nextdocpredictions(
        &self,
    ) -> crate::resources::nextdocpredictions::NextdocpredictionsActions<A> {
        crate::resources::nextdocpredictions::NextdocpredictionsActions {
            reqwest: &self.reqwest,
            auth: &self.auth,
        }
    }
    #[doc = "Actions that can be performed on the notifications resource"]
    pub fn notifications(&self) -> crate::resources::notifications::NotificationsActions<A> {
        crate::resources::notifications::NotificationsActions {
            reqwest: &self.reqwest,
            auth: &self.auth,
        }
    }
    #[doc = "Actions that can be performed on the parents resource"]
    pub fn parents(&self) -> crate::resources::parents::ParentsActions<A> {
        crate::resources::parents::ParentsActions {
            reqwest: &self.reqwest,
            auth: &self.auth,
        }
    }
    #[doc = "Actions that can be performed on the permissions resource"]
    pub fn permissions(&self) -> crate::resources::permissions::PermissionsActions<A> {
        crate::resources::permissions::PermissionsActions {
            reqwest: &self.reqwest,
            auth: &self.auth,
        }
    }
    #[doc = "Actions that can be performed on the properties resource"]
    pub fn properties(&self) -> crate::resources::properties::PropertiesActions<A> {
        crate::resources::properties::PropertiesActions {
            reqwest: &self.reqwest,
            auth: &self.auth,
        }
    }
    #[doc = "Actions that can be performed on the realtime resource"]
    pub fn realtime(&self) -> crate::resources::realtime::RealtimeActions<A> {
        crate::resources::realtime::RealtimeActions {
            reqwest: &self.reqwest,
            auth: &self.auth,
        }
    }
    #[doc = "Actions that can be performed on the replies resource"]
    pub fn replies(&self) -> crate::resources::replies::RepliesActions<A> {
        crate::resources::replies::RepliesActions {
            reqwest: &self.reqwest,
            auth: &self.auth,
        }
    }
    #[doc = "Actions that can be performed on the revisions resource"]
    pub fn revisions(&self) -> crate::resources::revisions::RevisionsActions<A> {
        crate::resources::revisions::RevisionsActions {
            reqwest: &self.reqwest,
            auth: &self.auth,
        }
    }
    #[doc = "Actions that can be performed on the settings resource"]
    pub fn settings(&self) -> crate::resources::settings::SettingsActions<A> {
        crate::resources::settings::SettingsActions {
            reqwest: &self.reqwest,
            auth: &self.auth,
        }
    }
    #[doc = "Actions that can be performed on the teamdrives resource"]
    pub fn teamdrives(&self) -> crate::resources::teamdrives::TeamdrivesActions<A> {
        crate::resources::teamdrives::TeamdrivesActions {
            reqwest: &self.reqwest,
            auth: &self.auth,
        }
    }
    #[doc = "Actions that can be performed on the workspaces resource"]
    pub fn workspaces(&self) -> crate::resources::workspaces::WorkspacesActions<A> {
        crate::resources::workspaces::WorkspacesActions {
            reqwest: &self.reqwest,
            auth: &self.auth,
        }
    }
}
pub mod resources {
    pub mod about {
        pub mod params {}
        pub struct AboutActions<'a, A> {
            pub(crate) reqwest: &'a reqwest::Client,
            pub(crate) auth: &'a std::sync::Mutex<A>,
        }
        impl<'a, A: yup_oauth2::GetToken> AboutActions<'a, A> {
            #[doc = "Gets the information about the current user along with Drive API settings"]
            pub fn get(&self) -> GetRequestBuilder<A> {
                GetRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    error_recovery: None,
                    feature_label: None,
                    include_subscribed: None,
                    max_change_id_count: None,
                    mutation_precondition: None,
                    open_drive: None,
                    reason: None,
                    start_change_id: None,
                    sync_type: None,
                }
            }
        }
        #[derive(Debug, Clone)]
        pub struct GetRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            include_subscribed: Option<bool>,
            max_change_id_count: Option<i64>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            reason: Option<String>,
            start_change_id: Option<i64>,
            sync_type: Option<i32>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> GetRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "Deprecated - use changes.getRemainingCount instead."]
            pub fn include_subscribed(mut self, value: bool) -> Self {
                self.include_subscribed = Some(value);
                self
            }
            #[doc = "Deprecated - use changes.getRemainingCount instead."]
            pub fn max_change_id_count(mut self, value: i64) -> Self {
                self.max_change_id_count = Some(value);
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Deprecated - use changes.getRemainingCount instead."]
            pub fn start_change_id(mut self, value: i64) -> Self {
                self.start_change_id = Some(value);
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::About, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::About, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("about");
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::GET, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("includeSubscribed", &self.include_subscribed)]);
                let req = req.query(&[("maxChangeIdCount", &self.max_change_id_count)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("startChangeId", &self.start_change_id)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec![
                    "https://www.googleapis.com/auth/drive.metadata.readonly",
                ]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
    }
    pub mod admin {
        pub mod params {}
        pub struct AdminActions<'a, A> {
            pub(crate) reqwest: &'a reqwest::Client,
            pub(crate) auth: &'a std::sync::Mutex<A>,
        }
        impl<'a, A: yup_oauth2::GetToken> AdminActions<'a, A> {
            #[doc = "Actions that can be performed on the files resource"]
            pub fn files(&self) -> crate::resources::admin::files::FilesActions<A> {
                crate::resources::admin::files::FilesActions {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                }
            }
        }
        pub mod files {
            pub mod params {}
            pub struct FilesActions<'a, A> {
                pub(crate) reqwest: &'a reqwest::Client,
                pub(crate) auth: &'a std::sync::Mutex<A>,
            }
            impl<'a, A: yup_oauth2::GetToken> FilesActions<'a, A> {
                #[doc = "Migrates a file into a Team Drive. The file and Team Drive must belong to the same Domain, and the requester must be a migration administrator for that domain. The response contains the ID of the migrated file within the Team Drive. If the file is a folder, this ID will be different than the originating ID."]
                pub fn migrate_to_team_drive(
                    &self,
                    request: crate::schemas::AdminFile,
                    file_id: impl Into<String>,
                ) -> MigrateToTeamDriveRequestBuilder<A> {
                    MigrateToTeamDriveRequestBuilder {
                        reqwest: &self.reqwest,
                        auth: &self.auth,
                        request,
                        alt: None,
                        fields: None,
                        key: None,
                        oauth_token: None,
                        pretty_print: None,
                        quota_user: None,
                        user_ip: None,
                        file_id: file_id.into(),
                        error_recovery: None,
                        feature_label: None,
                        mutation_precondition: None,
                        open_drive: None,
                        reason: None,
                        sync_type: None,
                    }
                }
            }
            #[derive(Debug, Clone)]
            pub struct MigrateToTeamDriveRequestBuilder<'a, A> {
                pub(crate) reqwest: &'a ::reqwest::Client,
                pub(crate) auth: &'a ::std::sync::Mutex<A>,
                request: crate::schemas::AdminFile,
                file_id: String,
                error_recovery: Option<bool>,
                feature_label: Option<String>,
                mutation_precondition: Option<bool>,
                open_drive: Option<bool>,
                reason: Option<String>,
                sync_type: Option<i32>,
                alt: Option<crate::params::Alt>,
                fields: Option<String>,
                key: Option<String>,
                oauth_token: Option<String>,
                pretty_print: Option<bool>,
                quota_user: Option<String>,
                user_ip: Option<String>,
            }
            impl<'a, A: yup_oauth2::GetToken> MigrateToTeamDriveRequestBuilder<'a, A> {
                #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
                pub fn error_recovery(mut self, value: bool) -> Self {
                    self.error_recovery = Some(value);
                    self
                }
                #[doc = "The label associated with a tracked feature rollout."]
                pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                    self.feature_label = Some(value.into());
                    self
                }
                #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
                pub fn mutation_precondition(mut self, value: bool) -> Self {
                    self.mutation_precondition = Some(value);
                    self
                }
                #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
                pub fn open_drive(mut self, value: bool) -> Self {
                    self.open_drive = Some(value);
                    self
                }
                #[doc = "The user action or internal event that triggered the request."]
                pub fn reason(mut self, value: impl Into<String>) -> Self {
                    self.reason = Some(value.into());
                    self
                }
                #[doc = "Whether the request is blocking a user action or not."]
                pub fn sync_type(mut self, value: i32) -> Self {
                    self.sync_type = Some(value);
                    self
                }
                #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
                pub fn key(mut self, value: impl Into<String>) -> Self {
                    self.key = Some(value.into());
                    self
                }
                #[doc = "OAuth 2.0 token for the current user."]
                pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                    self.oauth_token = Some(value.into());
                    self
                }
                #[doc = "Returns response with indentations and line breaks."]
                pub fn pretty_print(mut self, value: bool) -> Self {
                    self.pretty_print = Some(value);
                    self
                }
                #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
                pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                    self.quota_user = Some(value.into());
                    self
                }
                #[doc = "Deprecated. Please use quotaUser instead."]
                pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                    self.user_ip = Some(value.into());
                    self
                }
                #[doc = r" Execute the given operation. The fields requested are"]
                #[doc = r" determined by the FieldSelector attribute of the return type."]
                #[doc = r" This allows for flexible and ergonomic partial responses. See"]
                #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
                #[doc = r" are not generic over the return type and deserialize the"]
                #[doc = r" response into an auto-generated struct will all possible"]
                #[doc = r" fields."]
                pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
                where
                    T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
                {
                    let fields = T::field_selector();
                    let fields: Option<String> = if fields.is_empty() {
                        None
                    } else {
                        Some(fields)
                    };
                    self.execute_fields(fields)
                }
                #[doc = r" Execute the given operation. This will not provide any"]
                #[doc = r" `fields` selector indicating that the server will determine"]
                #[doc = r" the fields returned. This typically includes the most common"]
                #[doc = r" fields, but it will not include every possible attribute of"]
                #[doc = r" the response resource."]
                pub fn execute_standard(
                    self,
                ) -> Result<crate::schemas::AdminFile, Box<dyn ::std::error::Error>>
                {
                    self.execute_fields::<_, &str>(None)
                }
                #[doc = r" Execute the given operation. This will provide a `fields`"]
                #[doc = r" selector of `*`. This will include every attribute of the"]
                #[doc = r" response resource and should be limited to use during"]
                #[doc = r" development or debugging."]
                pub fn execute_debug(
                    self,
                ) -> Result<crate::schemas::AdminFile, Box<dyn ::std::error::Error>>
                {
                    self.execute_fields(Some("*"))
                }
                #[doc = r" Execute the given operation. This will use the `fields`"]
                #[doc = r" selector provided and will deserialize the response into"]
                #[doc = r" whatever return value is provided."]
                pub fn execute_fields<T, F>(
                    mut self,
                    fields: Option<F>,
                ) -> Result<T, Box<dyn ::std::error::Error>>
                where
                    T: ::serde::de::DeserializeOwned,
                    F: Into<String>,
                {
                    self.fields = fields.map(Into::into);
                    self._execute()
                }
                fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
                where
                    T: ::serde::de::DeserializeOwned,
                {
                    let req = self._request(&self._path());
                    let req = req.json(&self.request);
                    Ok(req.send()?.error_for_status()?.json()?)
                }
                fn _path(&self) -> String {
                    let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                    output.push_str("admin/files/");
                    {
                        let var_as_str = &self.file_id;
                        output.extend(::percent_encoding::utf8_percent_encode(
                            &var_as_str,
                            crate::SIMPLE,
                        ));
                    }
                    output.push_str("/migrateToTeamDrive");
                    output
                }
                fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                    let req = self.reqwest.request(::reqwest::Method::POST, path);
                    let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                    let req = req.query(&[("featureLabel", &self.feature_label)]);
                    let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                    let req = req.query(&[("openDrive", &self.open_drive)]);
                    let req = req.query(&[("reason", &self.reason)]);
                    let req = req.query(&[("syncType", &self.sync_type)]);
                    let req = req.query(&[("alt", &self.alt)]);
                    let req = req.query(&[("fields", &self.fields)]);
                    let req = req.query(&[("key", &self.key)]);
                    let req = req.query(&[("oauth_token", &self.oauth_token)]);
                    let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                    let req = req.query(&[("quotaUser", &self.quota_user)]);
                    let req = req.query(&[("userIp", &self.user_ip)]);
                    let mut auth = self.auth.lock().unwrap();
                    let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                    let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                    let token = runtime.block_on(fut).unwrap().access_token;
                    let req = req.bearer_auth(&token);
                    req
                }
            }
        }
    }
    pub mod approvalevents {
        pub mod params {}
        pub struct ApprovaleventsActions<'a, A> {
            pub(crate) reqwest: &'a reqwest::Client,
            pub(crate) auth: &'a std::sync::Mutex<A>,
        }
        impl<'a, A: yup_oauth2::GetToken> ApprovaleventsActions<'a, A> {
            #[doc = "Gets an ApprovalEvent by ID."]
            pub fn get(
                &self,
                file_id: impl Into<String>,
                approval_id: impl Into<String>,
                event_id: impl Into<String>,
            ) -> GetRequestBuilder<A> {
                GetRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    file_id: file_id.into(),
                    approval_id: approval_id.into(),
                    event_id: event_id.into(),
                    error_recovery: None,
                    feature_label: None,
                    mutation_precondition: None,
                    open_drive: None,
                    reason: None,
                    sync_type: None,
                }
            }
            #[doc = "Lists all ApprovalEvents on an Approval."]
            pub fn list(
                &self,
                file_id: impl Into<String>,
                approval_id: impl Into<String>,
            ) -> ListRequestBuilder<A> {
                ListRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    file_id: file_id.into(),
                    approval_id: approval_id.into(),
                    error_recovery: None,
                    feature_label: None,
                    max_results: None,
                    mutation_precondition: None,
                    open_drive: None,
                    page_token: None,
                    reason: None,
                    sync_type: None,
                }
            }
        }
        #[derive(Debug, Clone)]
        pub struct GetRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            file_id: String,
            approval_id: String,
            event_id: String,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            reason: Option<String>,
            sync_type: Option<i32>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> GetRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::ApprovalEvent, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::ApprovalEvent, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files/");
                {
                    let var_as_str = &self.file_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/approvals/");
                {
                    let var_as_str = &self.approval_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/events/");
                {
                    let var_as_str = &self.event_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::GET, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct ListRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            file_id: String,
            approval_id: String,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            max_results: Option<i32>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            page_token: Option<String>,
            reason: Option<String>,
            sync_type: Option<i32>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> ListRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "The maximum number of ApprovalEvents to return per page."]
            pub fn max_results(mut self, value: i32) -> Self {
                self.max_results = Some(value);
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The page token for the ApprovalEvents list."]
            pub fn page_token(mut self, value: impl Into<String>) -> Self {
                self.page_token = Some(value.into());
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Return an iterator that iterates over all `#prop_ident`. The"]
            #[doc = r" items yielded by the iterator are chosen by the caller of this"]
            #[doc = r" method and must implement `Deserialize` and `FieldSelector`. The"]
            #[doc = r" populated fields in the yielded items will be determined by the"]
            #[doc = r" `FieldSelector` implementation."]
            pub fn iter_items<T>(mut self) -> crate::iter::PageItemIter<Self, T>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let mut fields = concat!("nextPageToken,", "items").to_owned();
                let items_fields = T::field_selector();
                if !items_fields.is_empty() {
                    fields.push_str("(");
                    fields.push_str(&items_fields);
                    fields.push_str(")");
                }
                self.fields = Some(fields);
                crate::iter::PageItemIter::new(self, "items")
            }
            #[doc = r" Return an iterator that iterates over all `#prop_ident`. The"]
            #[doc = r" items yielded by the iterator are `#items_type`. The populated"]
            #[doc = r" fields in `#items_type` will be the default fields populated by"]
            #[doc = r" the server."]
            pub fn iter_items_standard(
                mut self,
            ) -> crate::iter::PageItemIter<Self, crate::schemas::ApprovalEvent> {
                self.fields = Some(concat!("nextPageToken,", "items").to_owned());
                crate::iter::PageItemIter::new(self, "items")
            }
            #[doc = r" Return an iterator that iterates over all `#prop_ident`. The"]
            #[doc = r" items yielded by the iterator are `#items_type`. The populated"]
            #[doc = r" fields in `#items_type` will be all fields available. This should"]
            #[doc = r" primarily be used during developement and debugging as fetching"]
            #[doc = r" all fields can be expensive both in bandwidth and server"]
            #[doc = r" resources."]
            pub fn iter_items_debug(
                mut self,
            ) -> crate::iter::PageItemIter<Self, crate::schemas::ApprovalEvent> {
                self.fields = Some(concat!("nextPageToken,", "items", "(*)").to_owned());
                crate::iter::PageItemIter::new(self, "items")
            }
            pub fn iter<T>(mut self) -> crate::iter::PageIter<Self, T>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let mut fields = T::field_selector();
                if !fields.is_empty() {
                    match fields.chars().rev().nth(0) {
                        Some(',') | None => {}
                        _ => fields.push_str(","),
                    }
                    fields.push_str("nextPageToken");
                    self.fields = Some(fields);
                }
                crate::iter::PageIter::new(self)
            }
            pub fn iter_standard(
                self,
            ) -> crate::iter::PageIter<Self, crate::schemas::ApprovalEventList> {
                crate::iter::PageIter::new(self)
            }
            pub fn iter_debug(
                mut self,
            ) -> crate::iter::PageIter<Self, crate::schemas::ApprovalEventList> {
                self.fields = Some("*".to_owned());
                crate::iter::PageIter::new(self)
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::ApprovalEventList, Box<dyn ::std::error::Error>>
            {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::ApprovalEventList, Box<dyn ::std::error::Error>>
            {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files/");
                {
                    let var_as_str = &self.file_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/approvals/");
                {
                    let var_as_str = &self.approval_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/events");
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::GET, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("maxResults", &self.max_results)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("pageToken", &self.page_token)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        impl<'a, A: yup_oauth2::GetToken> crate::iter::IterableMethod for ListRequestBuilder<'a, A> {
            fn set_page_token(&mut self, value: String) {
                self.page_token = value.into();
            }
            fn execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                self._execute()
            }
        }
    }
    pub mod approvals {
        pub mod params {}
        pub struct ApprovalsActions<'a, A> {
            pub(crate) reqwest: &'a reqwest::Client,
            pub(crate) auth: &'a std::sync::Mutex<A>,
        }
        impl<'a, A: yup_oauth2::GetToken> ApprovalsActions<'a, A> {
            #[doc = "DEPRECATED; use drive.approvals.recordDecision instead."]
            pub fn approve(
                &self,
                request: crate::schemas::ApprovalEventRequest,
                file_id: impl Into<String>,
                approval_id: impl Into<String>,
            ) -> ApproveRequestBuilder<A> {
                ApproveRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    request,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    file_id: file_id.into(),
                    approval_id: approval_id.into(),
                    error_recovery: None,
                    feature_label: None,
                    mutation_precondition: None,
                    open_drive: None,
                    reason: None,
                    sync_type: None,
                }
            }
            #[doc = "Cancel an Approval."]
            pub fn cancel(
                &self,
                request: crate::schemas::ApprovalEventRequest,
                file_id: impl Into<String>,
                approval_id: impl Into<String>,
            ) -> CancelRequestBuilder<A> {
                CancelRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    request,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    file_id: file_id.into(),
                    approval_id: approval_id.into(),
                    error_recovery: None,
                    feature_label: None,
                    mutation_precondition: None,
                    open_drive: None,
                    reason: None,
                    sync_type: None,
                }
            }
            #[doc = "Change the reviewers on the Approval."]
            pub fn change_reviewers(
                &self,
                request: crate::schemas::ApprovalChangeReviewers,
                file_id: impl Into<String>,
                approval_id: impl Into<String>,
            ) -> ChangeReviewersRequestBuilder<A> {
                ChangeReviewersRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    request,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    file_id: file_id.into(),
                    approval_id: approval_id.into(),
                    error_recovery: None,
                    feature_label: None,
                    mutation_precondition: None,
                    open_drive: None,
                    reason: None,
                    sync_type: None,
                }
            }
            #[doc = "Comment on an Approval."]
            pub fn comment(
                &self,
                request: crate::schemas::ApprovalEventRequest,
                file_id: impl Into<String>,
                approval_id: impl Into<String>,
            ) -> CommentRequestBuilder<A> {
                CommentRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    request,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    file_id: file_id.into(),
                    approval_id: approval_id.into(),
                    error_recovery: None,
                    feature_label: None,
                    mutation_precondition: None,
                    open_drive: None,
                    reason: None,
                    sync_type: None,
                }
            }
            #[doc = "DEPRECATED; use drive.approvals.recordDecision instead."]
            pub fn decline(
                &self,
                request: crate::schemas::ApprovalEventRequest,
                file_id: impl Into<String>,
                approval_id: impl Into<String>,
            ) -> DeclineRequestBuilder<A> {
                DeclineRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    request,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    file_id: file_id.into(),
                    approval_id: approval_id.into(),
                    error_recovery: None,
                    feature_label: None,
                    mutation_precondition: None,
                    open_drive: None,
                    reason: None,
                    sync_type: None,
                }
            }
            #[doc = "Gets an Approval by ID."]
            pub fn get(
                &self,
                file_id: impl Into<String>,
                approval_id: impl Into<String>,
            ) -> GetRequestBuilder<A> {
                GetRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    file_id: file_id.into(),
                    approval_id: approval_id.into(),
                    error_recovery: None,
                    feature_label: None,
                    mutation_precondition: None,
                    open_drive: None,
                    reason: None,
                    sync_type: None,
                }
            }
            #[doc = "Inserts a new Approval."]
            pub fn insert(
                &self,
                request: crate::schemas::Approval,
                file_id: impl Into<String>,
            ) -> InsertRequestBuilder<A> {
                InsertRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    request,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    file_id: file_id.into(),
                    error_recovery: None,
                    feature_label: None,
                    mutation_precondition: None,
                    open_drive: None,
                    reason: None,
                    sync_type: None,
                }
            }
            #[doc = "Lists all approvals on a Drive item."]
            pub fn list(&self, file_id: impl Into<String>) -> ListRequestBuilder<A> {
                ListRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    file_id: file_id.into(),
                    error_recovery: None,
                    feature_label: None,
                    max_results: None,
                    mutation_precondition: None,
                    open_drive: None,
                    page_token: None,
                    reason: None,
                    sync_type: None,
                }
            }
            #[doc = "Record a decision on an Approval. Only reviewers can make a decision."]
            pub fn record_decision(
                &self,
                request: crate::schemas::ApprovalDecisionRequest,
                file_id: impl Into<String>,
                approval_id: impl Into<String>,
            ) -> RecordDecisionRequestBuilder<A> {
                RecordDecisionRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    request,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    file_id: file_id.into(),
                    approval_id: approval_id.into(),
                    error_recovery: None,
                    feature_label: None,
                    mutation_precondition: None,
                    open_drive: None,
                    reason: None,
                    sync_type: None,
                }
            }
            #[doc = "Update the Approval's due date. If a date is not specified then any existing due date will be removed."]
            pub fn set_due_date(
                &self,
                request: crate::schemas::ApprovalDueDate,
                file_id: impl Into<String>,
                approval_id: impl Into<String>,
            ) -> SetDueDateRequestBuilder<A> {
                SetDueDateRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    request,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    file_id: file_id.into(),
                    approval_id: approval_id.into(),
                    error_recovery: None,
                    feature_label: None,
                    mutation_precondition: None,
                    open_drive: None,
                    reason: None,
                    sync_type: None,
                }
            }
        }
        #[derive(Debug, Clone)]
        pub struct ApproveRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            request: crate::schemas::ApprovalEventRequest,
            file_id: String,
            approval_id: String,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            reason: Option<String>,
            sync_type: Option<i32>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> ApproveRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::Approval, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::Approval, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                let req = req.json(&self.request);
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files/");
                {
                    let var_as_str = &self.file_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/approvals/");
                {
                    let var_as_str = &self.approval_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/approve");
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::POST, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct CancelRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            request: crate::schemas::ApprovalEventRequest,
            file_id: String,
            approval_id: String,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            reason: Option<String>,
            sync_type: Option<i32>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> CancelRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::Approval, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::Approval, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                let req = req.json(&self.request);
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files/");
                {
                    let var_as_str = &self.file_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/approvals/");
                {
                    let var_as_str = &self.approval_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/cancel");
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::POST, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct ChangeReviewersRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            request: crate::schemas::ApprovalChangeReviewers,
            file_id: String,
            approval_id: String,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            reason: Option<String>,
            sync_type: Option<i32>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> ChangeReviewersRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::Approval, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::Approval, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                let req = req.json(&self.request);
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files/");
                {
                    let var_as_str = &self.file_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/approvals/");
                {
                    let var_as_str = &self.approval_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/changeReviewers");
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::POST, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct CommentRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            request: crate::schemas::ApprovalEventRequest,
            file_id: String,
            approval_id: String,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            reason: Option<String>,
            sync_type: Option<i32>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> CommentRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::Approval, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::Approval, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                let req = req.json(&self.request);
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files/");
                {
                    let var_as_str = &self.file_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/approvals/");
                {
                    let var_as_str = &self.approval_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/comment");
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::POST, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct DeclineRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            request: crate::schemas::ApprovalEventRequest,
            file_id: String,
            approval_id: String,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            reason: Option<String>,
            sync_type: Option<i32>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> DeclineRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::Approval, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::Approval, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                let req = req.json(&self.request);
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files/");
                {
                    let var_as_str = &self.file_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/approvals/");
                {
                    let var_as_str = &self.approval_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/decline");
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::POST, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct GetRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            file_id: String,
            approval_id: String,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            reason: Option<String>,
            sync_type: Option<i32>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> GetRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::Approval, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::Approval, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files/");
                {
                    let var_as_str = &self.file_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/approvals/");
                {
                    let var_as_str = &self.approval_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::GET, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct InsertRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            request: crate::schemas::Approval,
            file_id: String,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            reason: Option<String>,
            sync_type: Option<i32>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> InsertRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::Approval, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::Approval, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                let req = req.json(&self.request);
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files/");
                {
                    let var_as_str = &self.file_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/approvals");
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::POST, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct ListRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            file_id: String,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            max_results: Option<i32>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            page_token: Option<String>,
            reason: Option<String>,
            sync_type: Option<i32>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> ListRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "The maximum number of Approvals to return per page. Partial or empty result pages are possible even before the end of the files list has been reached."]
            pub fn max_results(mut self, value: i32) -> Self {
                self.max_results = Some(value);
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The page token for the Approvals list."]
            pub fn page_token(mut self, value: impl Into<String>) -> Self {
                self.page_token = Some(value.into());
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Return an iterator that iterates over all `#prop_ident`. The"]
            #[doc = r" items yielded by the iterator are chosen by the caller of this"]
            #[doc = r" method and must implement `Deserialize` and `FieldSelector`. The"]
            #[doc = r" populated fields in the yielded items will be determined by the"]
            #[doc = r" `FieldSelector` implementation."]
            pub fn iter_items<T>(mut self) -> crate::iter::PageItemIter<Self, T>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let mut fields = concat!("nextPageToken,", "items").to_owned();
                let items_fields = T::field_selector();
                if !items_fields.is_empty() {
                    fields.push_str("(");
                    fields.push_str(&items_fields);
                    fields.push_str(")");
                }
                self.fields = Some(fields);
                crate::iter::PageItemIter::new(self, "items")
            }
            #[doc = r" Return an iterator that iterates over all `#prop_ident`. The"]
            #[doc = r" items yielded by the iterator are `#items_type`. The populated"]
            #[doc = r" fields in `#items_type` will be the default fields populated by"]
            #[doc = r" the server."]
            pub fn iter_items_standard(
                mut self,
            ) -> crate::iter::PageItemIter<Self, crate::schemas::Approval> {
                self.fields = Some(concat!("nextPageToken,", "items").to_owned());
                crate::iter::PageItemIter::new(self, "items")
            }
            #[doc = r" Return an iterator that iterates over all `#prop_ident`. The"]
            #[doc = r" items yielded by the iterator are `#items_type`. The populated"]
            #[doc = r" fields in `#items_type` will be all fields available. This should"]
            #[doc = r" primarily be used during developement and debugging as fetching"]
            #[doc = r" all fields can be expensive both in bandwidth and server"]
            #[doc = r" resources."]
            pub fn iter_items_debug(
                mut self,
            ) -> crate::iter::PageItemIter<Self, crate::schemas::Approval> {
                self.fields = Some(concat!("nextPageToken,", "items", "(*)").to_owned());
                crate::iter::PageItemIter::new(self, "items")
            }
            pub fn iter<T>(mut self) -> crate::iter::PageIter<Self, T>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let mut fields = T::field_selector();
                if !fields.is_empty() {
                    match fields.chars().rev().nth(0) {
                        Some(',') | None => {}
                        _ => fields.push_str(","),
                    }
                    fields.push_str("nextPageToken");
                    self.fields = Some(fields);
                }
                crate::iter::PageIter::new(self)
            }
            pub fn iter_standard(
                self,
            ) -> crate::iter::PageIter<Self, crate::schemas::ApprovalList> {
                crate::iter::PageIter::new(self)
            }
            pub fn iter_debug(
                mut self,
            ) -> crate::iter::PageIter<Self, crate::schemas::ApprovalList> {
                self.fields = Some("*".to_owned());
                crate::iter::PageIter::new(self)
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::ApprovalList, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::ApprovalList, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files/");
                {
                    let var_as_str = &self.file_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/approvals");
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::GET, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("maxResults", &self.max_results)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("pageToken", &self.page_token)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        impl<'a, A: yup_oauth2::GetToken> crate::iter::IterableMethod for ListRequestBuilder<'a, A> {
            fn set_page_token(&mut self, value: String) {
                self.page_token = value.into();
            }
            fn execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                self._execute()
            }
        }
        #[derive(Debug, Clone)]
        pub struct RecordDecisionRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            request: crate::schemas::ApprovalDecisionRequest,
            file_id: String,
            approval_id: String,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            reason: Option<String>,
            sync_type: Option<i32>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> RecordDecisionRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::Approval, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::Approval, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                let req = req.json(&self.request);
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files/");
                {
                    let var_as_str = &self.file_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/approvals/");
                {
                    let var_as_str = &self.approval_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/recordDecision");
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::POST, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct SetDueDateRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            request: crate::schemas::ApprovalDueDate,
            file_id: String,
            approval_id: String,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            reason: Option<String>,
            sync_type: Option<i32>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> SetDueDateRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::Approval, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::Approval, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                let req = req.json(&self.request);
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files/");
                {
                    let var_as_str = &self.file_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/approvals/");
                {
                    let var_as_str = &self.approval_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/setDueDate");
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::POST, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
    }
    pub mod apps {
        pub mod params {
            #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
            pub enum ListAppQueryScope {
                #[doc = "Include all apps known in the webstore."]
                AllWebstore,
                #[doc = "A deprecated alias for USER_APP_GRANT."]
                AuthorizedOrInstalled,
                #[doc = "Query apps granted to the user. Use userAppGrantSource to select the sources."]
                UserAppGrant,
            }
            impl ListAppQueryScope {
                pub fn as_str(self) -> &'static str {
                    match self {
                        ListAppQueryScope::AllWebstore => "ALL_WEBSTORE",
                        ListAppQueryScope::AuthorizedOrInstalled => "AUTHORIZED_OR_INSTALLED",
                        ListAppQueryScope::UserAppGrant => "USER_APP_GRANT",
                    }
                }
            }
            impl ::std::fmt::Display for ListAppQueryScope {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    f.write_str(self.as_str())
                }
            }
            impl ::serde::Serialize for ListAppQueryScope {
                fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
                where
                    S: ::serde::ser::Serializer,
                {
                    serializer.serialize_str(self.as_str())
                }
            }
            impl<'de> ::serde::Deserialize<'de> for ListAppQueryScope {
                fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
                where
                    D: ::serde::de::Deserializer<'de>,
                {
                    let value: &'de str = <&str>::deserialize(deserializer)?;
                    Ok(match value {
                        "ALL_WEBSTORE" => ListAppQueryScope::AllWebstore,
                        "AUTHORIZED_OR_INSTALLED" => ListAppQueryScope::AuthorizedOrInstalled,
                        "USER_APP_GRANT" => ListAppQueryScope::UserAppGrant,
                        _ => {
                            return Err(::serde::de::Error::custom(format!(
                                "invalid enum for #name: {}",
                                value
                            )))
                        }
                    })
                }
            }
            impl ::field_selector::FieldSelector for ListAppQueryScope {
                fn field_selector_with_ident(ident: &str, selector: &mut String) {
                    match selector.chars().rev().nth(0) {
                        Some(',') | None => {}
                        _ => selector.push_str(","),
                    }
                    selector.push_str(ident);
                }
            }
        }
        pub struct AppsActions<'a, A> {
            pub(crate) reqwest: &'a reqwest::Client,
            pub(crate) auth: &'a std::sync::Mutex<A>,
        }
        impl<'a, A: yup_oauth2::GetToken> AppsActions<'a, A> {
            #[doc = "Uninstall this app."]
            pub fn delete(&self, app_id: impl Into<String>) -> DeleteRequestBuilder<A> {
                DeleteRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    app_id: app_id.into(),
                    delete_app_data: None,
                    error_recovery: None,
                    feature_label: None,
                    mutation_precondition: None,
                    open_drive: None,
                    reason: None,
                    sync_type: None,
                }
            }
            #[doc = "Gets a specific app."]
            pub fn get(&self, app_id: impl Into<String>) -> GetRequestBuilder<A> {
                GetRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    app_id: app_id.into(),
                    error_recovery: None,
                    feature_label: None,
                    mutation_precondition: None,
                    open_drive: None,
                    reason: None,
                    sync_type: None,
                }
            }
            #[doc = "Install this app."]
            pub fn insert(&self) -> InsertRequestBuilder<A> {
                InsertRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    app_id: None,
                    error_recovery: None,
                    feature_label: None,
                    mutation_precondition: None,
                    open_drive: None,
                    reason: None,
                    sync_type: None,
                }
            }
            #[doc = "Lists a user's installed apps."]
            pub fn list(&self) -> ListRequestBuilder<A> {
                ListRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    app_filter_extensions: None,
                    app_filter_mime_types: None,
                    app_query_scope: None,
                    error_recovery: None,
                    feature_label: None,
                    include_hidden: None,
                    language_code: None,
                    mutation_precondition: None,
                    no_cache: None,
                    open_drive: None,
                    reason: None,
                    sync_type: None,
                    user_app_grant_source: None,
                }
            }
            #[doc = "Update the properties of this app. This method supports patch semantics."]
            pub fn patch(
                &self,
                request: crate::schemas::App,
                app_id: impl Into<String>,
            ) -> PatchRequestBuilder<A> {
                PatchRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    request,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    app_id: app_id.into(),
                    error_recovery: None,
                    feature_label: None,
                    mutation_precondition: None,
                    open_drive: None,
                    reason: None,
                    sync_type: None,
                }
            }
            #[doc = "Update the properties of this app."]
            pub fn update(
                &self,
                request: crate::schemas::App,
                app_id: impl Into<String>,
            ) -> UpdateRequestBuilder<A> {
                UpdateRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    request,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    app_id: app_id.into(),
                    error_recovery: None,
                    feature_label: None,
                    mutation_precondition: None,
                    open_drive: None,
                    reason: None,
                    sync_type: None,
                }
            }
        }
        #[derive(Debug, Clone)]
        pub struct DeleteRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            app_id: String,
            delete_app_data: Option<bool>,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            reason: Option<String>,
            sync_type: Option<i32>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> DeleteRequestBuilder<'a, A> {
            #[doc = "Whether to delete the App Data folder."]
            pub fn delete_app_data(mut self, value: bool) -> Self {
                self.delete_app_data = Some(value);
                self
            }
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            pub fn execute(self) -> Result<(), Box<dyn ::std::error::Error>> {
                let req = self._request(&self._path());
                req.send()?.error_for_status()?;
                Ok(())
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("apps/");
                {
                    let var_as_str = &self.app_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::DELETE, path);
                let req = req.query(&[("deleteAppData", &self.delete_app_data)]);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct GetRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            app_id: String,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            reason: Option<String>,
            sync_type: Option<i32>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> GetRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::App, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::App, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("apps/");
                {
                    let var_as_str = &self.app_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::GET, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive.apps.readonly"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct InsertRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            app_id: Option<String>,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            reason: Option<String>,
            sync_type: Option<i32>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> InsertRequestBuilder<'a, A> {
            #[doc = "The app to install. If no app is given, the calling app is used."]
            pub fn app_id(mut self, value: impl Into<String>) -> Self {
                self.app_id = Some(value.into());
                self
            }
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::App, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::App, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("apps");
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::POST, path);
                let req = req.query(&[("appId", &self.app_id)]);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct ListRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            app_filter_extensions: Option<String>,
            app_filter_mime_types: Option<String>,
            app_query_scope: Option<crate::resources::apps::params::ListAppQueryScope>,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            include_hidden: Option<bool>,
            language_code: Option<String>,
            mutation_precondition: Option<bool>,
            no_cache: Option<String>,
            open_drive: Option<bool>,
            reason: Option<String>,
            sync_type: Option<i32>,
            user_app_grant_source: Option<String>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> ListRequestBuilder<'a, A> {
            #[doc = "A comma-separated list of file extensions for open with filtering. All apps within the given app query scope which can open any of the given file extensions will be included in the response. If appFilterMimeTypes are provided as well, the result is a union of the two resulting app lists."]
            pub fn app_filter_extensions(mut self, value: impl Into<String>) -> Self {
                self.app_filter_extensions = Some(value.into());
                self
            }
            #[doc = "A comma-separated list of mimetypes for open with filtering. All apps within the given app query scope which can open any of the given mimetypes will be included in the response. If appFilterExtensions are provided as well, the result is a union of the two resulting app lists."]
            pub fn app_filter_mime_types(mut self, value: impl Into<String>) -> Self {
                self.app_filter_mime_types = Some(value.into());
                self
            }
            #[doc = "The scope of this query."]
            pub fn app_query_scope(
                mut self,
                value: crate::resources::apps::params::ListAppQueryScope,
            ) -> Self {
                self.app_query_scope = Some(value);
                self
            }
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "Whether to include apps that are normally suppressed in results, like first-party apps."]
            pub fn include_hidden(mut self, value: bool) -> Self {
                self.include_hidden = Some(value);
                self
            }
            #[doc = "A language or locale code, as defined by BCP 47, with some extensions from Unicode's LDML format (http://www.unicode.org/reports/tr35/)."]
            pub fn language_code(mut self, value: impl Into<String>) -> Self {
                self.language_code = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "A comma-separated list of the sources for which to disallow caching. Currently, the only acceptable value is SOURCE."]
            pub fn no_cache(mut self, value: impl Into<String>) -> Self {
                self.no_cache = Some(value.into());
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "A comma-separated list of the sources of user apps to query: AUTHORIZED, INSTALLED, or SOURCE."]
            pub fn user_app_grant_source(mut self, value: impl Into<String>) -> Self {
                self.user_app_grant_source = Some(value.into());
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::AppList, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::AppList, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("apps");
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::GET, path);
                let req = req.query(&[("appFilterExtensions", &self.app_filter_extensions)]);
                let req = req.query(&[("appFilterMimeTypes", &self.app_filter_mime_types)]);
                let req = req.query(&[("appQueryScope", &self.app_query_scope)]);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("includeHidden", &self.include_hidden)]);
                let req = req.query(&[("languageCode", &self.language_code)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("noCache", &self.no_cache)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("userAppGrantSource", &self.user_app_grant_source)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive.apps.readonly"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct PatchRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            request: crate::schemas::App,
            app_id: String,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            reason: Option<String>,
            sync_type: Option<i32>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> PatchRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::App, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::App, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                let req = req.json(&self.request);
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("apps/");
                {
                    let var_as_str = &self.app_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::PATCH, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct UpdateRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            request: crate::schemas::App,
            app_id: String,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            reason: Option<String>,
            sync_type: Option<i32>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> UpdateRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::App, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::App, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                let req = req.json(&self.request);
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("apps/");
                {
                    let var_as_str = &self.app_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::PUT, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                req
            }
        }
    }
    pub mod attachments {
        pub mod params {}
        pub struct AttachmentsActions<'a, A> {
            pub(crate) reqwest: &'a reqwest::Client,
            pub(crate) auth: &'a std::sync::Mutex<A>,
        }
        impl<'a, A: yup_oauth2::GetToken> AttachmentsActions<'a, A> {
            #[doc = "Inserts a gmail attachment into drive."]
            pub fn insert(&self, request: crate::schemas::Attachment) -> InsertRequestBuilder<A> {
                InsertRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    request,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    error_recovery: None,
                    feature_label: None,
                    mutation_precondition: None,
                    open_drive: None,
                    reason: None,
                    sync_type: None,
                }
            }
        }
        #[derive(Debug, Clone)]
        pub struct InsertRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            request: crate::schemas::Attachment,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            reason: Option<String>,
            sync_type: Option<i32>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> InsertRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::Attachment, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::Attachment, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                let req = req.json(&self.request);
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("attachments");
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::POST, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
    }
    pub mod backups {
        pub mod params {}
        pub struct BackupsActions<'a, A> {
            pub(crate) reqwest: &'a reqwest::Client,
            pub(crate) auth: &'a std::sync::Mutex<A>,
        }
        impl<'a, A: yup_oauth2::GetToken> BackupsActions<'a, A> {
            #[doc = "Deletes a backup."]
            pub fn delete(&self, backup_id: impl Into<String>) -> DeleteRequestBuilder<A> {
                DeleteRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    backup_id: backup_id.into(),
                    error_recovery: None,
                    feature_label: None,
                    mutation_precondition: None,
                    open_drive: None,
                    reason: None,
                    sync_type: None,
                }
            }
            #[doc = "Gets a backup's metadata by ID."]
            pub fn get(&self, backup_id: impl Into<String>) -> GetRequestBuilder<A> {
                GetRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    backup_id: backup_id.into(),
                    error_recovery: None,
                    feature_label: None,
                    mutation_precondition: None,
                    open_drive: None,
                    reason: None,
                    sync_type: None,
                }
            }
            #[doc = "Lists backups for a user."]
            pub fn list(&self) -> ListRequestBuilder<A> {
                ListRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    error_recovery: None,
                    feature_label: None,
                    mutation_precondition: None,
                    open_drive: None,
                    reason: None,
                    sync_type: None,
                }
            }
            #[doc = "Updates a backup's metadata."]
            pub fn patch(
                &self,
                request: crate::schemas::Backup,
                backup_id: impl Into<String>,
            ) -> PatchRequestBuilder<A> {
                PatchRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    request,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    backup_id: backup_id.into(),
                    error_recovery: None,
                    feature_label: None,
                    mutation_precondition: None,
                    open_drive: None,
                    reason: None,
                    sync_type: None,
                }
            }
            #[doc = "Starts extracting a backup."]
            pub fn start_extraction(
                &self,
                backup_id: impl Into<String>,
                target_folder_id: impl Into<String>,
            ) -> StartExtractionRequestBuilder<A> {
                StartExtractionRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    backup_id: backup_id.into(),
                    target_folder_id: target_folder_id.into(),
                    auth_token: None,
                    error_recovery: None,
                    feature_label: None,
                    mutation_precondition: None,
                    open_drive: None,
                    reason: None,
                    sync_type: None,
                }
            }
            #[doc = "Stops extraction of a backup."]
            pub fn stop_extraction(
                &self,
                backup_id: impl Into<String>,
            ) -> StopExtractionRequestBuilder<A> {
                StopExtractionRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    backup_id: backup_id.into(),
                    error_recovery: None,
                    feature_label: None,
                    mutation_precondition: None,
                    open_drive: None,
                    reason: None,
                    sync_type: None,
                }
            }
        }
        #[derive(Debug, Clone)]
        pub struct DeleteRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            backup_id: String,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            reason: Option<String>,
            sync_type: Option<i32>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> DeleteRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            pub fn execute(self) -> Result<(), Box<dyn ::std::error::Error>> {
                let req = self._request(&self._path());
                req.send()?.error_for_status()?;
                Ok(())
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("backups/");
                {
                    let var_as_str = &self.backup_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::DELETE, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct GetRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            backup_id: String,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            reason: Option<String>,
            sync_type: Option<i32>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> GetRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::Backup, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::Backup, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("backups/");
                {
                    let var_as_str = &self.backup_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::GET, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct ListRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            reason: Option<String>,
            sync_type: Option<i32>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> ListRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::BackupList, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::BackupList, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("backups");
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::GET, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct PatchRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            request: crate::schemas::Backup,
            backup_id: String,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            reason: Option<String>,
            sync_type: Option<i32>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> PatchRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::Backup, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::Backup, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                let req = req.json(&self.request);
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("backups/");
                {
                    let var_as_str = &self.backup_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::PATCH, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct StartExtractionRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            backup_id: String,
            target_folder_id: String,
            auth_token: Option<String>,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            reason: Option<String>,
            sync_type: Option<i32>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> StartExtractionRequestBuilder<'a, A> {
            #[doc = "A signed token that includes the user ID and a timestamp. Used to verify that a web user completed the reauth flow."]
            pub fn auth_token(mut self, value: impl Into<String>) -> Self {
                self.auth_token = Some(value.into());
                self
            }
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            pub fn execute(self) -> Result<(), Box<dyn ::std::error::Error>> {
                let req = self._request(&self._path());
                req.send()?.error_for_status()?;
                Ok(())
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("backups/");
                {
                    let var_as_str = &self.backup_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/startExtraction");
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::POST, path);
                let req = req.query(&[("targetFolderId", &self.target_folder_id)]);
                let req = req.query(&[("authToken", &self.auth_token)]);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct StopExtractionRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            backup_id: String,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            reason: Option<String>,
            sync_type: Option<i32>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> StopExtractionRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            pub fn execute(self) -> Result<(), Box<dyn ::std::error::Error>> {
                let req = self._request(&self._path());
                req.send()?.error_for_status()?;
                Ok(())
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("backups/");
                {
                    let var_as_str = &self.backup_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/stopExtraction");
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::POST, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
    }
    pub mod changes {
        pub mod params {
            #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
            pub enum ListAppDataFilter {
                #[doc = "Specifies that the query should return App Data and non-App Data files."]
                AllFiles,
                #[doc = "Specifies that the query should not return App Data files."]
                NoAppData,
                #[doc = "Specifies that the query should only return App Data files."]
                OnlyAppData,
            }
            impl ListAppDataFilter {
                pub fn as_str(self) -> &'static str {
                    match self {
                        ListAppDataFilter::AllFiles => "ALL_FILES",
                        ListAppDataFilter::NoAppData => "NO_APP_DATA",
                        ListAppDataFilter::OnlyAppData => "ONLY_APP_DATA",
                    }
                }
            }
            impl ::std::fmt::Display for ListAppDataFilter {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    f.write_str(self.as_str())
                }
            }
            impl ::serde::Serialize for ListAppDataFilter {
                fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
                where
                    S: ::serde::ser::Serializer,
                {
                    serializer.serialize_str(self.as_str())
                }
            }
            impl<'de> ::serde::Deserialize<'de> for ListAppDataFilter {
                fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
                where
                    D: ::serde::de::Deserializer<'de>,
                {
                    let value: &'de str = <&str>::deserialize(deserializer)?;
                    Ok(match value {
                        "ALL_FILES" => ListAppDataFilter::AllFiles,
                        "NO_APP_DATA" => ListAppDataFilter::NoAppData,
                        "ONLY_APP_DATA" => ListAppDataFilter::OnlyAppData,
                        _ => {
                            return Err(::serde::de::Error::custom(format!(
                                "invalid enum for #name: {}",
                                value
                            )))
                        }
                    })
                }
            }
            impl ::field_selector::FieldSelector for ListAppDataFilter {
                fn field_selector_with_ident(ident: &str, selector: &mut String) {
                    match selector.chars().rev().nth(0) {
                        Some(',') | None => {}
                        _ => selector.push_str(","),
                    }
                    selector.push_str(ident);
                }
            }
            #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
            pub enum WatchAppDataFilter {
                #[doc = "Specifies that the query should return App Data and non-App Data files."]
                AllFiles,
                #[doc = "Specifies that the query should not return App Data files."]
                NoAppData,
                #[doc = "Specifies that the query should only return App Data files."]
                OnlyAppData,
            }
            impl WatchAppDataFilter {
                pub fn as_str(self) -> &'static str {
                    match self {
                        WatchAppDataFilter::AllFiles => "ALL_FILES",
                        WatchAppDataFilter::NoAppData => "NO_APP_DATA",
                        WatchAppDataFilter::OnlyAppData => "ONLY_APP_DATA",
                    }
                }
            }
            impl ::std::fmt::Display for WatchAppDataFilter {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    f.write_str(self.as_str())
                }
            }
            impl ::serde::Serialize for WatchAppDataFilter {
                fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
                where
                    S: ::serde::ser::Serializer,
                {
                    serializer.serialize_str(self.as_str())
                }
            }
            impl<'de> ::serde::Deserialize<'de> for WatchAppDataFilter {
                fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
                where
                    D: ::serde::de::Deserializer<'de>,
                {
                    let value: &'de str = <&str>::deserialize(deserializer)?;
                    Ok(match value {
                        "ALL_FILES" => WatchAppDataFilter::AllFiles,
                        "NO_APP_DATA" => WatchAppDataFilter::NoAppData,
                        "ONLY_APP_DATA" => WatchAppDataFilter::OnlyAppData,
                        _ => {
                            return Err(::serde::de::Error::custom(format!(
                                "invalid enum for #name: {}",
                                value
                            )))
                        }
                    })
                }
            }
            impl ::field_selector::FieldSelector for WatchAppDataFilter {
                fn field_selector_with_ident(ident: &str, selector: &mut String) {
                    match selector.chars().rev().nth(0) {
                        Some(',') | None => {}
                        _ => selector.push_str(","),
                    }
                    selector.push_str(ident);
                }
            }
        }
        pub struct ChangesActions<'a, A> {
            pub(crate) reqwest: &'a reqwest::Client,
            pub(crate) auth: &'a std::sync::Mutex<A>,
        }
        impl<'a, A: yup_oauth2::GetToken> ChangesActions<'a, A> {
            #[doc = "Deprecated - Use changes.getStartPageToken and changes.list to retrieve recent changes."]
            pub fn get(&self, change_id: impl Into<String>) -> GetRequestBuilder<A> {
                GetRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    change_id: change_id.into(),
                    all_properties: None,
                    drive_id: None,
                    error_recovery: None,
                    feature_label: None,
                    include_permissions_for_view: None,
                    mutation_precondition: None,
                    open_drive: None,
                    reason: None,
                    supports_all_drives: None,
                    supports_team_drives: None,
                    sync_type: None,
                    team_drive_id: None,
                    use_legacy_domain_permission_behavior: None,
                }
            }
            #[doc = "Returns the estimated number of change entries that a client could expect by performing a similar changes.list request."]
            pub fn get_remaining_count(
                &self,
                page_token: impl Into<String>,
            ) -> GetRemainingCountRequestBuilder<A> {
                GetRemainingCountRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    page_token: page_token.into(),
                    drive_id: None,
                    filters: None,
                    include_embedded_items: None,
                    include_items_from_all_drives: None,
                    include_subscribed: None,
                    include_team_drive_items: None,
                    max_results: None,
                    spaces: None,
                    supports_all_drives: None,
                    supports_team_drives: None,
                    team_drive_id: None,
                }
            }
            #[doc = "Gets the starting pageToken for listing future changes."]
            pub fn get_start_page_token(&self) -> GetStartPageTokenRequestBuilder<A> {
                GetStartPageTokenRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    drive_id: None,
                    supports_all_drives: None,
                    supports_team_drives: None,
                    team_drive_id: None,
                }
            }
            #[doc = "Lists the changes for a user or shared drive."]
            pub fn list(&self) -> ListRequestBuilder<A> {
                ListRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    all_properties: None,
                    app_data_filter: None,
                    drive_id: None,
                    error_recovery: None,
                    feature_label: None,
                    file_scope_app_ids: None,
                    filters: None,
                    include_corpus_removals: None,
                    include_deleted: None,
                    include_embedded_items: None,
                    include_items_from_all_drives: None,
                    include_metadata_for_categories: None,
                    include_permissions_for_view: None,
                    include_subscribed: None,
                    include_team_drive_items: None,
                    max_results: None,
                    mutation_precondition: None,
                    open_drive: None,
                    page_token: None,
                    reason: None,
                    reject_inefficient_requests: None,
                    return_efficiency_info: None,
                    sources: None,
                    spaces: None,
                    start_change_id: None,
                    supports_all_drives: None,
                    supports_team_drives: None,
                    sync_type: None,
                    team_drive_id: None,
                    use_legacy_domain_permission_behavior: None,
                }
            }
            #[doc = "Subscribe to changes for a user."]
            pub fn watch(&self, request: crate::schemas::Channel) -> WatchRequestBuilder<A> {
                WatchRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    request,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    all_properties: None,
                    app_data_filter: None,
                    drive_id: None,
                    error_recovery: None,
                    feature_label: None,
                    file_scope_app_ids: None,
                    filters: None,
                    include_corpus_removals: None,
                    include_deleted: None,
                    include_embedded_items: None,
                    include_items_from_all_drives: None,
                    include_metadata_for_categories: None,
                    include_permissions_for_view: None,
                    include_subscribed: None,
                    include_team_drive_items: None,
                    max_results: None,
                    mutation_precondition: None,
                    open_drive: None,
                    page_token: None,
                    reason: None,
                    reject_inefficient_requests: None,
                    return_efficiency_info: None,
                    sources: None,
                    spaces: None,
                    start_change_id: None,
                    supports_all_drives: None,
                    supports_team_drives: None,
                    sync_type: None,
                    team_drive_id: None,
                    use_legacy_domain_permission_behavior: None,
                }
            }
        }
        #[derive(Debug, Clone)]
        pub struct GetRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            change_id: String,
            all_properties: Option<bool>,
            drive_id: Option<String>,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            include_permissions_for_view: Option<String>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            reason: Option<String>,
            supports_all_drives: Option<bool>,
            supports_team_drives: Option<bool>,
            sync_type: Option<i32>,
            team_drive_id: Option<String>,
            use_legacy_domain_permission_behavior: Option<bool>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> GetRequestBuilder<'a, A> {
            #[doc = "Whether to retrieve all properties, not just those visible to the app."]
            pub fn all_properties(mut self, value: bool) -> Self {
                self.all_properties = Some(value);
                self
            }
            #[doc = "The shared drive from which the change will be returned."]
            pub fn drive_id(mut self, value: impl Into<String>) -> Self {
                self.drive_id = Some(value.into());
                self
            }
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "Specifies which additional view's permissions to include in the response. Only 'published' is supported."]
            pub fn include_permissions_for_view(mut self, value: impl Into<String>) -> Self {
                self.include_permissions_for_view = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Deprecated - Whether the requesting application supports both My Drives and shared drives. This parameter will only be effective until June 1, 2020. Afterwards all applications are assumed to support shared drives."]
            pub fn supports_all_drives(mut self, value: bool) -> Self {
                self.supports_all_drives = Some(value);
                self
            }
            #[doc = "Deprecated use supportsAllDrives instead."]
            pub fn supports_team_drives(mut self, value: bool) -> Self {
                self.supports_team_drives = Some(value);
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "Deprecated use driveId instead."]
            pub fn team_drive_id(mut self, value: impl Into<String>) -> Self {
                self.team_drive_id = Some(value.into());
                self
            }
            #[doc = "If true, Permissions with type Audience are represented with Domain type."]
            pub fn use_legacy_domain_permission_behavior(mut self, value: bool) -> Self {
                self.use_legacy_domain_permission_behavior = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::Change, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::Change, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("changes/");
                {
                    let var_as_str = &self.change_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::GET, path);
                let req = req.query(&[("allProperties", &self.all_properties)]);
                let req = req.query(&[("driveId", &self.drive_id)]);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[(
                    "includePermissionsForView",
                    &self.include_permissions_for_view,
                )]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("supportsAllDrives", &self.supports_all_drives)]);
                let req = req.query(&[("supportsTeamDrives", &self.supports_team_drives)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("teamDriveId", &self.team_drive_id)]);
                let req = req.query(&[(
                    "useLegacyDomainPermissionBehavior",
                    &self.use_legacy_domain_permission_behavior,
                )]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive.apps.readonly"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct GetRemainingCountRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            page_token: String,
            drive_id: Option<String>,
            filters: Option<String>,
            include_embedded_items: Option<bool>,
            include_items_from_all_drives: Option<bool>,
            include_subscribed: Option<bool>,
            include_team_drive_items: Option<bool>,
            max_results: Option<i32>,
            spaces: Option<String>,
            supports_all_drives: Option<bool>,
            supports_team_drives: Option<bool>,
            team_drive_id: Option<String>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> GetRemainingCountRequestBuilder<'a, A> {
            #[doc = "The shared drive from which changes will be counted. If specified the change IDs will be reflective of the shared drive; use the combined drive ID and change ID as an identifier."]
            pub fn drive_id(mut self, value: impl Into<String>) -> Self {
                self.drive_id = Some(value.into());
                self
            }
            #[doc = "This field is ignored."]
            pub fn filters(mut self, value: impl Into<String>) -> Self {
                self.filters = Some(value.into());
                self
            }
            #[doc = "Whether changes to package embedded items should be counted in results."]
            pub fn include_embedded_items(mut self, value: bool) -> Self {
                self.include_embedded_items = Some(value);
                self
            }
            #[doc = "Deprecated - Whether shared drive items should be counted in the results. This parameter will only be effective until June 1, 2020. Afterwards shared drive items will be counted in the results."]
            pub fn include_items_from_all_drives(mut self, value: bool) -> Self {
                self.include_items_from_all_drives = Some(value);
                self
            }
            #[doc = "Whether to count changes outside the My Drive hierarchy. When set to false, changes to files such as those in the Application Data folder or shared files which have not been added to My Drive will be omitted from the count."]
            pub fn include_subscribed(mut self, value: bool) -> Self {
                self.include_subscribed = Some(value);
                self
            }
            #[doc = "Deprecated use includeItemsFromAllDrives instead."]
            pub fn include_team_drive_items(mut self, value: bool) -> Self {
                self.include_team_drive_items = Some(value);
                self
            }
            #[doc = "Maximum number of changes to count per page."]
            pub fn max_results(mut self, value: i32) -> Self {
                self.max_results = Some(value);
                self
            }
            #[doc = "A comma-separated list of spaces to query. Supported values are 'drive', 'appContent', 'appDataFolder', 'photos' and 'androidBackup'."]
            pub fn spaces(mut self, value: impl Into<String>) -> Self {
                self.spaces = Some(value.into());
                self
            }
            #[doc = "Deprecated - Whether the requesting application supports both My Drives and shared drives. This parameter will only be effective until June 1, 2020. Afterwards all applications are assumed to support shared drives."]
            pub fn supports_all_drives(mut self, value: bool) -> Self {
                self.supports_all_drives = Some(value);
                self
            }
            #[doc = "Deprecated use supportsAllDrives instead."]
            pub fn supports_team_drives(mut self, value: bool) -> Self {
                self.supports_team_drives = Some(value);
                self
            }
            #[doc = "Deprecated use driveId instead."]
            pub fn team_drive_id(mut self, value: impl Into<String>) -> Self {
                self.team_drive_id = Some(value.into());
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            pub fn iter<T>(mut self) -> crate::iter::PageIter<Self, T>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let mut fields = T::field_selector();
                if !fields.is_empty() {
                    match fields.chars().rev().nth(0) {
                        Some(',') | None => {}
                        _ => fields.push_str(","),
                    }
                    fields.push_str("nextPageToken");
                    self.fields = Some(fields);
                }
                crate::iter::PageIter::new(self)
            }
            pub fn iter_standard(
                self,
            ) -> crate::iter::PageIter<Self, crate::schemas::RemainingCount> {
                crate::iter::PageIter::new(self)
            }
            pub fn iter_debug(
                mut self,
            ) -> crate::iter::PageIter<Self, crate::schemas::RemainingCount> {
                self.fields = Some("*".to_owned());
                crate::iter::PageIter::new(self)
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::RemainingCount, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::RemainingCount, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("changes/getRemainingCount");
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::GET, path);
                let req = req.query(&[("pageToken", &self.page_token)]);
                let req = req.query(&[("driveId", &self.drive_id)]);
                let req = req.query(&[("filters", &self.filters)]);
                let req = req.query(&[("includeEmbeddedItems", &self.include_embedded_items)]);
                let req = req.query(&[(
                    "includeItemsFromAllDrives",
                    &self.include_items_from_all_drives,
                )]);
                let req = req.query(&[("includeSubscribed", &self.include_subscribed)]);
                let req = req.query(&[("includeTeamDriveItems", &self.include_team_drive_items)]);
                let req = req.query(&[("maxResults", &self.max_results)]);
                let req = req.query(&[("spaces", &self.spaces)]);
                let req = req.query(&[("supportsAllDrives", &self.supports_all_drives)]);
                let req = req.query(&[("supportsTeamDrives", &self.supports_team_drives)]);
                let req = req.query(&[("teamDriveId", &self.team_drive_id)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive.apps.readonly"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        impl<'a, A: yup_oauth2::GetToken> crate::iter::IterableMethod
            for GetRemainingCountRequestBuilder<'a, A>
        {
            fn set_page_token(&mut self, value: String) {
                self.page_token = value.into();
            }
            fn execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                self._execute()
            }
        }
        #[derive(Debug, Clone)]
        pub struct GetStartPageTokenRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            drive_id: Option<String>,
            supports_all_drives: Option<bool>,
            supports_team_drives: Option<bool>,
            team_drive_id: Option<String>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> GetStartPageTokenRequestBuilder<'a, A> {
            #[doc = "The ID of the shared drive for which the starting pageToken for listing future changes from that shared drive will be returned."]
            pub fn drive_id(mut self, value: impl Into<String>) -> Self {
                self.drive_id = Some(value.into());
                self
            }
            #[doc = "Deprecated - Whether the requesting application supports both My Drives and shared drives. This parameter will only be effective until June 1, 2020. Afterwards all applications are assumed to support shared drives."]
            pub fn supports_all_drives(mut self, value: bool) -> Self {
                self.supports_all_drives = Some(value);
                self
            }
            #[doc = "Deprecated use supportsAllDrives instead."]
            pub fn supports_team_drives(mut self, value: bool) -> Self {
                self.supports_team_drives = Some(value);
                self
            }
            #[doc = "Deprecated use driveId instead."]
            pub fn team_drive_id(mut self, value: impl Into<String>) -> Self {
                self.team_drive_id = Some(value.into());
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::StartPageToken, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::StartPageToken, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("changes/startPageToken");
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::GET, path);
                let req = req.query(&[("driveId", &self.drive_id)]);
                let req = req.query(&[("supportsAllDrives", &self.supports_all_drives)]);
                let req = req.query(&[("supportsTeamDrives", &self.supports_team_drives)]);
                let req = req.query(&[("teamDriveId", &self.team_drive_id)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive.apps.readonly"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct ListRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            all_properties: Option<bool>,
            app_data_filter: Option<crate::resources::changes::params::ListAppDataFilter>,
            drive_id: Option<String>,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            file_scope_app_ids: Option<String>,
            filters: Option<String>,
            include_corpus_removals: Option<bool>,
            include_deleted: Option<bool>,
            include_embedded_items: Option<bool>,
            include_items_from_all_drives: Option<bool>,
            include_metadata_for_categories: Option<String>,
            include_permissions_for_view: Option<String>,
            include_subscribed: Option<bool>,
            include_team_drive_items: Option<bool>,
            max_results: Option<i32>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            page_token: Option<String>,
            reason: Option<String>,
            reject_inefficient_requests: Option<bool>,
            return_efficiency_info: Option<bool>,
            sources: Option<String>,
            spaces: Option<String>,
            start_change_id: Option<i64>,
            supports_all_drives: Option<bool>,
            supports_team_drives: Option<bool>,
            sync_type: Option<i32>,
            team_drive_id: Option<String>,
            use_legacy_domain_permission_behavior: Option<bool>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> ListRequestBuilder<'a, A> {
            #[doc = "Whether to retrieve all properties, not just those visible to the app."]
            pub fn all_properties(mut self, value: bool) -> Self {
                self.all_properties = Some(value);
                self
            }
            #[doc = "Deprecated: use 'spaces' instead. Specifies whether to return App Data, non-App Data, or both in query results."]
            pub fn app_data_filter(
                mut self,
                value: crate::resources::changes::params::ListAppDataFilter,
            ) -> Self {
                self.app_data_filter = Some(value);
                self
            }
            #[doc = "The shared drive from which changes will be returned. If specified the change IDs will be reflective of the shared drive; use the combined drive ID and change ID as an identifier."]
            pub fn drive_id(mut self, value: impl Into<String>) -> Self {
                self.drive_id = Some(value.into());
                self
            }
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "A comma separated list of app IDs. If set, the list will also include files inside the app data folder that could be opened with any of the given apps with drive.appdata scope. Requires the ALL_APPDATA scope."]
            pub fn file_scope_app_ids(mut self, value: impl Into<String>) -> Self {
                self.file_scope_app_ids = Some(value.into());
                self
            }
            #[doc = "This field is ignored."]
            pub fn filters(mut self, value: impl Into<String>) -> Self {
                self.filters = Some(value.into());
                self
            }
            #[doc = "Whether changes should include the file resource if the file is still accessible by the user at the time of the request, even when a file was removed from the list of changes and there will be no further change entries for this file."]
            pub fn include_corpus_removals(mut self, value: bool) -> Self {
                self.include_corpus_removals = Some(value);
                self
            }
            #[doc = "Whether to include changes indicating that items have been removed from the list of changes, for example by deletion or loss of access."]
            pub fn include_deleted(mut self, value: bool) -> Self {
                self.include_deleted = Some(value);
                self
            }
            #[doc = "Whether changes to package embedded items should be included in results."]
            pub fn include_embedded_items(mut self, value: bool) -> Self {
                self.include_embedded_items = Some(value);
                self
            }
            #[doc = "Deprecated - Whether both My Drive and shared drive items should be included in results. This parameter will only be effective until June 1, 2020. Afterwards shared drive items will be included in the results."]
            pub fn include_items_from_all_drives(mut self, value: bool) -> Self {
                self.include_items_from_all_drives = Some(value);
                self
            }
            #[doc = "A comma-separated list of names of Categories to include in the response."]
            pub fn include_metadata_for_categories(mut self, value: impl Into<String>) -> Self {
                self.include_metadata_for_categories = Some(value.into());
                self
            }
            #[doc = "Specifies which additional view's permissions to include in the response. Only 'published' is supported."]
            pub fn include_permissions_for_view(mut self, value: impl Into<String>) -> Self {
                self.include_permissions_for_view = Some(value.into());
                self
            }
            #[doc = "Whether to include changes outside the My Drive hierarchy in the result. When set to false, changes to files such as those in the Application Data folder or shared files which have not been added to My Drive will be omitted from the result."]
            pub fn include_subscribed(mut self, value: bool) -> Self {
                self.include_subscribed = Some(value);
                self
            }
            #[doc = "Deprecated use includeItemsFromAllDrives instead."]
            pub fn include_team_drive_items(mut self, value: bool) -> Self {
                self.include_team_drive_items = Some(value);
                self
            }
            #[doc = "Maximum number of changes to return."]
            pub fn max_results(mut self, value: i32) -> Self {
                self.max_results = Some(value);
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The token for continuing a previous list request on the next page. This should be set to the value of 'nextPageToken' from the previous response or to the response from the getStartPageToken method."]
            pub fn page_token(mut self, value: impl Into<String>) -> Self {
                self.page_token = Some(value.into());
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request should be rejected if it would generate an inefficient query."]
            pub fn reject_inefficient_requests(mut self, value: bool) -> Self {
                self.reject_inefficient_requests = Some(value);
                self
            }
            #[doc = "Whether the request should return efficiency info."]
            pub fn return_efficiency_info(mut self, value: bool) -> Self {
                self.return_efficiency_info = Some(value);
                self
            }
            #[doc = "Deprecated: use 'spaces' instead. A comma-separated list of sources to query. Supported values are 'GOOGLE_PHOTOS' and 'ANDROID_BACKUP'."]
            pub fn sources(mut self, value: impl Into<String>) -> Self {
                self.sources = Some(value.into());
                self
            }
            #[doc = "A comma-separated list of spaces to query. Supported values are 'drive', 'appContent', 'appDataFolder', 'photos' and 'androidBackup'."]
            pub fn spaces(mut self, value: impl Into<String>) -> Self {
                self.spaces = Some(value.into());
                self
            }
            #[doc = "Deprecated - use pageToken instead."]
            pub fn start_change_id(mut self, value: i64) -> Self {
                self.start_change_id = Some(value);
                self
            }
            #[doc = "Deprecated - Whether the requesting application supports both My Drives and shared drives. This parameter will only be effective until June 1, 2020. Afterwards all applications are assumed to support shared drives."]
            pub fn supports_all_drives(mut self, value: bool) -> Self {
                self.supports_all_drives = Some(value);
                self
            }
            #[doc = "Deprecated use supportsAllDrives instead."]
            pub fn supports_team_drives(mut self, value: bool) -> Self {
                self.supports_team_drives = Some(value);
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "Deprecated use driveId instead."]
            pub fn team_drive_id(mut self, value: impl Into<String>) -> Self {
                self.team_drive_id = Some(value.into());
                self
            }
            #[doc = "If true, Permissions with type Audience are represented with Domain type."]
            pub fn use_legacy_domain_permission_behavior(mut self, value: bool) -> Self {
                self.use_legacy_domain_permission_behavior = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Return an iterator that iterates over all `#prop_ident`. The"]
            #[doc = r" items yielded by the iterator are chosen by the caller of this"]
            #[doc = r" method and must implement `Deserialize` and `FieldSelector`. The"]
            #[doc = r" populated fields in the yielded items will be determined by the"]
            #[doc = r" `FieldSelector` implementation."]
            pub fn iter_items<T>(mut self) -> crate::iter::PageItemIter<Self, T>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let mut fields = concat!("nextPageToken,", "items").to_owned();
                let items_fields = T::field_selector();
                if !items_fields.is_empty() {
                    fields.push_str("(");
                    fields.push_str(&items_fields);
                    fields.push_str(")");
                }
                self.fields = Some(fields);
                crate::iter::PageItemIter::new(self, "items")
            }
            #[doc = r" Return an iterator that iterates over all `#prop_ident`. The"]
            #[doc = r" items yielded by the iterator are `#items_type`. The populated"]
            #[doc = r" fields in `#items_type` will be the default fields populated by"]
            #[doc = r" the server."]
            pub fn iter_items_standard(
                mut self,
            ) -> crate::iter::PageItemIter<Self, crate::schemas::Change> {
                self.fields = Some(concat!("nextPageToken,", "items").to_owned());
                crate::iter::PageItemIter::new(self, "items")
            }
            #[doc = r" Return an iterator that iterates over all `#prop_ident`. The"]
            #[doc = r" items yielded by the iterator are `#items_type`. The populated"]
            #[doc = r" fields in `#items_type` will be all fields available. This should"]
            #[doc = r" primarily be used during developement and debugging as fetching"]
            #[doc = r" all fields can be expensive both in bandwidth and server"]
            #[doc = r" resources."]
            pub fn iter_items_debug(
                mut self,
            ) -> crate::iter::PageItemIter<Self, crate::schemas::Change> {
                self.fields = Some(concat!("nextPageToken,", "items", "(*)").to_owned());
                crate::iter::PageItemIter::new(self, "items")
            }
            pub fn iter<T>(mut self) -> crate::iter::PageIter<Self, T>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let mut fields = T::field_selector();
                if !fields.is_empty() {
                    match fields.chars().rev().nth(0) {
                        Some(',') | None => {}
                        _ => fields.push_str(","),
                    }
                    fields.push_str("nextPageToken");
                    self.fields = Some(fields);
                }
                crate::iter::PageIter::new(self)
            }
            pub fn iter_standard(self) -> crate::iter::PageIter<Self, crate::schemas::ChangeList> {
                crate::iter::PageIter::new(self)
            }
            pub fn iter_debug(mut self) -> crate::iter::PageIter<Self, crate::schemas::ChangeList> {
                self.fields = Some("*".to_owned());
                crate::iter::PageIter::new(self)
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::ChangeList, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::ChangeList, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("changes");
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::GET, path);
                let req = req.query(&[("allProperties", &self.all_properties)]);
                let req = req.query(&[("appDataFilter", &self.app_data_filter)]);
                let req = req.query(&[("driveId", &self.drive_id)]);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("fileScopeAppIds", &self.file_scope_app_ids)]);
                let req = req.query(&[("filters", &self.filters)]);
                let req = req.query(&[("includeCorpusRemovals", &self.include_corpus_removals)]);
                let req = req.query(&[("includeDeleted", &self.include_deleted)]);
                let req = req.query(&[("includeEmbeddedItems", &self.include_embedded_items)]);
                let req = req.query(&[(
                    "includeItemsFromAllDrives",
                    &self.include_items_from_all_drives,
                )]);
                let req = req.query(&[(
                    "includeMetadataForCategories",
                    &self.include_metadata_for_categories,
                )]);
                let req = req.query(&[(
                    "includePermissionsForView",
                    &self.include_permissions_for_view,
                )]);
                let req = req.query(&[("includeSubscribed", &self.include_subscribed)]);
                let req = req.query(&[("includeTeamDriveItems", &self.include_team_drive_items)]);
                let req = req.query(&[("maxResults", &self.max_results)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("pageToken", &self.page_token)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[(
                    "rejectInefficientRequests",
                    &self.reject_inefficient_requests,
                )]);
                let req = req.query(&[("returnEfficiencyInfo", &self.return_efficiency_info)]);
                let req = req.query(&[("sources", &self.sources)]);
                let req = req.query(&[("spaces", &self.spaces)]);
                let req = req.query(&[("startChangeId", &self.start_change_id)]);
                let req = req.query(&[("supportsAllDrives", &self.supports_all_drives)]);
                let req = req.query(&[("supportsTeamDrives", &self.supports_team_drives)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("teamDriveId", &self.team_drive_id)]);
                let req = req.query(&[(
                    "useLegacyDomainPermissionBehavior",
                    &self.use_legacy_domain_permission_behavior,
                )]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive.apps.readonly"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        impl<'a, A: yup_oauth2::GetToken> crate::iter::IterableMethod for ListRequestBuilder<'a, A> {
            fn set_page_token(&mut self, value: String) {
                self.page_token = value.into();
            }
            fn execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                self._execute()
            }
        }
        #[derive(Debug, Clone)]
        pub struct WatchRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            request: crate::schemas::Channel,
            all_properties: Option<bool>,
            app_data_filter: Option<crate::resources::changes::params::WatchAppDataFilter>,
            drive_id: Option<String>,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            file_scope_app_ids: Option<String>,
            filters: Option<String>,
            include_corpus_removals: Option<bool>,
            include_deleted: Option<bool>,
            include_embedded_items: Option<bool>,
            include_items_from_all_drives: Option<bool>,
            include_metadata_for_categories: Option<String>,
            include_permissions_for_view: Option<String>,
            include_subscribed: Option<bool>,
            include_team_drive_items: Option<bool>,
            max_results: Option<i32>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            page_token: Option<String>,
            reason: Option<String>,
            reject_inefficient_requests: Option<bool>,
            return_efficiency_info: Option<bool>,
            sources: Option<String>,
            spaces: Option<String>,
            start_change_id: Option<i64>,
            supports_all_drives: Option<bool>,
            supports_team_drives: Option<bool>,
            sync_type: Option<i32>,
            team_drive_id: Option<String>,
            use_legacy_domain_permission_behavior: Option<bool>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> WatchRequestBuilder<'a, A> {
            #[doc = "Whether to retrieve all properties, not just those visible to the app."]
            pub fn all_properties(mut self, value: bool) -> Self {
                self.all_properties = Some(value);
                self
            }
            #[doc = "Deprecated: use 'spaces' instead. Specifies whether to return App Data, non-App Data, or both in query results."]
            pub fn app_data_filter(
                mut self,
                value: crate::resources::changes::params::WatchAppDataFilter,
            ) -> Self {
                self.app_data_filter = Some(value);
                self
            }
            #[doc = "The shared drive from which changes will be returned. If specified the change IDs will be reflective of the shared drive; use the combined drive ID and change ID as an identifier."]
            pub fn drive_id(mut self, value: impl Into<String>) -> Self {
                self.drive_id = Some(value.into());
                self
            }
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "A comma separated list of app IDs. If set, the list will also include files inside the app data folder that could be opened with any of the given apps with drive.appdata scope. Requires the ALL_APPDATA scope."]
            pub fn file_scope_app_ids(mut self, value: impl Into<String>) -> Self {
                self.file_scope_app_ids = Some(value.into());
                self
            }
            #[doc = "This field is ignored."]
            pub fn filters(mut self, value: impl Into<String>) -> Self {
                self.filters = Some(value.into());
                self
            }
            #[doc = "Whether changes should include the file resource if the file is still accessible by the user at the time of the request, even when a file was removed from the list of changes and there will be no further change entries for this file."]
            pub fn include_corpus_removals(mut self, value: bool) -> Self {
                self.include_corpus_removals = Some(value);
                self
            }
            #[doc = "Whether to include changes indicating that items have been removed from the list of changes, for example by deletion or loss of access."]
            pub fn include_deleted(mut self, value: bool) -> Self {
                self.include_deleted = Some(value);
                self
            }
            #[doc = "Whether changes to package embedded items should be included in results."]
            pub fn include_embedded_items(mut self, value: bool) -> Self {
                self.include_embedded_items = Some(value);
                self
            }
            #[doc = "Deprecated - Whether both My Drive and shared drive items should be included in results. This parameter will only be effective until June 1, 2020. Afterwards shared drive items will be included in the results."]
            pub fn include_items_from_all_drives(mut self, value: bool) -> Self {
                self.include_items_from_all_drives = Some(value);
                self
            }
            #[doc = "A comma-separated list of names of Categories to include in the response."]
            pub fn include_metadata_for_categories(mut self, value: impl Into<String>) -> Self {
                self.include_metadata_for_categories = Some(value.into());
                self
            }
            #[doc = "Specifies which additional view's permissions to include in the response. Only 'published' is supported."]
            pub fn include_permissions_for_view(mut self, value: impl Into<String>) -> Self {
                self.include_permissions_for_view = Some(value.into());
                self
            }
            #[doc = "Whether to include changes outside the My Drive hierarchy in the result. When set to false, changes to files such as those in the Application Data folder or shared files which have not been added to My Drive will be omitted from the result."]
            pub fn include_subscribed(mut self, value: bool) -> Self {
                self.include_subscribed = Some(value);
                self
            }
            #[doc = "Deprecated use includeItemsFromAllDrives instead."]
            pub fn include_team_drive_items(mut self, value: bool) -> Self {
                self.include_team_drive_items = Some(value);
                self
            }
            #[doc = "Maximum number of changes to return."]
            pub fn max_results(mut self, value: i32) -> Self {
                self.max_results = Some(value);
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The token for continuing a previous list request on the next page. This should be set to the value of 'nextPageToken' from the previous response or to the response from the getStartPageToken method."]
            pub fn page_token(mut self, value: impl Into<String>) -> Self {
                self.page_token = Some(value.into());
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request should be rejected if it would generate an inefficient query."]
            pub fn reject_inefficient_requests(mut self, value: bool) -> Self {
                self.reject_inefficient_requests = Some(value);
                self
            }
            #[doc = "Whether the request should return efficiency info."]
            pub fn return_efficiency_info(mut self, value: bool) -> Self {
                self.return_efficiency_info = Some(value);
                self
            }
            #[doc = "Deprecated: use 'spaces' instead. A comma-separated list of sources to query. Supported values are 'GOOGLE_PHOTOS' and 'ANDROID_BACKUP'."]
            pub fn sources(mut self, value: impl Into<String>) -> Self {
                self.sources = Some(value.into());
                self
            }
            #[doc = "A comma-separated list of spaces to query. Supported values are 'drive', 'appContent', 'appDataFolder', 'photos' and 'androidBackup'."]
            pub fn spaces(mut self, value: impl Into<String>) -> Self {
                self.spaces = Some(value.into());
                self
            }
            #[doc = "Deprecated - use pageToken instead."]
            pub fn start_change_id(mut self, value: i64) -> Self {
                self.start_change_id = Some(value);
                self
            }
            #[doc = "Deprecated - Whether the requesting application supports both My Drives and shared drives. This parameter will only be effective until June 1, 2020. Afterwards all applications are assumed to support shared drives."]
            pub fn supports_all_drives(mut self, value: bool) -> Self {
                self.supports_all_drives = Some(value);
                self
            }
            #[doc = "Deprecated use supportsAllDrives instead."]
            pub fn supports_team_drives(mut self, value: bool) -> Self {
                self.supports_team_drives = Some(value);
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "Deprecated use driveId instead."]
            pub fn team_drive_id(mut self, value: impl Into<String>) -> Self {
                self.team_drive_id = Some(value.into());
                self
            }
            #[doc = "If true, Permissions with type Audience are represented with Domain type."]
            pub fn use_legacy_domain_permission_behavior(mut self, value: bool) -> Self {
                self.use_legacy_domain_permission_behavior = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::Channel, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::Channel, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                let req = req.json(&self.request);
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("changes/watch");
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::POST, path);
                let req = req.query(&[("allProperties", &self.all_properties)]);
                let req = req.query(&[("appDataFilter", &self.app_data_filter)]);
                let req = req.query(&[("driveId", &self.drive_id)]);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("fileScopeAppIds", &self.file_scope_app_ids)]);
                let req = req.query(&[("filters", &self.filters)]);
                let req = req.query(&[("includeCorpusRemovals", &self.include_corpus_removals)]);
                let req = req.query(&[("includeDeleted", &self.include_deleted)]);
                let req = req.query(&[("includeEmbeddedItems", &self.include_embedded_items)]);
                let req = req.query(&[(
                    "includeItemsFromAllDrives",
                    &self.include_items_from_all_drives,
                )]);
                let req = req.query(&[(
                    "includeMetadataForCategories",
                    &self.include_metadata_for_categories,
                )]);
                let req = req.query(&[(
                    "includePermissionsForView",
                    &self.include_permissions_for_view,
                )]);
                let req = req.query(&[("includeSubscribed", &self.include_subscribed)]);
                let req = req.query(&[("includeTeamDriveItems", &self.include_team_drive_items)]);
                let req = req.query(&[("maxResults", &self.max_results)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("pageToken", &self.page_token)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[(
                    "rejectInefficientRequests",
                    &self.reject_inefficient_requests,
                )]);
                let req = req.query(&[("returnEfficiencyInfo", &self.return_efficiency_info)]);
                let req = req.query(&[("sources", &self.sources)]);
                let req = req.query(&[("spaces", &self.spaces)]);
                let req = req.query(&[("startChangeId", &self.start_change_id)]);
                let req = req.query(&[("supportsAllDrives", &self.supports_all_drives)]);
                let req = req.query(&[("supportsTeamDrives", &self.supports_team_drives)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("teamDriveId", &self.team_drive_id)]);
                let req = req.query(&[(
                    "useLegacyDomainPermissionBehavior",
                    &self.use_legacy_domain_permission_behavior,
                )]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
    }
    pub mod channels {
        pub mod params {}
        pub struct ChannelsActions<'a, A> {
            pub(crate) reqwest: &'a reqwest::Client,
            pub(crate) auth: &'a std::sync::Mutex<A>,
        }
        impl<'a, A: yup_oauth2::GetToken> ChannelsActions<'a, A> {
            #[doc = "Stop watching resources through this channel"]
            pub fn stop(&self, request: crate::schemas::Channel) -> StopRequestBuilder<A> {
                StopRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    request,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                }
            }
        }
        #[derive(Debug, Clone)]
        pub struct StopRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            request: crate::schemas::Channel,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> StopRequestBuilder<'a, A> {
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            pub fn execute(self) -> Result<(), Box<dyn ::std::error::Error>> {
                let req = self._request(&self._path());
                let req = req.json(&self.request);
                req.send()?.error_for_status()?;
                Ok(())
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("channels/stop");
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::POST, path);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/activity"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
    }
    pub mod children {
        pub mod params {
            #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
            pub enum ListSortBy {
                #[doc = "Sort by the createdDate field of the files. Reverse chronological by default."]
                CreationDate,
                #[doc = "Sort folders first then sort files by title."]
                FolderTitle,
                #[doc = "Sort folders first."]
                FoldersFirst,
                #[doc = "Sort by the modifiedDate field of the files. Reverse chronological by default."]
                LastModified,
                #[doc = "Sort by the modifiedByMeDate field of the files. Reverse chronological by default."]
                LastModifiedByMe,
                #[doc = "Sort by the lastViewedByMeDate field of the files. Reverse chronological by default."]
                LastViewedByMe,
                #[doc = "Sort by the quotaBytesUsed field of the files. In descending order by default."]
                QuotaUsed,
                #[doc = "Sort by max(createdDate, lastViewedByMeDate, modifiedByMeDate) of the files. Reverse chronological by default."]
                Recent,
                #[doc = "Sort by the relevance of the query results."]
                Relevance,
                #[doc = "Sort by the sharedWithMeDate field of the files. Reverse chronological by default."]
                SharedWithMeDate,
                #[doc = "Sort starred items first."]
                StarredFirst,
                #[doc = "Sort by the title field of the files."]
                Title,
            }
            impl ListSortBy {
                pub fn as_str(self) -> &'static str {
                    match self {
                        ListSortBy::CreationDate => "CREATION_DATE",
                        ListSortBy::FolderTitle => "FOLDER_TITLE",
                        ListSortBy::FoldersFirst => "FOLDERS_FIRST",
                        ListSortBy::LastModified => "LAST_MODIFIED",
                        ListSortBy::LastModifiedByMe => "LAST_MODIFIED_BY_ME",
                        ListSortBy::LastViewedByMe => "LAST_VIEWED_BY_ME",
                        ListSortBy::QuotaUsed => "QUOTA_USED",
                        ListSortBy::Recent => "RECENT",
                        ListSortBy::Relevance => "RELEVANCE",
                        ListSortBy::SharedWithMeDate => "SHARED_WITH_ME_DATE",
                        ListSortBy::StarredFirst => "STARRED_FIRST",
                        ListSortBy::Title => "TITLE",
                    }
                }
            }
            impl ::std::fmt::Display for ListSortBy {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    f.write_str(self.as_str())
                }
            }
            impl ::serde::Serialize for ListSortBy {
                fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
                where
                    S: ::serde::ser::Serializer,
                {
                    serializer.serialize_str(self.as_str())
                }
            }
            impl<'de> ::serde::Deserialize<'de> for ListSortBy {
                fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
                where
                    D: ::serde::de::Deserializer<'de>,
                {
                    let value: &'de str = <&str>::deserialize(deserializer)?;
                    Ok(match value {
                        "CREATION_DATE" => ListSortBy::CreationDate,
                        "FOLDER_TITLE" => ListSortBy::FolderTitle,
                        "FOLDERS_FIRST" => ListSortBy::FoldersFirst,
                        "LAST_MODIFIED" => ListSortBy::LastModified,
                        "LAST_MODIFIED_BY_ME" => ListSortBy::LastModifiedByMe,
                        "LAST_VIEWED_BY_ME" => ListSortBy::LastViewedByMe,
                        "QUOTA_USED" => ListSortBy::QuotaUsed,
                        "RECENT" => ListSortBy::Recent,
                        "RELEVANCE" => ListSortBy::Relevance,
                        "SHARED_WITH_ME_DATE" => ListSortBy::SharedWithMeDate,
                        "STARRED_FIRST" => ListSortBy::StarredFirst,
                        "TITLE" => ListSortBy::Title,
                        _ => {
                            return Err(::serde::de::Error::custom(format!(
                                "invalid enum for #name: {}",
                                value
                            )))
                        }
                    })
                }
            }
            impl ::field_selector::FieldSelector for ListSortBy {
                fn field_selector_with_ident(ident: &str, selector: &mut String) {
                    match selector.chars().rev().nth(0) {
                        Some(',') | None => {}
                        _ => selector.push_str(","),
                    }
                    selector.push_str(ident);
                }
            }
        }
        pub struct ChildrenActions<'a, A> {
            pub(crate) reqwest: &'a reqwest::Client,
            pub(crate) auth: &'a std::sync::Mutex<A>,
        }
        impl<'a, A: yup_oauth2::GetToken> ChildrenActions<'a, A> {
            #[doc = "Removes a child from a folder."]
            pub fn delete(
                &self,
                folder_id: impl Into<String>,
                child_id: impl Into<String>,
            ) -> DeleteRequestBuilder<A> {
                DeleteRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    folder_id: folder_id.into(),
                    child_id: child_id.into(),
                    error_recovery: None,
                    feature_label: None,
                    mutation_precondition: None,
                    open_drive: None,
                    reason: None,
                    sync_type: None,
                }
            }
            #[doc = "Gets a specific child reference."]
            pub fn get(
                &self,
                folder_id: impl Into<String>,
                child_id: impl Into<String>,
            ) -> GetRequestBuilder<A> {
                GetRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    folder_id: folder_id.into(),
                    child_id: child_id.into(),
                    error_recovery: None,
                    feature_label: None,
                    mutation_precondition: None,
                    open_drive: None,
                    reason: None,
                    sync_type: None,
                }
            }
            #[doc = "Inserts a file into a folder."]
            pub fn insert(
                &self,
                request: crate::schemas::ChildReference,
                folder_id: impl Into<String>,
            ) -> InsertRequestBuilder<A> {
                InsertRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    request,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    folder_id: folder_id.into(),
                    error_recovery: None,
                    feature_label: None,
                    mutation_precondition: None,
                    open_drive: None,
                    reason: None,
                    supports_all_drives: None,
                    supports_team_drives: None,
                    sync_type: None,
                }
            }
            #[doc = "Lists a folder's children."]
            pub fn list(&self, folder_id: impl Into<String>) -> ListRequestBuilder<A> {
                ListRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    folder_id: folder_id.into(),
                    error_recovery: None,
                    feature_label: None,
                    max_results: None,
                    mutation_precondition: None,
                    open_drive: None,
                    order_by: None,
                    page_token: None,
                    q: None,
                    reason: None,
                    reverse_sort: None,
                    secondary_sort_by: None,
                    sort_by: None,
                    sync_type: None,
                }
            }
        }
        #[derive(Debug, Clone)]
        pub struct DeleteRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            folder_id: String,
            child_id: String,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            reason: Option<String>,
            sync_type: Option<i32>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> DeleteRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            pub fn execute(self) -> Result<(), Box<dyn ::std::error::Error>> {
                let req = self._request(&self._path());
                req.send()?.error_for_status()?;
                Ok(())
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files/");
                {
                    let var_as_str = &self.folder_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/children/");
                {
                    let var_as_str = &self.child_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::DELETE, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct GetRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            folder_id: String,
            child_id: String,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            reason: Option<String>,
            sync_type: Option<i32>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> GetRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::ChildReference, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::ChildReference, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files/");
                {
                    let var_as_str = &self.folder_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/children/");
                {
                    let var_as_str = &self.child_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::GET, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec![
                    "https://www.googleapis.com/auth/drive.metadata.readonly",
                ]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct InsertRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            request: crate::schemas::ChildReference,
            folder_id: String,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            reason: Option<String>,
            supports_all_drives: Option<bool>,
            supports_team_drives: Option<bool>,
            sync_type: Option<i32>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> InsertRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Deprecated - Whether the requesting application supports both My Drives and shared drives. This parameter will only be effective until June 1, 2020. Afterwards all applications are assumed to support shared drives."]
            pub fn supports_all_drives(mut self, value: bool) -> Self {
                self.supports_all_drives = Some(value);
                self
            }
            #[doc = "Deprecated use supportsAllDrives instead."]
            pub fn supports_team_drives(mut self, value: bool) -> Self {
                self.supports_team_drives = Some(value);
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::ChildReference, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::ChildReference, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                let req = req.json(&self.request);
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files/");
                {
                    let var_as_str = &self.folder_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/children");
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::POST, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("supportsAllDrives", &self.supports_all_drives)]);
                let req = req.query(&[("supportsTeamDrives", &self.supports_team_drives)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct ListRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            folder_id: String,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            max_results: Option<i32>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            order_by: Option<String>,
            page_token: Option<String>,
            q: Option<String>,
            reason: Option<String>,
            reverse_sort: Option<bool>,
            secondary_sort_by: Option<String>,
            sort_by: Option<crate::resources::children::params::ListSortBy>,
            sync_type: Option<i32>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> ListRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "Maximum number of children to return."]
            pub fn max_results(mut self, value: i32) -> Self {
                self.max_results = Some(value);
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "A comma-separated list of sort keys. Valid keys are 'createdDate', 'folder', 'lastViewedByMeDate', 'modifiedByMeDate', 'modifiedDate', 'quotaBytesUsed', 'recency', 'sharedWithMeDate', 'starred', and 'title'. Each key sorts ascending by default, but may be reversed with the 'desc' modifier. Example usage: ?orderBy=folder,modifiedDate desc,title. Please note that there is a current limitation for users with approximately one million files in which the requested sort order is ignored."]
            pub fn order_by(mut self, value: impl Into<String>) -> Self {
                self.order_by = Some(value.into());
                self
            }
            #[doc = "Page token for children."]
            pub fn page_token(mut self, value: impl Into<String>) -> Self {
                self.page_token = Some(value.into());
                self
            }
            #[doc = "Query string for searching children."]
            pub fn q(mut self, value: impl Into<String>) -> Self {
                self.q = Some(value.into());
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "DEPRECATED; use orderBy instead. Whether to reverse the order of the results if sortBy is set."]
            pub fn reverse_sort(mut self, value: bool) -> Self {
                self.reverse_sort = Some(value);
                self
            }
            #[doc = "DEPRECATED; use orderBy instead. The list of sort orders to apply after sortBy."]
            pub fn secondary_sort_by(mut self, value: impl Into<String>) -> Self {
                self.secondary_sort_by = Some(value.into());
                self
            }
            #[doc = "DEPRECATED; use orderBy instead. The sort order for returned files."]
            pub fn sort_by(
                mut self,
                value: crate::resources::children::params::ListSortBy,
            ) -> Self {
                self.sort_by = Some(value);
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Return an iterator that iterates over all `#prop_ident`. The"]
            #[doc = r" items yielded by the iterator are chosen by the caller of this"]
            #[doc = r" method and must implement `Deserialize` and `FieldSelector`. The"]
            #[doc = r" populated fields in the yielded items will be determined by the"]
            #[doc = r" `FieldSelector` implementation."]
            pub fn iter_items<T>(mut self) -> crate::iter::PageItemIter<Self, T>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let mut fields = concat!("nextPageToken,", "items").to_owned();
                let items_fields = T::field_selector();
                if !items_fields.is_empty() {
                    fields.push_str("(");
                    fields.push_str(&items_fields);
                    fields.push_str(")");
                }
                self.fields = Some(fields);
                crate::iter::PageItemIter::new(self, "items")
            }
            #[doc = r" Return an iterator that iterates over all `#prop_ident`. The"]
            #[doc = r" items yielded by the iterator are `#items_type`. The populated"]
            #[doc = r" fields in `#items_type` will be the default fields populated by"]
            #[doc = r" the server."]
            pub fn iter_items_standard(
                mut self,
            ) -> crate::iter::PageItemIter<Self, crate::schemas::ChildReference> {
                self.fields = Some(concat!("nextPageToken,", "items").to_owned());
                crate::iter::PageItemIter::new(self, "items")
            }
            #[doc = r" Return an iterator that iterates over all `#prop_ident`. The"]
            #[doc = r" items yielded by the iterator are `#items_type`. The populated"]
            #[doc = r" fields in `#items_type` will be all fields available. This should"]
            #[doc = r" primarily be used during developement and debugging as fetching"]
            #[doc = r" all fields can be expensive both in bandwidth and server"]
            #[doc = r" resources."]
            pub fn iter_items_debug(
                mut self,
            ) -> crate::iter::PageItemIter<Self, crate::schemas::ChildReference> {
                self.fields = Some(concat!("nextPageToken,", "items", "(*)").to_owned());
                crate::iter::PageItemIter::new(self, "items")
            }
            pub fn iter<T>(mut self) -> crate::iter::PageIter<Self, T>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let mut fields = T::field_selector();
                if !fields.is_empty() {
                    match fields.chars().rev().nth(0) {
                        Some(',') | None => {}
                        _ => fields.push_str(","),
                    }
                    fields.push_str("nextPageToken");
                    self.fields = Some(fields);
                }
                crate::iter::PageIter::new(self)
            }
            pub fn iter_standard(self) -> crate::iter::PageIter<Self, crate::schemas::ChildList> {
                crate::iter::PageIter::new(self)
            }
            pub fn iter_debug(mut self) -> crate::iter::PageIter<Self, crate::schemas::ChildList> {
                self.fields = Some("*".to_owned());
                crate::iter::PageIter::new(self)
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::ChildList, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::ChildList, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files/");
                {
                    let var_as_str = &self.folder_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/children");
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::GET, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("maxResults", &self.max_results)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("orderBy", &self.order_by)]);
                let req = req.query(&[("pageToken", &self.page_token)]);
                let req = req.query(&[("q", &self.q)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("reverseSort", &self.reverse_sort)]);
                let req = req.query(&[("secondarySortBy", &self.secondary_sort_by)]);
                let req = req.query(&[("sortBy", &self.sort_by)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec![
                    "https://www.googleapis.com/auth/drive.metadata.readonly",
                ]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        impl<'a, A: yup_oauth2::GetToken> crate::iter::IterableMethod for ListRequestBuilder<'a, A> {
            fn set_page_token(&mut self, value: String) {
                self.page_token = value.into();
            }
            fn execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                self._execute()
            }
        }
    }
    pub mod comments {
        pub mod params {}
        pub struct CommentsActions<'a, A> {
            pub(crate) reqwest: &'a reqwest::Client,
            pub(crate) auth: &'a std::sync::Mutex<A>,
        }
        impl<'a, A: yup_oauth2::GetToken> CommentsActions<'a, A> {
            #[doc = "Deletes a comment."]
            pub fn delete(
                &self,
                file_id: impl Into<String>,
                comment_id: impl Into<String>,
            ) -> DeleteRequestBuilder<A> {
                DeleteRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    file_id: file_id.into(),
                    comment_id: comment_id.into(),
                }
            }
            #[doc = "Gets a comment by ID."]
            pub fn get(
                &self,
                file_id: impl Into<String>,
                comment_id: impl Into<String>,
            ) -> GetRequestBuilder<A> {
                GetRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    file_id: file_id.into(),
                    comment_id: comment_id.into(),
                    include_deleted: None,
                }
            }
            #[doc = "Creates a new comment on the given file."]
            pub fn insert(
                &self,
                request: crate::schemas::Comment,
                file_id: impl Into<String>,
            ) -> InsertRequestBuilder<A> {
                InsertRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    request,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    file_id: file_id.into(),
                }
            }
            #[doc = "Lists a file's comments."]
            pub fn list(&self, file_id: impl Into<String>) -> ListRequestBuilder<A> {
                ListRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    file_id: file_id.into(),
                    include_deleted: None,
                    include_suggestions: None,
                    max_results: None,
                    page_token: None,
                    updated_min: None,
                }
            }
            #[doc = "Updates an existing comment. This method supports patch semantics."]
            pub fn patch(
                &self,
                request: crate::schemas::Comment,
                file_id: impl Into<String>,
                comment_id: impl Into<String>,
            ) -> PatchRequestBuilder<A> {
                PatchRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    request,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    file_id: file_id.into(),
                    comment_id: comment_id.into(),
                }
            }
            #[doc = "Updates an existing comment."]
            pub fn update(
                &self,
                request: crate::schemas::Comment,
                file_id: impl Into<String>,
                comment_id: impl Into<String>,
            ) -> UpdateRequestBuilder<A> {
                UpdateRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    request,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    file_id: file_id.into(),
                    comment_id: comment_id.into(),
                }
            }
        }
        #[derive(Debug, Clone)]
        pub struct DeleteRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            file_id: String,
            comment_id: String,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> DeleteRequestBuilder<'a, A> {
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            pub fn execute(self) -> Result<(), Box<dyn ::std::error::Error>> {
                let req = self._request(&self._path());
                req.send()?.error_for_status()?;
                Ok(())
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files/");
                {
                    let var_as_str = &self.file_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/comments/");
                {
                    let var_as_str = &self.comment_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::DELETE, path);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct GetRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            file_id: String,
            comment_id: String,
            include_deleted: Option<bool>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> GetRequestBuilder<'a, A> {
            #[doc = "If set, this will succeed when retrieving a deleted comment, and will include any deleted replies."]
            pub fn include_deleted(mut self, value: bool) -> Self {
                self.include_deleted = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::Comment, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::Comment, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files/");
                {
                    let var_as_str = &self.file_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/comments/");
                {
                    let var_as_str = &self.comment_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::GET, path);
                let req = req.query(&[("includeDeleted", &self.include_deleted)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive.readonly"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct InsertRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            request: crate::schemas::Comment,
            file_id: String,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> InsertRequestBuilder<'a, A> {
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::Comment, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::Comment, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                let req = req.json(&self.request);
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files/");
                {
                    let var_as_str = &self.file_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/comments");
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::POST, path);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct ListRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            file_id: String,
            include_deleted: Option<bool>,
            include_suggestions: Option<bool>,
            max_results: Option<i32>,
            page_token: Option<String>,
            updated_min: Option<String>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> ListRequestBuilder<'a, A> {
            #[doc = "If set, all comments and replies, including deleted comments and replies (with content stripped) will be returned."]
            pub fn include_deleted(mut self, value: bool) -> Self {
                self.include_deleted = Some(value);
                self
            }
            #[doc = "If set, suggested edits will be included in the response."]
            pub fn include_suggestions(mut self, value: bool) -> Self {
                self.include_suggestions = Some(value);
                self
            }
            #[doc = "The maximum number of discussions to include in the response, used for paging."]
            pub fn max_results(mut self, value: i32) -> Self {
                self.max_results = Some(value);
                self
            }
            #[doc = "The continuation token, used to page through large result sets. To get the next page of results, set this parameter to the value of \"nextPageToken\" from the previous response."]
            pub fn page_token(mut self, value: impl Into<String>) -> Self {
                self.page_token = Some(value.into());
                self
            }
            #[doc = "Only discussions that were updated after this timestamp will be returned. Formatted as an RFC 3339 timestamp."]
            pub fn updated_min(mut self, value: impl Into<String>) -> Self {
                self.updated_min = Some(value.into());
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Return an iterator that iterates over all `#prop_ident`. The"]
            #[doc = r" items yielded by the iterator are chosen by the caller of this"]
            #[doc = r" method and must implement `Deserialize` and `FieldSelector`. The"]
            #[doc = r" populated fields in the yielded items will be determined by the"]
            #[doc = r" `FieldSelector` implementation."]
            pub fn iter_items<T>(mut self) -> crate::iter::PageItemIter<Self, T>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let mut fields = concat!("nextPageToken,", "items").to_owned();
                let items_fields = T::field_selector();
                if !items_fields.is_empty() {
                    fields.push_str("(");
                    fields.push_str(&items_fields);
                    fields.push_str(")");
                }
                self.fields = Some(fields);
                crate::iter::PageItemIter::new(self, "items")
            }
            #[doc = r" Return an iterator that iterates over all `#prop_ident`. The"]
            #[doc = r" items yielded by the iterator are `#items_type`. The populated"]
            #[doc = r" fields in `#items_type` will be the default fields populated by"]
            #[doc = r" the server."]
            pub fn iter_items_standard(
                mut self,
            ) -> crate::iter::PageItemIter<Self, crate::schemas::Comment> {
                self.fields = Some(concat!("nextPageToken,", "items").to_owned());
                crate::iter::PageItemIter::new(self, "items")
            }
            #[doc = r" Return an iterator that iterates over all `#prop_ident`. The"]
            #[doc = r" items yielded by the iterator are `#items_type`. The populated"]
            #[doc = r" fields in `#items_type` will be all fields available. This should"]
            #[doc = r" primarily be used during developement and debugging as fetching"]
            #[doc = r" all fields can be expensive both in bandwidth and server"]
            #[doc = r" resources."]
            pub fn iter_items_debug(
                mut self,
            ) -> crate::iter::PageItemIter<Self, crate::schemas::Comment> {
                self.fields = Some(concat!("nextPageToken,", "items", "(*)").to_owned());
                crate::iter::PageItemIter::new(self, "items")
            }
            pub fn iter<T>(mut self) -> crate::iter::PageIter<Self, T>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let mut fields = T::field_selector();
                if !fields.is_empty() {
                    match fields.chars().rev().nth(0) {
                        Some(',') | None => {}
                        _ => fields.push_str(","),
                    }
                    fields.push_str("nextPageToken");
                    self.fields = Some(fields);
                }
                crate::iter::PageIter::new(self)
            }
            pub fn iter_standard(self) -> crate::iter::PageIter<Self, crate::schemas::CommentList> {
                crate::iter::PageIter::new(self)
            }
            pub fn iter_debug(
                mut self,
            ) -> crate::iter::PageIter<Self, crate::schemas::CommentList> {
                self.fields = Some("*".to_owned());
                crate::iter::PageIter::new(self)
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::CommentList, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::CommentList, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files/");
                {
                    let var_as_str = &self.file_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/comments");
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::GET, path);
                let req = req.query(&[("includeDeleted", &self.include_deleted)]);
                let req = req.query(&[("includeSuggestions", &self.include_suggestions)]);
                let req = req.query(&[("maxResults", &self.max_results)]);
                let req = req.query(&[("pageToken", &self.page_token)]);
                let req = req.query(&[("updatedMin", &self.updated_min)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive.readonly"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        impl<'a, A: yup_oauth2::GetToken> crate::iter::IterableMethod for ListRequestBuilder<'a, A> {
            fn set_page_token(&mut self, value: String) {
                self.page_token = value.into();
            }
            fn execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                self._execute()
            }
        }
        #[derive(Debug, Clone)]
        pub struct PatchRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            request: crate::schemas::Comment,
            file_id: String,
            comment_id: String,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> PatchRequestBuilder<'a, A> {
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::Comment, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::Comment, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                let req = req.json(&self.request);
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files/");
                {
                    let var_as_str = &self.file_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/comments/");
                {
                    let var_as_str = &self.comment_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::PATCH, path);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct UpdateRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            request: crate::schemas::Comment,
            file_id: String,
            comment_id: String,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> UpdateRequestBuilder<'a, A> {
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::Comment, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::Comment, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                let req = req.json(&self.request);
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files/");
                {
                    let var_as_str = &self.file_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/comments/");
                {
                    let var_as_str = &self.comment_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::PUT, path);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
    }
    pub mod drives {
        pub mod params {}
        pub struct DrivesActions<'a, A> {
            pub(crate) reqwest: &'a reqwest::Client,
            pub(crate) auth: &'a std::sync::Mutex<A>,
        }
        impl<'a, A: yup_oauth2::GetToken> DrivesActions<'a, A> {
            #[doc = "Allows adding, removing, and updating references to Categories on a shared drive."]
            pub fn change_category_references(
                &self,
                request: crate::schemas::DriveCategoryChangeRequest,
                drive_id: impl Into<String>,
            ) -> ChangeCategoryReferencesRequestBuilder<A> {
                ChangeCategoryReferencesRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    request,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    drive_id: drive_id.into(),
                    error_recovery: None,
                    feature_label: None,
                    mutation_precondition: None,
                    open_drive: None,
                    reason: None,
                    sync_type: None,
                    use_domain_admin_access: None,
                }
            }
            #[doc = "Permanently deletes a shared drive for which the user is an organizer. The shared drive cannot contain any untrashed items."]
            pub fn delete(&self, drive_id: impl Into<String>) -> DeleteRequestBuilder<A> {
                DeleteRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    drive_id: drive_id.into(),
                    error_recovery: None,
                    feature_label: None,
                    mutation_precondition: None,
                    open_drive: None,
                    reason: None,
                    sync_type: None,
                }
            }
            #[doc = "Gets a shared drive's metadata by ID."]
            pub fn get(&self, drive_id: impl Into<String>) -> GetRequestBuilder<A> {
                GetRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    drive_id: drive_id.into(),
                    error_recovery: None,
                    feature_label: None,
                    mutation_precondition: None,
                    open_drive: None,
                    reason: None,
                    sync_type: None,
                    use_domain_admin_access: None,
                }
            }
            #[doc = "Hides a shared drive from the default view."]
            pub fn hide(&self, drive_id: impl Into<String>) -> HideRequestBuilder<A> {
                HideRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    drive_id: drive_id.into(),
                    error_recovery: None,
                    feature_label: None,
                    mutation_precondition: None,
                    open_drive: None,
                    reason: None,
                    sync_type: None,
                }
            }
            #[doc = "Creates a new shared drive."]
            pub fn insert(
                &self,
                request: crate::schemas::Drive,
                request_id: impl Into<String>,
            ) -> InsertRequestBuilder<A> {
                InsertRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    request,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    request_id: request_id.into(),
                    error_recovery: None,
                    feature_label: None,
                    mutation_precondition: None,
                    open_drive: None,
                    reason: None,
                    sync_type: None,
                }
            }
            #[doc = "Lists the user's shared drives."]
            pub fn list(&self) -> ListRequestBuilder<A> {
                ListRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    error_recovery: None,
                    feature_label: None,
                    max_results: None,
                    mutation_precondition: None,
                    open_drive: None,
                    page_token: None,
                    q: None,
                    reason: None,
                    sync_type: None,
                    use_domain_admin_access: None,
                }
            }
            #[doc = "Restores a shared drive to the default view."]
            pub fn unhide(&self, drive_id: impl Into<String>) -> UnhideRequestBuilder<A> {
                UnhideRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    drive_id: drive_id.into(),
                    error_recovery: None,
                    feature_label: None,
                    mutation_precondition: None,
                    open_drive: None,
                    reason: None,
                    sync_type: None,
                }
            }
            #[doc = "Updates the metadata for a shared drive."]
            pub fn update(
                &self,
                request: crate::schemas::Drive,
                drive_id: impl Into<String>,
            ) -> UpdateRequestBuilder<A> {
                UpdateRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    request,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    drive_id: drive_id.into(),
                    error_recovery: None,
                    feature_label: None,
                    mutation_precondition: None,
                    open_drive: None,
                    reason: None,
                    sync_type: None,
                    use_domain_admin_access: None,
                }
            }
        }
        #[derive(Debug, Clone)]
        pub struct ChangeCategoryReferencesRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            request: crate::schemas::DriveCategoryChangeRequest,
            drive_id: String,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            reason: Option<String>,
            sync_type: Option<i32>,
            use_domain_admin_access: Option<bool>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> ChangeCategoryReferencesRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "Issue the request as a domain administrator; if set to true, then the requester will be granted access if they are an administrator of the domain to which the shared drive belongs."]
            pub fn use_domain_admin_access(mut self, value: bool) -> Self {
                self.use_domain_admin_access = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::Drive, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::Drive, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                let req = req.json(&self.request);
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("drives/");
                {
                    let var_as_str = &self.drive_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/changeCategoryReferences");
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::POST, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("useDomainAdminAccess", &self.use_domain_admin_access)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct DeleteRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            drive_id: String,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            reason: Option<String>,
            sync_type: Option<i32>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> DeleteRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            pub fn execute(self) -> Result<(), Box<dyn ::std::error::Error>> {
                let req = self._request(&self._path());
                req.send()?.error_for_status()?;
                Ok(())
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("drives/");
                {
                    let var_as_str = &self.drive_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::DELETE, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct GetRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            drive_id: String,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            reason: Option<String>,
            sync_type: Option<i32>,
            use_domain_admin_access: Option<bool>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> GetRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "Issue the request as a domain administrator; if set to true, then the requester will be granted access if they are an administrator of the domain to which the shared drive belongs."]
            pub fn use_domain_admin_access(mut self, value: bool) -> Self {
                self.use_domain_admin_access = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::Drive, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::Drive, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("drives/");
                {
                    let var_as_str = &self.drive_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::GET, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("useDomainAdminAccess", &self.use_domain_admin_access)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive.readonly"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct HideRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            drive_id: String,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            reason: Option<String>,
            sync_type: Option<i32>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> HideRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::Drive, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::Drive, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("drives/");
                {
                    let var_as_str = &self.drive_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/hide");
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::POST, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct InsertRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            request: crate::schemas::Drive,
            request_id: String,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            reason: Option<String>,
            sync_type: Option<i32>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> InsertRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::Drive, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::Drive, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                let req = req.json(&self.request);
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("drives/");
                {
                    let var_as_str = &self.request_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::POST, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct ListRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            max_results: Option<i32>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            page_token: Option<String>,
            q: Option<String>,
            reason: Option<String>,
            sync_type: Option<i32>,
            use_domain_admin_access: Option<bool>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> ListRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "Maximum number of shared drives to return."]
            pub fn max_results(mut self, value: i32) -> Self {
                self.max_results = Some(value);
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "Page token for shared drives."]
            pub fn page_token(mut self, value: impl Into<String>) -> Self {
                self.page_token = Some(value.into());
                self
            }
            #[doc = "Query string for searching shared drives."]
            pub fn q(mut self, value: impl Into<String>) -> Self {
                self.q = Some(value.into());
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "Issue the request as a domain administrator; if set to true, then all shared drives of the domain in which the requester is an administrator are returned."]
            pub fn use_domain_admin_access(mut self, value: bool) -> Self {
                self.use_domain_admin_access = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Return an iterator that iterates over all `#prop_ident`. The"]
            #[doc = r" items yielded by the iterator are chosen by the caller of this"]
            #[doc = r" method and must implement `Deserialize` and `FieldSelector`. The"]
            #[doc = r" populated fields in the yielded items will be determined by the"]
            #[doc = r" `FieldSelector` implementation."]
            pub fn iter_items<T>(mut self) -> crate::iter::PageItemIter<Self, T>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let mut fields = concat!("nextPageToken,", "items").to_owned();
                let items_fields = T::field_selector();
                if !items_fields.is_empty() {
                    fields.push_str("(");
                    fields.push_str(&items_fields);
                    fields.push_str(")");
                }
                self.fields = Some(fields);
                crate::iter::PageItemIter::new(self, "items")
            }
            #[doc = r" Return an iterator that iterates over all `#prop_ident`. The"]
            #[doc = r" items yielded by the iterator are `#items_type`. The populated"]
            #[doc = r" fields in `#items_type` will be the default fields populated by"]
            #[doc = r" the server."]
            pub fn iter_items_standard(
                mut self,
            ) -> crate::iter::PageItemIter<Self, crate::schemas::Drive> {
                self.fields = Some(concat!("nextPageToken,", "items").to_owned());
                crate::iter::PageItemIter::new(self, "items")
            }
            #[doc = r" Return an iterator that iterates over all `#prop_ident`. The"]
            #[doc = r" items yielded by the iterator are `#items_type`. The populated"]
            #[doc = r" fields in `#items_type` will be all fields available. This should"]
            #[doc = r" primarily be used during developement and debugging as fetching"]
            #[doc = r" all fields can be expensive both in bandwidth and server"]
            #[doc = r" resources."]
            pub fn iter_items_debug(
                mut self,
            ) -> crate::iter::PageItemIter<Self, crate::schemas::Drive> {
                self.fields = Some(concat!("nextPageToken,", "items", "(*)").to_owned());
                crate::iter::PageItemIter::new(self, "items")
            }
            pub fn iter<T>(mut self) -> crate::iter::PageIter<Self, T>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let mut fields = T::field_selector();
                if !fields.is_empty() {
                    match fields.chars().rev().nth(0) {
                        Some(',') | None => {}
                        _ => fields.push_str(","),
                    }
                    fields.push_str("nextPageToken");
                    self.fields = Some(fields);
                }
                crate::iter::PageIter::new(self)
            }
            pub fn iter_standard(self) -> crate::iter::PageIter<Self, crate::schemas::DriveList> {
                crate::iter::PageIter::new(self)
            }
            pub fn iter_debug(mut self) -> crate::iter::PageIter<Self, crate::schemas::DriveList> {
                self.fields = Some("*".to_owned());
                crate::iter::PageIter::new(self)
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::DriveList, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::DriveList, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("drives");
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::GET, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("maxResults", &self.max_results)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("pageToken", &self.page_token)]);
                let req = req.query(&[("q", &self.q)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("useDomainAdminAccess", &self.use_domain_admin_access)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive.readonly"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        impl<'a, A: yup_oauth2::GetToken> crate::iter::IterableMethod for ListRequestBuilder<'a, A> {
            fn set_page_token(&mut self, value: String) {
                self.page_token = value.into();
            }
            fn execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                self._execute()
            }
        }
        #[derive(Debug, Clone)]
        pub struct UnhideRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            drive_id: String,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            reason: Option<String>,
            sync_type: Option<i32>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> UnhideRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::Drive, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::Drive, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("drives/");
                {
                    let var_as_str = &self.drive_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/unhide");
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::POST, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct UpdateRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            request: crate::schemas::Drive,
            drive_id: String,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            reason: Option<String>,
            sync_type: Option<i32>,
            use_domain_admin_access: Option<bool>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> UpdateRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "Issue the request as a domain administrator; if set to true, then the requester will be granted access if they are an administrator of the domain to which the shared drive belongs."]
            pub fn use_domain_admin_access(mut self, value: bool) -> Self {
                self.use_domain_admin_access = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::Drive, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::Drive, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                let req = req.json(&self.request);
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("drives/");
                {
                    let var_as_str = &self.drive_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::PUT, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("useDomainAdminAccess", &self.use_domain_admin_access)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
    }
    pub mod files {
        pub mod params {
            #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
            pub enum CopyVisibility {
                #[doc = "The visibility of the new file is determined by the user's default visibility/sharing policies."]
                Default,
                #[doc = "The new file will be visible to only the owner."]
                Private,
            }
            impl CopyVisibility {
                pub fn as_str(self) -> &'static str {
                    match self {
                        CopyVisibility::Default => "DEFAULT",
                        CopyVisibility::Private => "PRIVATE",
                    }
                }
            }
            impl ::std::fmt::Display for CopyVisibility {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    f.write_str(self.as_str())
                }
            }
            impl ::serde::Serialize for CopyVisibility {
                fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
                where
                    S: ::serde::ser::Serializer,
                {
                    serializer.serialize_str(self.as_str())
                }
            }
            impl<'de> ::serde::Deserialize<'de> for CopyVisibility {
                fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
                where
                    D: ::serde::de::Deserializer<'de>,
                {
                    let value: &'de str = <&str>::deserialize(deserializer)?;
                    Ok(match value {
                        "DEFAULT" => CopyVisibility::Default,
                        "PRIVATE" => CopyVisibility::Private,
                        _ => {
                            return Err(::serde::de::Error::custom(format!(
                                "invalid enum for #name: {}",
                                value
                            )))
                        }
                    })
                }
            }
            impl ::field_selector::FieldSelector for CopyVisibility {
                fn field_selector_with_ident(ident: &str, selector: &mut String) {
                    match selector.chars().rev().nth(0) {
                        Some(',') | None => {}
                        _ => selector.push_str(","),
                    }
                    selector.push_str(ident);
                }
            }
            #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
            pub enum ExtractOrigin {
                #[doc = "Indicates the file to be previewed is from the user's Google Drive account."]
                Drive,
                #[doc = "Indicates the file to be previewed is from a gmail attachment."]
                Gmail,
            }
            impl ExtractOrigin {
                pub fn as_str(self) -> &'static str {
                    match self {
                        ExtractOrigin::Drive => "DRIVE",
                        ExtractOrigin::Gmail => "GMAIL",
                    }
                }
            }
            impl ::std::fmt::Display for ExtractOrigin {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    f.write_str(self.as_str())
                }
            }
            impl ::serde::Serialize for ExtractOrigin {
                fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
                where
                    S: ::serde::ser::Serializer,
                {
                    serializer.serialize_str(self.as_str())
                }
            }
            impl<'de> ::serde::Deserialize<'de> for ExtractOrigin {
                fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
                where
                    D: ::serde::de::Deserializer<'de>,
                {
                    let value: &'de str = <&str>::deserialize(deserializer)?;
                    Ok(match value {
                        "DRIVE" => ExtractOrigin::Drive,
                        "GMAIL" => ExtractOrigin::Gmail,
                        _ => {
                            return Err(::serde::de::Error::custom(format!(
                                "invalid enum for #name: {}",
                                value
                            )))
                        }
                    })
                }
            }
            impl ::field_selector::FieldSelector for ExtractOrigin {
                fn field_selector_with_ident(ident: &str, selector: &mut String) {
                    match selector.chars().rev().nth(0) {
                        Some(',') | None => {}
                        _ => selector.push_str(","),
                    }
                    selector.push_str(ident);
                }
            }
            #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
            pub enum GetProjection {
                #[doc = "Deprecated"]
                Basic,
                #[doc = "Deprecated"]
                Full,
            }
            impl GetProjection {
                pub fn as_str(self) -> &'static str {
                    match self {
                        GetProjection::Basic => "BASIC",
                        GetProjection::Full => "FULL",
                    }
                }
            }
            impl ::std::fmt::Display for GetProjection {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    f.write_str(self.as_str())
                }
            }
            impl ::serde::Serialize for GetProjection {
                fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
                where
                    S: ::serde::ser::Serializer,
                {
                    serializer.serialize_str(self.as_str())
                }
            }
            impl<'de> ::serde::Deserialize<'de> for GetProjection {
                fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
                where
                    D: ::serde::de::Deserializer<'de>,
                {
                    let value: &'de str = <&str>::deserialize(deserializer)?;
                    Ok(match value {
                        "BASIC" => GetProjection::Basic,
                        "FULL" => GetProjection::Full,
                        _ => {
                            return Err(::serde::de::Error::custom(format!(
                                "invalid enum for #name: {}",
                                value
                            )))
                        }
                    })
                }
            }
            impl ::field_selector::FieldSelector for GetProjection {
                fn field_selector_with_ident(ident: &str, selector: &mut String) {
                    match selector.chars().rev().nth(0) {
                        Some(',') | None => {}
                        _ => selector.push_str(","),
                    }
                    selector.push_str(ident);
                }
            }
            #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
            pub enum InsertVisibility {
                #[doc = "The visibility of the new file is determined by the user's default visibility/sharing policies."]
                Default,
                #[doc = "The new file will be visible to only the owner."]
                Private,
            }
            impl InsertVisibility {
                pub fn as_str(self) -> &'static str {
                    match self {
                        InsertVisibility::Default => "DEFAULT",
                        InsertVisibility::Private => "PRIVATE",
                    }
                }
            }
            impl ::std::fmt::Display for InsertVisibility {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    f.write_str(self.as_str())
                }
            }
            impl ::serde::Serialize for InsertVisibility {
                fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
                where
                    S: ::serde::ser::Serializer,
                {
                    serializer.serialize_str(self.as_str())
                }
            }
            impl<'de> ::serde::Deserialize<'de> for InsertVisibility {
                fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
                where
                    D: ::serde::de::Deserializer<'de>,
                {
                    let value: &'de str = <&str>::deserialize(deserializer)?;
                    Ok(match value {
                        "DEFAULT" => InsertVisibility::Default,
                        "PRIVATE" => InsertVisibility::Private,
                        _ => {
                            return Err(::serde::de::Error::custom(format!(
                                "invalid enum for #name: {}",
                                value
                            )))
                        }
                    })
                }
            }
            impl ::field_selector::FieldSelector for InsertVisibility {
                fn field_selector_with_ident(ident: &str, selector: &mut String) {
                    match selector.chars().rev().nth(0) {
                        Some(',') | None => {}
                        _ => selector.push_str(","),
                    }
                    selector.push_str(ident);
                }
            }
            #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
            pub enum ListAppDataFilter {
                #[doc = "Specifies that the query should return App Data and non-App Data files."]
                AllFiles,
                #[doc = "Specifies that the query should not return App Data files."]
                NoAppData,
                #[doc = "Specifies that the query should only return App Data files."]
                OnlyAppData,
            }
            impl ListAppDataFilter {
                pub fn as_str(self) -> &'static str {
                    match self {
                        ListAppDataFilter::AllFiles => "ALL_FILES",
                        ListAppDataFilter::NoAppData => "NO_APP_DATA",
                        ListAppDataFilter::OnlyAppData => "ONLY_APP_DATA",
                    }
                }
            }
            impl ::std::fmt::Display for ListAppDataFilter {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    f.write_str(self.as_str())
                }
            }
            impl ::serde::Serialize for ListAppDataFilter {
                fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
                where
                    S: ::serde::ser::Serializer,
                {
                    serializer.serialize_str(self.as_str())
                }
            }
            impl<'de> ::serde::Deserialize<'de> for ListAppDataFilter {
                fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
                where
                    D: ::serde::de::Deserializer<'de>,
                {
                    let value: &'de str = <&str>::deserialize(deserializer)?;
                    Ok(match value {
                        "ALL_FILES" => ListAppDataFilter::AllFiles,
                        "NO_APP_DATA" => ListAppDataFilter::NoAppData,
                        "ONLY_APP_DATA" => ListAppDataFilter::OnlyAppData,
                        _ => {
                            return Err(::serde::de::Error::custom(format!(
                                "invalid enum for #name: {}",
                                value
                            )))
                        }
                    })
                }
            }
            impl ::field_selector::FieldSelector for ListAppDataFilter {
                fn field_selector_with_ident(ident: &str, selector: &mut String) {
                    match selector.chars().rev().nth(0) {
                        Some(',') | None => {}
                        _ => selector.push_str(","),
                    }
                    selector.push_str(ident);
                }
            }
            #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
            pub enum ListCorpus {
                #[doc = "The items that the user has accessed. This encompasses shared drive items that the user has recently accessed."]
                Default,
                #[doc = "Items shared to the user's domain."]
                Domain,
            }
            impl ListCorpus {
                pub fn as_str(self) -> &'static str {
                    match self {
                        ListCorpus::Default => "DEFAULT",
                        ListCorpus::Domain => "DOMAIN",
                    }
                }
            }
            impl ::std::fmt::Display for ListCorpus {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    f.write_str(self.as_str())
                }
            }
            impl ::serde::Serialize for ListCorpus {
                fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
                where
                    S: ::serde::ser::Serializer,
                {
                    serializer.serialize_str(self.as_str())
                }
            }
            impl<'de> ::serde::Deserialize<'de> for ListCorpus {
                fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
                where
                    D: ::serde::de::Deserializer<'de>,
                {
                    let value: &'de str = <&str>::deserialize(deserializer)?;
                    Ok(match value {
                        "DEFAULT" => ListCorpus::Default,
                        "DOMAIN" => ListCorpus::Domain,
                        _ => {
                            return Err(::serde::de::Error::custom(format!(
                                "invalid enum for #name: {}",
                                value
                            )))
                        }
                    })
                }
            }
            impl ::field_selector::FieldSelector for ListCorpus {
                fn field_selector_with_ident(ident: &str, selector: &mut String) {
                    match selector.chars().rev().nth(0) {
                        Some(',') | None => {}
                        _ => selector.push_str(","),
                    }
                    selector.push_str(ident);
                }
            }
            #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
            pub enum ListProjection {
                #[doc = "Deprecated"]
                Basic,
                #[doc = "Deprecated"]
                Full,
            }
            impl ListProjection {
                pub fn as_str(self) -> &'static str {
                    match self {
                        ListProjection::Basic => "BASIC",
                        ListProjection::Full => "FULL",
                    }
                }
            }
            impl ::std::fmt::Display for ListProjection {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    f.write_str(self.as_str())
                }
            }
            impl ::serde::Serialize for ListProjection {
                fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
                where
                    S: ::serde::ser::Serializer,
                {
                    serializer.serialize_str(self.as_str())
                }
            }
            impl<'de> ::serde::Deserialize<'de> for ListProjection {
                fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
                where
                    D: ::serde::de::Deserializer<'de>,
                {
                    let value: &'de str = <&str>::deserialize(deserializer)?;
                    Ok(match value {
                        "BASIC" => ListProjection::Basic,
                        "FULL" => ListProjection::Full,
                        _ => {
                            return Err(::serde::de::Error::custom(format!(
                                "invalid enum for #name: {}",
                                value
                            )))
                        }
                    })
                }
            }
            impl ::field_selector::FieldSelector for ListProjection {
                fn field_selector_with_ident(ident: &str, selector: &mut String) {
                    match selector.chars().rev().nth(0) {
                        Some(',') | None => {}
                        _ => selector.push_str(","),
                    }
                    selector.push_str(ident);
                }
            }
            #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
            pub enum ListSortBy {
                #[doc = "Sort by the createdDate field of the files. Reverse chronological by default."]
                CreationDate,
                #[doc = "Sort folders first then sort files by title."]
                FolderTitle,
                #[doc = "Sort folders first."]
                FoldersFirst,
                #[doc = "Sort by the modifiedDate field of the files. Reverse chronological by default."]
                LastModified,
                #[doc = "Sort by the modifiedByMeDate field of the files. Reverse chronological by default."]
                LastModifiedByMe,
                #[doc = "Sort by the lastViewedByMeDate field of the files. Reverse chronological by default."]
                LastViewedByMe,
                #[doc = "Sort by the quotaBytesUsed field of the files. In descending order by default."]
                QuotaUsed,
                #[doc = "Sort by max(createdDate, lastViewedByMeDate, modifiedByMeDate) of the files. Reverse chronological by default."]
                Recent,
                #[doc = "Sort by the relevance of the query results."]
                Relevance,
                #[doc = "Sort by the sharedWithMeDate field of the files. Reverse chronological by default."]
                SharedWithMeDate,
                #[doc = "Sort starred items first."]
                StarredFirst,
                #[doc = "Sort by the title field of the files."]
                Title,
            }
            impl ListSortBy {
                pub fn as_str(self) -> &'static str {
                    match self {
                        ListSortBy::CreationDate => "CREATION_DATE",
                        ListSortBy::FolderTitle => "FOLDER_TITLE",
                        ListSortBy::FoldersFirst => "FOLDERS_FIRST",
                        ListSortBy::LastModified => "LAST_MODIFIED",
                        ListSortBy::LastModifiedByMe => "LAST_MODIFIED_BY_ME",
                        ListSortBy::LastViewedByMe => "LAST_VIEWED_BY_ME",
                        ListSortBy::QuotaUsed => "QUOTA_USED",
                        ListSortBy::Recent => "RECENT",
                        ListSortBy::Relevance => "RELEVANCE",
                        ListSortBy::SharedWithMeDate => "SHARED_WITH_ME_DATE",
                        ListSortBy::StarredFirst => "STARRED_FIRST",
                        ListSortBy::Title => "TITLE",
                    }
                }
            }
            impl ::std::fmt::Display for ListSortBy {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    f.write_str(self.as_str())
                }
            }
            impl ::serde::Serialize for ListSortBy {
                fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
                where
                    S: ::serde::ser::Serializer,
                {
                    serializer.serialize_str(self.as_str())
                }
            }
            impl<'de> ::serde::Deserialize<'de> for ListSortBy {
                fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
                where
                    D: ::serde::de::Deserializer<'de>,
                {
                    let value: &'de str = <&str>::deserialize(deserializer)?;
                    Ok(match value {
                        "CREATION_DATE" => ListSortBy::CreationDate,
                        "FOLDER_TITLE" => ListSortBy::FolderTitle,
                        "FOLDERS_FIRST" => ListSortBy::FoldersFirst,
                        "LAST_MODIFIED" => ListSortBy::LastModified,
                        "LAST_MODIFIED_BY_ME" => ListSortBy::LastModifiedByMe,
                        "LAST_VIEWED_BY_ME" => ListSortBy::LastViewedByMe,
                        "QUOTA_USED" => ListSortBy::QuotaUsed,
                        "RECENT" => ListSortBy::Recent,
                        "RELEVANCE" => ListSortBy::Relevance,
                        "SHARED_WITH_ME_DATE" => ListSortBy::SharedWithMeDate,
                        "STARRED_FIRST" => ListSortBy::StarredFirst,
                        "TITLE" => ListSortBy::Title,
                        _ => {
                            return Err(::serde::de::Error::custom(format!(
                                "invalid enum for #name: {}",
                                value
                            )))
                        }
                    })
                }
            }
            impl ::field_selector::FieldSelector for ListSortBy {
                fn field_selector_with_ident(ident: &str, selector: &mut String) {
                    match selector.chars().rev().nth(0) {
                        Some(',') | None => {}
                        _ => selector.push_str(","),
                    }
                    selector.push_str(ident);
                }
            }
            #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
            pub enum PatchModifiedDateBehavior {
                #[doc = "Set the modified date to the current time if a field is changing for which the Drive UI requires the modification date to be updated."]
                DriveUi,
                #[doc = "Set the modified date to the value provided in the body of the request if a field is changing for which the Drive UI requires the modification date to be updated."]
                DriveUiOffline,
                #[doc = "Maintain the previous value of the modified date."]
                NoChange,
                #[doc = "Set the modified date to the value provided in the body of the request. No change if no value was provided."]
                SetFromBody,
                #[doc = "Set the modified date to the value provided in the body of the request, or to the current time if no value was provided."]
                SetFromBodyOrNow,
                #[doc = "Set the modified date to the current time if changes are made to any field that is not per-user."]
                SetIfNeeded,
                #[doc = "Set the modified date to the current time."]
                SetNow,
            }
            impl PatchModifiedDateBehavior {
                pub fn as_str(self) -> &'static str {
                    match self {
                        PatchModifiedDateBehavior::DriveUi => "DRIVE_UI",
                        PatchModifiedDateBehavior::DriveUiOffline => "DRIVE_UI_OFFLINE",
                        PatchModifiedDateBehavior::NoChange => "NO_CHANGE",
                        PatchModifiedDateBehavior::SetFromBody => "SET_FROM_BODY",
                        PatchModifiedDateBehavior::SetFromBodyOrNow => "SET_FROM_BODY_OR_NOW",
                        PatchModifiedDateBehavior::SetIfNeeded => "SET_IF_NEEDED",
                        PatchModifiedDateBehavior::SetNow => "SET_NOW",
                    }
                }
            }
            impl ::std::fmt::Display for PatchModifiedDateBehavior {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    f.write_str(self.as_str())
                }
            }
            impl ::serde::Serialize for PatchModifiedDateBehavior {
                fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
                where
                    S: ::serde::ser::Serializer,
                {
                    serializer.serialize_str(self.as_str())
                }
            }
            impl<'de> ::serde::Deserialize<'de> for PatchModifiedDateBehavior {
                fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
                where
                    D: ::serde::de::Deserializer<'de>,
                {
                    let value: &'de str = <&str>::deserialize(deserializer)?;
                    Ok(match value {
                        "DRIVE_UI" => PatchModifiedDateBehavior::DriveUi,
                        "DRIVE_UI_OFFLINE" => PatchModifiedDateBehavior::DriveUiOffline,
                        "NO_CHANGE" => PatchModifiedDateBehavior::NoChange,
                        "SET_FROM_BODY" => PatchModifiedDateBehavior::SetFromBody,
                        "SET_FROM_BODY_OR_NOW" => PatchModifiedDateBehavior::SetFromBodyOrNow,
                        "SET_IF_NEEDED" => PatchModifiedDateBehavior::SetIfNeeded,
                        "SET_NOW" => PatchModifiedDateBehavior::SetNow,
                        _ => {
                            return Err(::serde::de::Error::custom(format!(
                                "invalid enum for #name: {}",
                                value
                            )))
                        }
                    })
                }
            }
            impl ::field_selector::FieldSelector for PatchModifiedDateBehavior {
                fn field_selector_with_ident(ident: &str, selector: &mut String) {
                    match selector.chars().rev().nth(0) {
                        Some(',') | None => {}
                        _ => selector.push_str(","),
                    }
                    selector.push_str(ident);
                }
            }
            #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
            pub enum PreviewOrigin {
                #[doc = "Indicates the file to be previewed is from the user's Google Drive account."]
                Drive,
                #[doc = "Indicates the file to be previewed is from a gmail attachment."]
                Gmail,
            }
            impl PreviewOrigin {
                pub fn as_str(self) -> &'static str {
                    match self {
                        PreviewOrigin::Drive => "DRIVE",
                        PreviewOrigin::Gmail => "GMAIL",
                    }
                }
            }
            impl ::std::fmt::Display for PreviewOrigin {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    f.write_str(self.as_str())
                }
            }
            impl ::serde::Serialize for PreviewOrigin {
                fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
                where
                    S: ::serde::ser::Serializer,
                {
                    serializer.serialize_str(self.as_str())
                }
            }
            impl<'de> ::serde::Deserialize<'de> for PreviewOrigin {
                fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
                where
                    D: ::serde::de::Deserializer<'de>,
                {
                    let value: &'de str = <&str>::deserialize(deserializer)?;
                    Ok(match value {
                        "DRIVE" => PreviewOrigin::Drive,
                        "GMAIL" => PreviewOrigin::Gmail,
                        _ => {
                            return Err(::serde::de::Error::custom(format!(
                                "invalid enum for #name: {}",
                                value
                            )))
                        }
                    })
                }
            }
            impl ::field_selector::FieldSelector for PreviewOrigin {
                fn field_selector_with_ident(ident: &str, selector: &mut String) {
                    match selector.chars().rev().nth(0) {
                        Some(',') | None => {}
                        _ => selector.push_str(","),
                    }
                    selector.push_str(ident);
                }
            }
            #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
            pub enum UpdateModifiedDateBehavior {
                #[doc = "Set the modified date to the current time if a field is changing for which the Drive UI requires the modification date to be updated."]
                DriveUi,
                #[doc = "Set the modified date to the value provided in the body of the request if a field is changing for which the Drive UI requires the modification date to be updated."]
                DriveUiOffline,
                #[doc = "Maintain the previous value of the modified date."]
                NoChange,
                #[doc = "Set the modified date to the value provided in the body of the request. No change if no value was provided."]
                SetFromBody,
                #[doc = "Set the modified date to the value provided in the body of the request, or to the current time if no value was provided."]
                SetFromBodyOrNow,
                #[doc = "Set the modified date to the current time if changes are made to any field that is not per-user."]
                SetIfNeeded,
                #[doc = "Set the modified date to the current time."]
                SetNow,
            }
            impl UpdateModifiedDateBehavior {
                pub fn as_str(self) -> &'static str {
                    match self {
                        UpdateModifiedDateBehavior::DriveUi => "DRIVE_UI",
                        UpdateModifiedDateBehavior::DriveUiOffline => "DRIVE_UI_OFFLINE",
                        UpdateModifiedDateBehavior::NoChange => "NO_CHANGE",
                        UpdateModifiedDateBehavior::SetFromBody => "SET_FROM_BODY",
                        UpdateModifiedDateBehavior::SetFromBodyOrNow => "SET_FROM_BODY_OR_NOW",
                        UpdateModifiedDateBehavior::SetIfNeeded => "SET_IF_NEEDED",
                        UpdateModifiedDateBehavior::SetNow => "SET_NOW",
                    }
                }
            }
            impl ::std::fmt::Display for UpdateModifiedDateBehavior {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    f.write_str(self.as_str())
                }
            }
            impl ::serde::Serialize for UpdateModifiedDateBehavior {
                fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
                where
                    S: ::serde::ser::Serializer,
                {
                    serializer.serialize_str(self.as_str())
                }
            }
            impl<'de> ::serde::Deserialize<'de> for UpdateModifiedDateBehavior {
                fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
                where
                    D: ::serde::de::Deserializer<'de>,
                {
                    let value: &'de str = <&str>::deserialize(deserializer)?;
                    Ok(match value {
                        "DRIVE_UI" => UpdateModifiedDateBehavior::DriveUi,
                        "DRIVE_UI_OFFLINE" => UpdateModifiedDateBehavior::DriveUiOffline,
                        "NO_CHANGE" => UpdateModifiedDateBehavior::NoChange,
                        "SET_FROM_BODY" => UpdateModifiedDateBehavior::SetFromBody,
                        "SET_FROM_BODY_OR_NOW" => UpdateModifiedDateBehavior::SetFromBodyOrNow,
                        "SET_IF_NEEDED" => UpdateModifiedDateBehavior::SetIfNeeded,
                        "SET_NOW" => UpdateModifiedDateBehavior::SetNow,
                        _ => {
                            return Err(::serde::de::Error::custom(format!(
                                "invalid enum for #name: {}",
                                value
                            )))
                        }
                    })
                }
            }
            impl ::field_selector::FieldSelector for UpdateModifiedDateBehavior {
                fn field_selector_with_ident(ident: &str, selector: &mut String) {
                    match selector.chars().rev().nth(0) {
                        Some(',') | None => {}
                        _ => selector.push_str(","),
                    }
                    selector.push_str(ident);
                }
            }
            #[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Ord, Eq, Copy)]
            pub enum WatchProjection {
                #[doc = "Deprecated"]
                Basic,
                #[doc = "Deprecated"]
                Full,
            }
            impl WatchProjection {
                pub fn as_str(self) -> &'static str {
                    match self {
                        WatchProjection::Basic => "BASIC",
                        WatchProjection::Full => "FULL",
                    }
                }
            }
            impl ::std::fmt::Display for WatchProjection {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    f.write_str(self.as_str())
                }
            }
            impl ::serde::Serialize for WatchProjection {
                fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
                where
                    S: ::serde::ser::Serializer,
                {
                    serializer.serialize_str(self.as_str())
                }
            }
            impl<'de> ::serde::Deserialize<'de> for WatchProjection {
                fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
                where
                    D: ::serde::de::Deserializer<'de>,
                {
                    let value: &'de str = <&str>::deserialize(deserializer)?;
                    Ok(match value {
                        "BASIC" => WatchProjection::Basic,
                        "FULL" => WatchProjection::Full,
                        _ => {
                            return Err(::serde::de::Error::custom(format!(
                                "invalid enum for #name: {}",
                                value
                            )))
                        }
                    })
                }
            }
            impl ::field_selector::FieldSelector for WatchProjection {
                fn field_selector_with_ident(ident: &str, selector: &mut String) {
                    match selector.chars().rev().nth(0) {
                        Some(',') | None => {}
                        _ => selector.push_str(","),
                    }
                    selector.push_str(ident);
                }
            }
        }
        pub struct FilesActions<'a, A> {
            pub(crate) reqwest: &'a reqwest::Client,
            pub(crate) auth: &'a std::sync::Mutex<A>,
        }
        impl<'a, A: yup_oauth2::GetToken> FilesActions<'a, A> {
            #[doc = "Authorize an app to access a file."]
            pub fn authorize(
                &self,
                file_id: impl Into<String>,
                app_id: impl Into<String>,
            ) -> AuthorizeRequestBuilder<A> {
                AuthorizeRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    file_id: file_id.into(),
                    app_id: app_id.into(),
                    error_recovery: None,
                    feature_label: None,
                    include_metadata_for_categories: None,
                    include_permissions_for_view: None,
                    mutation_precondition: None,
                    open_drive: None,
                    reason: None,
                    supports_all_drives: None,
                    supports_team_drives: None,
                    sync_type: None,
                    use_legacy_domain_permission_behavior: None,
                }
            }
            #[doc = "Checks for permission fix options for a role, a set of files, and a set of recipients."]
            pub fn check_permissions(
                &self,
                request: crate::schemas::CheckPermissionsRequest,
            ) -> CheckPermissionsRequestBuilder<A> {
                CheckPermissionsRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    request,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                }
            }
            #[doc = "Creates a copy of the specified file."]
            pub fn copy(
                &self,
                request: crate::schemas::File,
                file_id: impl Into<String>,
            ) -> CopyRequestBuilder<A> {
                CopyRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    request,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    file_id: file_id.into(),
                    convert: None,
                    convert_to: None,
                    copy_comments: None,
                    error_recovery: None,
                    feature_label: None,
                    include_metadata_for_categories: None,
                    include_permissions_for_view: None,
                    mutation_precondition: None,
                    ocr: None,
                    ocr_language: None,
                    open_drive: None,
                    pinned: None,
                    reason: None,
                    revision_id: None,
                    supports_all_drives: None,
                    supports_team_drives: None,
                    sync_type: None,
                    timed_text_language: None,
                    timed_text_track_name: None,
                    update_viewed_date: None,
                    use_legacy_domain_permission_behavior: None,
                    visibility: None,
                }
            }
            #[doc = "Remove an app's authorization from a file."]
            pub fn deauthorize(
                &self,
                file_id: impl Into<String>,
                app_id: impl Into<String>,
            ) -> DeauthorizeRequestBuilder<A> {
                DeauthorizeRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    file_id: file_id.into(),
                    app_id: app_id.into(),
                    error_recovery: None,
                    feature_label: None,
                    include_metadata_for_categories: None,
                    include_permissions_for_view: None,
                    mutation_precondition: None,
                    open_drive: None,
                    reason: None,
                    supports_all_drives: None,
                    supports_team_drives: None,
                    sync_type: None,
                    use_legacy_domain_permission_behavior: None,
                }
            }
            #[doc = "Permanently deletes a file by ID. Skips the trash. The currently authenticated user must own the file or be an organizer on the parent for shared drive files."]
            pub fn delete(&self, file_id: impl Into<String>) -> DeleteRequestBuilder<A> {
                DeleteRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    file_id: file_id.into(),
                    error_recovery: None,
                    feature_label: None,
                    mutation_precondition: None,
                    open_drive: None,
                    reason: None,
                    supports_all_drives: None,
                    supports_team_drives: None,
                    sync_type: None,
                }
            }
            #[doc = "Permanently deletes all of the user's trashed files."]
            pub fn empty_trash(&self) -> EmptyTrashRequestBuilder<A> {
                EmptyTrashRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    error_recovery: None,
                    feature_label: None,
                    mutation_precondition: None,
                    open_drive: None,
                    reason: None,
                    sync_type: None,
                }
            }
            #[doc = "Exports a Google Doc to the requested MIME type and returns the exported content."]
            pub fn export(
                &self,
                file_id: impl Into<String>,
                mime_type: impl Into<String>,
            ) -> ExportRequestBuilder<A> {
                ExportRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    file_id: file_id.into(),
                    mime_type: mime_type.into(),
                }
            }
            #[doc = "Extract the contents of an archive file into Google Drive. Currently supports RAR, TAR/BZ2, TAR/GZIP, and ZIP files."]
            pub fn extract(&self, file_id: impl Into<String>) -> ExtractRequestBuilder<A> {
                ExtractRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    file_id: file_id.into(),
                    destination_location_id: None,
                    file_name: None,
                    mime_type: None,
                    origin: None,
                }
            }
            #[doc = "Cancel an archive extraction job by the job ID"]
            pub fn extractcancel(
                &self,
                job_id: impl Into<String>,
            ) -> ExtractcancelRequestBuilder<A> {
                ExtractcancelRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    job_id: job_id.into(),
                }
            }
            #[doc = "Retrieve the status of an archive extraction job by the job ID"]
            pub fn extractstatus(
                &self,
                job_id: impl Into<String>,
            ) -> ExtractstatusRequestBuilder<A> {
                ExtractstatusRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    job_id: job_id.into(),
                }
            }
            #[doc = "Executes a permission fix option for a role, a set of files, and a set of recipients."]
            pub fn fix_permissions(
                &self,
                request: crate::schemas::FixPermissionsRequest,
            ) -> FixPermissionsRequestBuilder<A> {
                FixPermissionsRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    request,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                }
            }
            #[doc = "Generates a file ID based on the provided local ID."]
            pub fn generate_id(
                &self,
                request: crate::schemas::File,
            ) -> GenerateIdRequestBuilder<A> {
                GenerateIdRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    request,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    error_recovery: None,
                    feature_label: None,
                    mutation_precondition: None,
                    open_drive: None,
                    reason: None,
                    sync_type: None,
                }
            }
            #[doc = "Generates a set of file IDs which can be provided in insert or copy requests."]
            pub fn generate_ids(&self) -> GenerateIdsRequestBuilder<A> {
                GenerateIdsRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    error_recovery: None,
                    feature_label: None,
                    max_results: None,
                    mutation_precondition: None,
                    open_drive: None,
                    r#type: None,
                    reason: None,
                    space: None,
                    sync_type: None,
                }
            }
            #[doc = "Gets a file's metadata by ID."]
            pub fn get(&self, file_id: impl Into<String>) -> GetRequestBuilder<A> {
                GetRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    file_id: file_id.into(),
                    acknowledge_abuse: None,
                    all_properties: None,
                    embed_origin: None,
                    error_recovery: None,
                    expected_parent_ids: None,
                    feature_label: None,
                    file_scope_app_ids: None,
                    include_metadata_for_categories: None,
                    include_permissions_for_view: None,
                    mutation_precondition: None,
                    open_drive: None,
                    projection: None,
                    reason: None,
                    reject_inefficient_requests: None,
                    report_permission_errors: None,
                    return_efficiency_info: None,
                    revision_id: None,
                    sources: None,
                    supports_all_drives: None,
                    supports_team_drives: None,
                    sync_type: None,
                    update_viewed_date: None,
                    use_domain_admin_access: None,
                    use_legacy_domain_permission_behavior: None,
                }
            }
            #[doc = "Insert a new file."]
            pub fn insert(&self, request: crate::schemas::File) -> InsertRequestBuilder<A> {
                InsertRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    request,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    convert: None,
                    error_recovery: None,
                    feature_label: None,
                    include_metadata_for_categories: None,
                    include_permissions_for_view: None,
                    mutation_precondition: None,
                    ocr: None,
                    ocr_language: None,
                    open_drive: None,
                    pinned: None,
                    reason: None,
                    storage_policy: None,
                    supports_all_drives: None,
                    supports_team_drives: None,
                    sync_type: None,
                    timed_text_language: None,
                    timed_text_track_name: None,
                    update_viewed_date: None,
                    use_content_as_indexable_text: None,
                    use_legacy_domain_permission_behavior: None,
                    visibility: None,
                }
            }
            #[doc = "Lists the user's files."]
            pub fn list(&self) -> ListRequestBuilder<A> {
                ListRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    all_properties: None,
                    app_data_filter: None,
                    corpora: None,
                    corpus: None,
                    drive_id: None,
                    embed_origin: None,
                    error_recovery: None,
                    feature_label: None,
                    file_scope_app_ids: None,
                    include_embeds: None,
                    include_items_from_all_drives: None,
                    include_metadata_for_categories: None,
                    include_permissions_for_view: None,
                    include_team_drive_items: None,
                    include_unsubscribed: None,
                    max_results: None,
                    mutation_precondition: None,
                    open_drive: None,
                    order_by: None,
                    page_token: None,
                    projection: None,
                    q: None,
                    raw_user_query: None,
                    reason: None,
                    reject_inefficient_requests: None,
                    return_efficiency_info: None,
                    reverse_sort: None,
                    search_session_data: None,
                    secondary_sort_by: None,
                    sort_by: None,
                    sources: None,
                    spaces: None,
                    supports_all_drives: None,
                    supports_team_drives: None,
                    sync_type: None,
                    team_drive_id: None,
                    use_legacy_domain_permission_behavior: None,
                }
            }
            #[doc = "Lists a category metadata on a file."]
            pub fn list_category_metadata(
                &self,
                file_id: impl Into<String>,
            ) -> ListCategoryMetadataRequestBuilder<A> {
                ListCategoryMetadataRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    file_id: file_id.into(),
                    max_results: None,
                    page_token: None,
                }
            }
            #[doc = "Verifies if migrating a set of files & folders into a shared drive can succeed without errors. The result is a best effort check on a potential migration."]
            pub fn migrate_to_drive_pre_flight(
                &self,
                request: crate::schemas::MigrateToDrivePreFlightRequest,
            ) -> MigrateToDrivePreFlightRequestBuilder<A> {
                MigrateToDrivePreFlightRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    request,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    error_recovery: None,
                    feature_label: None,
                    mutation_precondition: None,
                    open_drive: None,
                    reason: None,
                    sync_type: None,
                }
            }
            #[doc = "Verifies if migrating a set of files & folders into a Team Drive can succeed without errors. The result is a best effort check on a potential migration."]
            pub fn migrate_to_team_drive_pre_flight(
                &self,
                request: crate::schemas::MigrateToTeamDrivePreFlightRequest,
            ) -> MigrateToTeamDrivePreFlightRequestBuilder<A> {
                MigrateToTeamDrivePreFlightRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    request,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    error_recovery: None,
                    feature_label: None,
                    mutation_precondition: None,
                    open_drive: None,
                    reason: None,
                    sync_type: None,
                }
            }
            #[doc = "Updates file metadata and/or content. This method supports patch semantics."]
            pub fn patch(
                &self,
                request: crate::schemas::File,
                file_id: impl Into<String>,
            ) -> PatchRequestBuilder<A> {
                PatchRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    request,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    file_id: file_id.into(),
                    add_parents: None,
                    base_revision: None,
                    confirmed: None,
                    convert: None,
                    error_recovery: None,
                    expected_parent_ids: None,
                    feature_label: None,
                    include_metadata_for_categories: None,
                    include_permissions_for_view: None,
                    language_code: None,
                    modified_date_behavior: None,
                    mutation_precondition: None,
                    new_revision: None,
                    ocr: None,
                    ocr_language: None,
                    open_drive: None,
                    pinned: None,
                    precondition: None,
                    reason: None,
                    remove_parents: None,
                    set_modified_date: None,
                    storage_policy: None,
                    supports_all_drives: None,
                    supports_team_drives: None,
                    sync_type: None,
                    timed_text_language: None,
                    timed_text_track_name: None,
                    update_viewed_date: None,
                    use_content_as_indexable_text: None,
                    use_domain_admin_access: None,
                    use_legacy_domain_permission_behavior: None,
                }
            }
            #[doc = "Generate a preview for an archive file. Currently supports RAR, TAR/BZ2, TAR/GZIP, and ZIP files."]
            pub fn preview(&self, file_id: impl Into<String>) -> PreviewRequestBuilder<A> {
                PreviewRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    file_id: file_id.into(),
                    file_name: None,
                    file_size: None,
                    mime_type: None,
                    origin: None,
                    quota_bytes: None,
                }
            }
            #[doc = "If user owns the file, trashes it; else if parentId is provided, removes the file from that folder; otherwise, unsubscribes the user. This method is unsupported for shared drive files."]
            pub fn remove(&self, file_id: impl Into<String>) -> RemoveRequestBuilder<A> {
                RemoveRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    file_id: file_id.into(),
                    error_recovery: None,
                    feature_label: None,
                    include_metadata_for_categories: None,
                    include_permissions_for_view: None,
                    mutation_precondition: None,
                    open_drive: None,
                    parent_id: None,
                    reason: None,
                    sync_type: None,
                    use_legacy_domain_permission_behavior: None,
                }
            }
            #[doc = "Deprecated - use drive.files.sendAccessRequest."]
            pub fn request_access(
                &self,
                file_id: impl Into<String>,
            ) -> RequestAccessRequestBuilder<A> {
                RequestAccessRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    file_id: file_id.into(),
                    email_message: None,
                }
            }
            #[doc = "Requests access to the file for the current user or a list of recipients. A notification is sent to the owner of the file requesting that they share the file with the requesting user or a list of recipients."]
            pub fn send_access_request(
                &self,
                request: crate::schemas::SendAccessRequest,
                file_id: impl Into<String>,
            ) -> SendAccessRequestRequestBuilder<A> {
                SendAccessRequestRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    request,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    file_id: file_id.into(),
                }
            }
            #[doc = "Sends a sharing notification message to one or more users."]
            pub fn send_share_notification(
                &self,
                request: crate::schemas::ShareNotificationRequest,
                file_id: impl Into<String>,
            ) -> SendShareNotificationRequestBuilder<A> {
                SendShareNotificationRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    request,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    file_id: file_id.into(),
                    language_code: None,
                }
            }
            #[doc = "Syncs a photo into Google Drive. If the photo already exists in Google Drive, returns the existing File. Otherwise, it syncs the photo and returns the newly synced file."]
            pub fn sync_photo_with_sha_1(
                &self,
                request: crate::schemas::SyncPhotoWithSha1Request,
            ) -> SyncPhotoWithSha1RequestBuilder<A> {
                SyncPhotoWithSha1RequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    request,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    error_recovery: None,
                    feature_label: None,
                    include_metadata_for_categories: None,
                    mutation_precondition: None,
                    open_drive: None,
                    reason: None,
                    sync_type: None,
                    use_legacy_domain_permission_behavior: None,
                }
            }
            #[doc = "Set the file's updated time to the current server time."]
            pub fn touch(&self, file_id: impl Into<String>) -> TouchRequestBuilder<A> {
                TouchRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    file_id: file_id.into(),
                    error_recovery: None,
                    feature_label: None,
                    include_metadata_for_categories: None,
                    include_permissions_for_view: None,
                    mutation_precondition: None,
                    open_drive: None,
                    reason: None,
                    supports_all_drives: None,
                    supports_team_drives: None,
                    sync_type: None,
                    use_legacy_domain_permission_behavior: None,
                }
            }
            #[doc = "Moves a file to the trash. The currently authenticated user must own the file or be at least a fileOrganizer on the parent for shared drive files."]
            pub fn trash(&self, file_id: impl Into<String>) -> TrashRequestBuilder<A> {
                TrashRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    file_id: file_id.into(),
                    error_recovery: None,
                    feature_label: None,
                    include_metadata_for_categories: None,
                    include_permissions_for_view: None,
                    mutation_precondition: None,
                    open_drive: None,
                    reason: None,
                    supports_all_drives: None,
                    supports_team_drives: None,
                    sync_type: None,
                    use_legacy_domain_permission_behavior: None,
                }
            }
            #[doc = "Restores a file from the trash."]
            pub fn untrash(&self, file_id: impl Into<String>) -> UntrashRequestBuilder<A> {
                UntrashRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    file_id: file_id.into(),
                    error_recovery: None,
                    feature_label: None,
                    include_metadata_for_categories: None,
                    include_permissions_for_view: None,
                    mutation_precondition: None,
                    open_drive: None,
                    reason: None,
                    supports_all_drives: None,
                    supports_team_drives: None,
                    sync_type: None,
                    use_legacy_domain_permission_behavior: None,
                }
            }
            #[doc = "Updates file metadata and/or content."]
            pub fn update(
                &self,
                request: crate::schemas::File,
                file_id: impl Into<String>,
            ) -> UpdateRequestBuilder<A> {
                UpdateRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    request,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    file_id: file_id.into(),
                    add_parents: None,
                    add_workspaces: None,
                    base_revision: None,
                    confirmed: None,
                    convert: None,
                    error_recovery: None,
                    expected_parent_ids: None,
                    feature_label: None,
                    include_metadata_for_categories: None,
                    include_permissions_for_view: None,
                    language_code: None,
                    modified_date_behavior: None,
                    mutation_precondition: None,
                    new_revision: None,
                    ocr: None,
                    ocr_language: None,
                    open_drive: None,
                    pinned: None,
                    precondition: None,
                    reason: None,
                    remove_parents: None,
                    remove_workspaces: None,
                    set_modified_date: None,
                    storage_policy: None,
                    supports_all_drives: None,
                    supports_team_drives: None,
                    sync_type: None,
                    timed_text_language: None,
                    timed_text_track_name: None,
                    update_viewed_date: None,
                    use_content_as_indexable_text: None,
                    use_domain_admin_access: None,
                    use_legacy_domain_permission_behavior: None,
                }
            }
            #[doc = "Updates Category Metadata applied to a file. Returns Category Metadata for the Categories that were updated by the request."]
            pub fn update_category_metadata(
                &self,
                request: crate::schemas::UpdateCategoryMetadata,
                file_id: impl Into<String>,
            ) -> UpdateCategoryMetadataRequestBuilder<A> {
                UpdateCategoryMetadataRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    request,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    file_id: file_id.into(),
                }
            }
            #[doc = "Subscribe to changes on a file"]
            pub fn watch(
                &self,
                request: crate::schemas::Channel,
                file_id: impl Into<String>,
            ) -> WatchRequestBuilder<A> {
                WatchRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    request,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    file_id: file_id.into(),
                    acknowledge_abuse: None,
                    all_properties: None,
                    embed_origin: None,
                    error_recovery: None,
                    expected_parent_ids: None,
                    feature_label: None,
                    file_scope_app_ids: None,
                    include_metadata_for_categories: None,
                    include_permissions_for_view: None,
                    mutation_precondition: None,
                    open_drive: None,
                    projection: None,
                    reason: None,
                    reject_inefficient_requests: None,
                    report_permission_errors: None,
                    return_efficiency_info: None,
                    revision_id: None,
                    sources: None,
                    supports_all_drives: None,
                    supports_team_drives: None,
                    sync_type: None,
                    update_viewed_date: None,
                    use_domain_admin_access: None,
                    use_legacy_domain_permission_behavior: None,
                }
            }
        }
        #[derive(Debug, Clone)]
        pub struct AuthorizeRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            file_id: String,
            app_id: String,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            include_metadata_for_categories: Option<String>,
            include_permissions_for_view: Option<String>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            reason: Option<String>,
            supports_all_drives: Option<bool>,
            supports_team_drives: Option<bool>,
            sync_type: Option<i32>,
            use_legacy_domain_permission_behavior: Option<bool>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> AuthorizeRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "A comma-separated list of names of Categories to include in the response."]
            pub fn include_metadata_for_categories(mut self, value: impl Into<String>) -> Self {
                self.include_metadata_for_categories = Some(value.into());
                self
            }
            #[doc = "Specifies which additional view's permissions to include in the response. Only 'published' is supported."]
            pub fn include_permissions_for_view(mut self, value: impl Into<String>) -> Self {
                self.include_permissions_for_view = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Deprecated - Whether the requesting application supports both My Drives and shared drives. This parameter will only be effective until June 1, 2020. Afterwards all applications are assumed to support shared drives."]
            pub fn supports_all_drives(mut self, value: bool) -> Self {
                self.supports_all_drives = Some(value);
                self
            }
            #[doc = "Deprecated use supportsAllDrives instead."]
            pub fn supports_team_drives(mut self, value: bool) -> Self {
                self.supports_team_drives = Some(value);
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "If true, Permissions with type Audience are represented with Domain type."]
            pub fn use_legacy_domain_permission_behavior(mut self, value: bool) -> Self {
                self.use_legacy_domain_permission_behavior = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::File, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::File, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files/");
                {
                    let var_as_str = &self.file_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/authorize");
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::POST, path);
                let req = req.query(&[("appId", &self.app_id)]);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[(
                    "includeMetadataForCategories",
                    &self.include_metadata_for_categories,
                )]);
                let req = req.query(&[(
                    "includePermissionsForView",
                    &self.include_permissions_for_view,
                )]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("supportsAllDrives", &self.supports_all_drives)]);
                let req = req.query(&[("supportsTeamDrives", &self.supports_team_drives)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[(
                    "useLegacyDomainPermissionBehavior",
                    &self.use_legacy_domain_permission_behavior,
                )]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct CheckPermissionsRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            request: crate::schemas::CheckPermissionsRequest,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> CheckPermissionsRequestBuilder<'a, A> {
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::CheckPermissionsResponse, Box<dyn ::std::error::Error>>
            {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::CheckPermissionsResponse, Box<dyn ::std::error::Error>>
            {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                let req = req.json(&self.request);
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files/checkPermissions");
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::POST, path);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct CopyRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            request: crate::schemas::File,
            file_id: String,
            convert: Option<bool>,
            convert_to: Option<String>,
            copy_comments: Option<bool>,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            include_metadata_for_categories: Option<String>,
            include_permissions_for_view: Option<String>,
            mutation_precondition: Option<bool>,
            ocr: Option<bool>,
            ocr_language: Option<String>,
            open_drive: Option<bool>,
            pinned: Option<bool>,
            reason: Option<String>,
            revision_id: Option<String>,
            supports_all_drives: Option<bool>,
            supports_team_drives: Option<bool>,
            sync_type: Option<i32>,
            timed_text_language: Option<String>,
            timed_text_track_name: Option<String>,
            update_viewed_date: Option<bool>,
            use_legacy_domain_permission_behavior: Option<bool>,
            visibility: Option<crate::resources::files::params::CopyVisibility>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> CopyRequestBuilder<'a, A> {
            #[doc = "Whether to convert this file to the corresponding Google Docs format."]
            pub fn convert(mut self, value: bool) -> Self {
                self.convert = Some(value);
                self
            }
            #[doc = "If set, requests conversion to the given format. For native Google Docs, valid values are any of the targets in the exportFormats field of the about.get response."]
            pub fn convert_to(mut self, value: impl Into<String>) -> Self {
                self.convert_to = Some(value.into());
                self
            }
            #[doc = "Whether to also copy file comments. Only supported for Google Docs files."]
            pub fn copy_comments(mut self, value: bool) -> Self {
                self.copy_comments = Some(value);
                self
            }
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "A comma-separated list of names of Categories to include in the response."]
            pub fn include_metadata_for_categories(mut self, value: impl Into<String>) -> Self {
                self.include_metadata_for_categories = Some(value.into());
                self
            }
            #[doc = "Specifies which additional view's permissions to include in the response. Only 'published' is supported."]
            pub fn include_permissions_for_view(mut self, value: impl Into<String>) -> Self {
                self.include_permissions_for_view = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether to attempt OCR on .jpg, .png, .gif, or .pdf uploads."]
            pub fn ocr(mut self, value: bool) -> Self {
                self.ocr = Some(value);
                self
            }
            #[doc = "If ocr is true, hints at the language to use. Valid values are ISO 639-1 codes."]
            pub fn ocr_language(mut self, value: impl Into<String>) -> Self {
                self.ocr_language = Some(value.into());
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "Whether to pin the head revision of the new copy."]
            pub fn pinned(mut self, value: bool) -> Self {
                self.pinned = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "The ID of the revision to copy. Only allowed for files with content stored in Google Drive when conversion is not requested. Two revisions of the same file cannot be copied in a single batch request."]
            pub fn revision_id(mut self, value: impl Into<String>) -> Self {
                self.revision_id = Some(value.into());
                self
            }
            #[doc = "Deprecated - Whether the requesting application supports both My Drives and shared drives. This parameter will only be effective until June 1, 2020. Afterwards all applications are assumed to support shared drives."]
            pub fn supports_all_drives(mut self, value: bool) -> Self {
                self.supports_all_drives = Some(value);
                self
            }
            #[doc = "Deprecated use supportsAllDrives instead."]
            pub fn supports_team_drives(mut self, value: bool) -> Self {
                self.supports_team_drives = Some(value);
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "The language of the timed text."]
            pub fn timed_text_language(mut self, value: impl Into<String>) -> Self {
                self.timed_text_language = Some(value.into());
                self
            }
            #[doc = "The timed text track name."]
            pub fn timed_text_track_name(mut self, value: impl Into<String>) -> Self {
                self.timed_text_track_name = Some(value.into());
                self
            }
            #[doc = "Whether to update the view date on the copied file."]
            pub fn update_viewed_date(mut self, value: bool) -> Self {
                self.update_viewed_date = Some(value);
                self
            }
            #[doc = "If true, Permissions with type Audience are represented with Domain type."]
            pub fn use_legacy_domain_permission_behavior(mut self, value: bool) -> Self {
                self.use_legacy_domain_permission_behavior = Some(value);
                self
            }
            #[doc = "The visibility of the new file. This parameter is only relevant when the source is not a native Google Doc and convert=false."]
            pub fn visibility(
                mut self,
                value: crate::resources::files::params::CopyVisibility,
            ) -> Self {
                self.visibility = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::File, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::File, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                let req = req.json(&self.request);
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files/");
                {
                    let var_as_str = &self.file_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/copy");
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::POST, path);
                let req = req.query(&[("convert", &self.convert)]);
                let req = req.query(&[("convertTo", &self.convert_to)]);
                let req = req.query(&[("copyComments", &self.copy_comments)]);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[(
                    "includeMetadataForCategories",
                    &self.include_metadata_for_categories,
                )]);
                let req = req.query(&[(
                    "includePermissionsForView",
                    &self.include_permissions_for_view,
                )]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("ocr", &self.ocr)]);
                let req = req.query(&[("ocrLanguage", &self.ocr_language)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("pinned", &self.pinned)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("revisionId", &self.revision_id)]);
                let req = req.query(&[("supportsAllDrives", &self.supports_all_drives)]);
                let req = req.query(&[("supportsTeamDrives", &self.supports_team_drives)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("timedTextLanguage", &self.timed_text_language)]);
                let req = req.query(&[("timedTextTrackName", &self.timed_text_track_name)]);
                let req = req.query(&[("updateViewedDate", &self.update_viewed_date)]);
                let req = req.query(&[(
                    "useLegacyDomainPermissionBehavior",
                    &self.use_legacy_domain_permission_behavior,
                )]);
                let req = req.query(&[("visibility", &self.visibility)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct DeauthorizeRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            file_id: String,
            app_id: String,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            include_metadata_for_categories: Option<String>,
            include_permissions_for_view: Option<String>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            reason: Option<String>,
            supports_all_drives: Option<bool>,
            supports_team_drives: Option<bool>,
            sync_type: Option<i32>,
            use_legacy_domain_permission_behavior: Option<bool>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> DeauthorizeRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "A comma-separated list of names of Categories to include in the response."]
            pub fn include_metadata_for_categories(mut self, value: impl Into<String>) -> Self {
                self.include_metadata_for_categories = Some(value.into());
                self
            }
            #[doc = "Specifies which additional view's permissions to include in the response. Only 'published' is supported."]
            pub fn include_permissions_for_view(mut self, value: impl Into<String>) -> Self {
                self.include_permissions_for_view = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Deprecated - Whether the requesting application supports both My Drives and shared drives. This parameter will only be effective until June 1, 2020. Afterwards all applications are assumed to support shared drives."]
            pub fn supports_all_drives(mut self, value: bool) -> Self {
                self.supports_all_drives = Some(value);
                self
            }
            #[doc = "Deprecated use supportsAllDrives instead."]
            pub fn supports_team_drives(mut self, value: bool) -> Self {
                self.supports_team_drives = Some(value);
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "If true, Permissions with type Audience are represented with Domain type."]
            pub fn use_legacy_domain_permission_behavior(mut self, value: bool) -> Self {
                self.use_legacy_domain_permission_behavior = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::File, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::File, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files/");
                {
                    let var_as_str = &self.file_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/deauthorize");
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::POST, path);
                let req = req.query(&[("appId", &self.app_id)]);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[(
                    "includeMetadataForCategories",
                    &self.include_metadata_for_categories,
                )]);
                let req = req.query(&[(
                    "includePermissionsForView",
                    &self.include_permissions_for_view,
                )]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("supportsAllDrives", &self.supports_all_drives)]);
                let req = req.query(&[("supportsTeamDrives", &self.supports_team_drives)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[(
                    "useLegacyDomainPermissionBehavior",
                    &self.use_legacy_domain_permission_behavior,
                )]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct DeleteRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            file_id: String,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            reason: Option<String>,
            supports_all_drives: Option<bool>,
            supports_team_drives: Option<bool>,
            sync_type: Option<i32>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> DeleteRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Deprecated - Whether the requesting application supports both My Drives and shared drives. This parameter will only be effective until June 1, 2020. Afterwards all applications are assumed to support shared drives."]
            pub fn supports_all_drives(mut self, value: bool) -> Self {
                self.supports_all_drives = Some(value);
                self
            }
            #[doc = "Deprecated use supportsAllDrives instead."]
            pub fn supports_team_drives(mut self, value: bool) -> Self {
                self.supports_team_drives = Some(value);
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            pub fn execute(self) -> Result<(), Box<dyn ::std::error::Error>> {
                let req = self._request(&self._path());
                req.send()?.error_for_status()?;
                Ok(())
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files/");
                {
                    let var_as_str = &self.file_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::DELETE, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("supportsAllDrives", &self.supports_all_drives)]);
                let req = req.query(&[("supportsTeamDrives", &self.supports_team_drives)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct EmptyTrashRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            reason: Option<String>,
            sync_type: Option<i32>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> EmptyTrashRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            pub fn execute(self) -> Result<(), Box<dyn ::std::error::Error>> {
                let req = self._request(&self._path());
                req.send()?.error_for_status()?;
                Ok(())
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files/trash");
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::DELETE, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct ExportRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            file_id: String,
            mime_type: String,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> ExportRequestBuilder<'a, A> {
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            fn _download_path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/download/".to_owned();
                output.push_str("files/");
                {
                    let var_as_str = &self.file_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/export");
                output
            }
            pub fn download<W>(
                mut self,
                output: &mut W,
            ) -> Result<u64, Box<dyn ::std::error::Error>>
            where
                W: ::std::io::Write + ?Sized,
            {
                self.alt = Some(crate::params::Alt::Media);
                Ok(self
                    ._request(&self._path())
                    .send()?
                    .error_for_status()?
                    .copy_to(output)?)
            }
            pub fn execute(self) -> Result<(), Box<dyn ::std::error::Error>> {
                let req = self._request(&self._path());
                req.send()?.error_for_status()?;
                Ok(())
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files/");
                {
                    let var_as_str = &self.file_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/export");
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::GET, path);
                let req = req.query(&[("mimeType", &self.mime_type)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive.readonly"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct ExtractRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            file_id: String,
            destination_location_id: Option<String>,
            file_name: Option<String>,
            mime_type: Option<String>,
            origin: Option<crate::resources::files::params::ExtractOrigin>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> ExtractRequestBuilder<'a, A> {
            #[doc = "The ID of the folder to extract the contents of the archive into."]
            pub fn destination_location_id(mut self, value: impl Into<String>) -> Self {
                self.destination_location_id = Some(value.into());
                self
            }
            #[doc = "The name of the archive file to be extracted. Required when origin is GMAIL"]
            pub fn file_name(mut self, value: impl Into<String>) -> Self {
                self.file_name = Some(value.into());
                self
            }
            #[doc = "The mime type of the archive file to be extracted. Required when origin is GMAIL"]
            pub fn mime_type(mut self, value: impl Into<String>) -> Self {
                self.mime_type = Some(value.into());
                self
            }
            #[doc = "The origin of the file preview request."]
            pub fn origin(mut self, value: crate::resources::files::params::ExtractOrigin) -> Self {
                self.origin = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::ArchiveExtractionJob, Box<dyn ::std::error::Error>>
            {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::ArchiveExtractionJob, Box<dyn ::std::error::Error>>
            {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files/");
                {
                    let var_as_str = &self.file_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/extract");
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::POST, path);
                let req = req.query(&[("destinationLocationId", &self.destination_location_id)]);
                let req = req.query(&[("fileName", &self.file_name)]);
                let req = req.query(&[("mimeType", &self.mime_type)]);
                let req = req.query(&[("origin", &self.origin)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct ExtractcancelRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            job_id: String,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> ExtractcancelRequestBuilder<'a, A> {
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            pub fn execute(self) -> Result<(), Box<dyn ::std::error::Error>> {
                let req = self._request(&self._path());
                req.send()?.error_for_status()?;
                Ok(())
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("extractionJobs/");
                {
                    let var_as_str = &self.job_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::DELETE, path);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct ExtractstatusRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            job_id: String,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> ExtractstatusRequestBuilder<'a, A> {
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::ArchiveExtractionJob, Box<dyn ::std::error::Error>>
            {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::ArchiveExtractionJob, Box<dyn ::std::error::Error>>
            {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("extractionJobs/");
                {
                    let var_as_str = &self.job_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::GET, path);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct FixPermissionsRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            request: crate::schemas::FixPermissionsRequest,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> FixPermissionsRequestBuilder<'a, A> {
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            pub fn execute(self) -> Result<(), Box<dyn ::std::error::Error>> {
                let req = self._request(&self._path());
                let req = req.json(&self.request);
                req.send()?.error_for_status()?;
                Ok(())
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files/fixPermissions");
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::POST, path);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct GenerateIdRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            request: crate::schemas::File,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            reason: Option<String>,
            sync_type: Option<i32>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> GenerateIdRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::File, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::File, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                let req = req.json(&self.request);
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files/generateId");
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::POST, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct GenerateIdsRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            max_results: Option<i32>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            r#type: Option<String>,
            reason: Option<String>,
            space: Option<String>,
            sync_type: Option<i32>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> GenerateIdsRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "Maximum number of IDs to return."]
            pub fn max_results(mut self, value: i32) -> Self {
                self.max_results = Some(value);
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The type of items which the IDs can be used for. Supported values are 'files' and 'shortcuts'. Note that 'shortcuts' are only supported in the drive 'space'."]
            pub fn r#type(mut self, value: impl Into<String>) -> Self {
                self.r#type = Some(value.into());
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "The space in which the IDs can be used to create new items. Supported values are 'drive' and 'appDataFolder'."]
            pub fn space(mut self, value: impl Into<String>) -> Self {
                self.space = Some(value.into());
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::GeneratedIds, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::GeneratedIds, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files/generateIds");
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::GET, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("maxResults", &self.max_results)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("type", &self.r#type)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("space", &self.space)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct GetRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            file_id: String,
            acknowledge_abuse: Option<bool>,
            all_properties: Option<bool>,
            embed_origin: Option<String>,
            error_recovery: Option<bool>,
            expected_parent_ids: Option<String>,
            feature_label: Option<String>,
            file_scope_app_ids: Option<String>,
            include_metadata_for_categories: Option<String>,
            include_permissions_for_view: Option<String>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            projection: Option<crate::resources::files::params::GetProjection>,
            reason: Option<String>,
            reject_inefficient_requests: Option<bool>,
            report_permission_errors: Option<bool>,
            return_efficiency_info: Option<bool>,
            revision_id: Option<String>,
            sources: Option<String>,
            supports_all_drives: Option<bool>,
            supports_team_drives: Option<bool>,
            sync_type: Option<i32>,
            update_viewed_date: Option<bool>,
            use_domain_admin_access: Option<bool>,
            use_legacy_domain_permission_behavior: Option<bool>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> GetRequestBuilder<'a, A> {
            #[doc = "Whether the user is acknowledging the risk of downloading known malware or other abusive files."]
            pub fn acknowledge_abuse(mut self, value: bool) -> Self {
                self.acknowledge_abuse = Some(value);
                self
            }
            #[doc = "Whether to retrieve all properties, not just those visible to the app."]
            pub fn all_properties(mut self, value: bool) -> Self {
                self.all_properties = Some(value);
                self
            }
            #[doc = "The origin in which the sharing widget will be embedded. This should be supplied when requesting the shareLink field."]
            pub fn embed_origin(mut self, value: impl Into<String>) -> Self {
                self.embed_origin = Some(value.into());
                self
            }
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "A comma-separated list of parent IDs that have already been discovered by the requesting user. Parent filtering is prevented for parents on this list."]
            pub fn expected_parent_ids(mut self, value: impl Into<String>) -> Self {
                self.expected_parent_ids = Some(value.into());
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "DEPRECATED; not needed. A comma separated list of app IDs. If set the result will only include a file inside the app data folder if it could be opened by any of the specified app IDs with the drive.appdata scope. Requires the ALL_APPDATA scope."]
            pub fn file_scope_app_ids(mut self, value: impl Into<String>) -> Self {
                self.file_scope_app_ids = Some(value.into());
                self
            }
            #[doc = "A comma-separated list of names of Categories to include in the response."]
            pub fn include_metadata_for_categories(mut self, value: impl Into<String>) -> Self {
                self.include_metadata_for_categories = Some(value.into());
                self
            }
            #[doc = "Specifies which additional view's permissions to include in the response. Only 'published' is supported."]
            pub fn include_permissions_for_view(mut self, value: impl Into<String>) -> Self {
                self.include_permissions_for_view = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "This parameter is deprecated and has no function."]
            pub fn projection(
                mut self,
                value: crate::resources::files::params::GetProjection,
            ) -> Self {
                self.projection = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request should be rejected if it would generate an inefficient query."]
            pub fn reject_inefficient_requests(mut self, value: bool) -> Self {
                self.reject_inefficient_requests = Some(value);
                self
            }
            #[doc = "Whether the request should return 403 instead 404 if the file exists but the user doesn't have read access. This option is not compatible with the deprecated updateViewedDate parameter. If set for any item in a batch, it will be set for all."]
            pub fn report_permission_errors(mut self, value: bool) -> Self {
                self.report_permission_errors = Some(value);
                self
            }
            #[doc = "Whether the request should return efficiency info."]
            pub fn return_efficiency_info(mut self, value: bool) -> Self {
                self.return_efficiency_info = Some(value);
                self
            }
            #[doc = "Specifies the Revision ID that should be downloaded. Ignored unless alt=media is specified."]
            pub fn revision_id(mut self, value: impl Into<String>) -> Self {
                self.revision_id = Some(value.into());
                self
            }
            #[doc = "Deprecated. This parameter is no longer necessary."]
            pub fn sources(mut self, value: impl Into<String>) -> Self {
                self.sources = Some(value.into());
                self
            }
            #[doc = "Deprecated - Whether the requesting application supports both My Drives and shared drives. This parameter will only be effective until June 1, 2020. Afterwards all applications are assumed to support shared drives."]
            pub fn supports_all_drives(mut self, value: bool) -> Self {
                self.supports_all_drives = Some(value);
                self
            }
            #[doc = "Deprecated - use supportsAllDrives instead."]
            pub fn supports_team_drives(mut self, value: bool) -> Self {
                self.supports_team_drives = Some(value);
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "Deprecated: Use files.update with modifiedDateBehavior=noChange, updateViewedDate=true and an empty request body."]
            pub fn update_viewed_date(mut self, value: bool) -> Self {
                self.update_viewed_date = Some(value);
                self
            }
            #[doc = "Issue the request as a domain administrator; if set to true, then the requester will be granted access if they are an administrator of the domain to which the item belongs."]
            pub fn use_domain_admin_access(mut self, value: bool) -> Self {
                self.use_domain_admin_access = Some(value);
                self
            }
            #[doc = "If true, Permissions with type Audience are represented with Domain type."]
            pub fn use_legacy_domain_permission_behavior(mut self, value: bool) -> Self {
                self.use_legacy_domain_permission_behavior = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            fn _download_path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/download/".to_owned();
                output.push_str("files/");
                {
                    let var_as_str = &self.file_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output
            }
            pub fn download<W>(
                mut self,
                output: &mut W,
            ) -> Result<u64, Box<dyn ::std::error::Error>>
            where
                W: ::std::io::Write + ?Sized,
            {
                self.alt = Some(crate::params::Alt::Media);
                Ok(self
                    ._request(&self._path())
                    .send()?
                    .error_for_status()?
                    .copy_to(output)?)
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::File, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::File, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files/");
                {
                    let var_as_str = &self.file_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::GET, path);
                let req = req.query(&[("acknowledgeAbuse", &self.acknowledge_abuse)]);
                let req = req.query(&[("allProperties", &self.all_properties)]);
                let req = req.query(&[("embedOrigin", &self.embed_origin)]);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("expectedParentIds", &self.expected_parent_ids)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("fileScopeAppIds", &self.file_scope_app_ids)]);
                let req = req.query(&[(
                    "includeMetadataForCategories",
                    &self.include_metadata_for_categories,
                )]);
                let req = req.query(&[(
                    "includePermissionsForView",
                    &self.include_permissions_for_view,
                )]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("projection", &self.projection)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[(
                    "rejectInefficientRequests",
                    &self.reject_inefficient_requests,
                )]);
                let req = req.query(&[("reportPermissionErrors", &self.report_permission_errors)]);
                let req = req.query(&[("returnEfficiencyInfo", &self.return_efficiency_info)]);
                let req = req.query(&[("revisionId", &self.revision_id)]);
                let req = req.query(&[("sources", &self.sources)]);
                let req = req.query(&[("supportsAllDrives", &self.supports_all_drives)]);
                let req = req.query(&[("supportsTeamDrives", &self.supports_team_drives)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("updateViewedDate", &self.update_viewed_date)]);
                let req = req.query(&[("useDomainAdminAccess", &self.use_domain_admin_access)]);
                let req = req.query(&[(
                    "useLegacyDomainPermissionBehavior",
                    &self.use_legacy_domain_permission_behavior,
                )]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec![
                    "https://www.googleapis.com/auth/drive.metadata.readonly",
                ]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct InsertRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            request: crate::schemas::File,
            convert: Option<bool>,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            include_metadata_for_categories: Option<String>,
            include_permissions_for_view: Option<String>,
            mutation_precondition: Option<bool>,
            ocr: Option<bool>,
            ocr_language: Option<String>,
            open_drive: Option<bool>,
            pinned: Option<bool>,
            reason: Option<String>,
            storage_policy: Option<String>,
            supports_all_drives: Option<bool>,
            supports_team_drives: Option<bool>,
            sync_type: Option<i32>,
            timed_text_language: Option<String>,
            timed_text_track_name: Option<String>,
            update_viewed_date: Option<bool>,
            use_content_as_indexable_text: Option<bool>,
            use_legacy_domain_permission_behavior: Option<bool>,
            visibility: Option<crate::resources::files::params::InsertVisibility>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> InsertRequestBuilder<'a, A> {
            #[doc = "Whether to convert this file to the corresponding Google Docs format."]
            pub fn convert(mut self, value: bool) -> Self {
                self.convert = Some(value);
                self
            }
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "A comma-separated list of names of Categories to include in the response."]
            pub fn include_metadata_for_categories(mut self, value: impl Into<String>) -> Self {
                self.include_metadata_for_categories = Some(value.into());
                self
            }
            #[doc = "Specifies which additional view's permissions to include in the response. Only 'published' is supported."]
            pub fn include_permissions_for_view(mut self, value: impl Into<String>) -> Self {
                self.include_permissions_for_view = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether to attempt OCR on .jpg, .png, .gif, or .pdf uploads."]
            pub fn ocr(mut self, value: bool) -> Self {
                self.ocr = Some(value);
                self
            }
            #[doc = "If ocr is true, hints at the language to use. Valid values are ISO 639-1 codes."]
            pub fn ocr_language(mut self, value: impl Into<String>) -> Self {
                self.ocr_language = Some(value.into());
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "Whether to pin the head revision of the uploaded file."]
            pub fn pinned(mut self, value: bool) -> Self {
                self.pinned = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "For eligible files (e.g. image and video) whether to store the data at original compressed high-quality resolution. Valid values are 'original' and 'highQuality'."]
            pub fn storage_policy(mut self, value: impl Into<String>) -> Self {
                self.storage_policy = Some(value.into());
                self
            }
            #[doc = "Deprecated - Whether the requesting application supports both My Drives and shared drives. This parameter will only be effective until June 1, 2020. Afterwards all applications are assumed to support shared drives."]
            pub fn supports_all_drives(mut self, value: bool) -> Self {
                self.supports_all_drives = Some(value);
                self
            }
            #[doc = "Deprecated use supportsAllDrives instead."]
            pub fn supports_team_drives(mut self, value: bool) -> Self {
                self.supports_team_drives = Some(value);
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "The language of the timed text."]
            pub fn timed_text_language(mut self, value: impl Into<String>) -> Self {
                self.timed_text_language = Some(value.into());
                self
            }
            #[doc = "The timed text track name."]
            pub fn timed_text_track_name(mut self, value: impl Into<String>) -> Self {
                self.timed_text_track_name = Some(value.into());
                self
            }
            #[doc = "Whether to update the view date when inserting the file."]
            pub fn update_viewed_date(mut self, value: bool) -> Self {
                self.update_viewed_date = Some(value);
                self
            }
            #[doc = "Whether to use the content as indexable text."]
            pub fn use_content_as_indexable_text(mut self, value: bool) -> Self {
                self.use_content_as_indexable_text = Some(value);
                self
            }
            #[doc = "If true, Permissions with type Audience are represented with Domain type."]
            pub fn use_legacy_domain_permission_behavior(mut self, value: bool) -> Self {
                self.use_legacy_domain_permission_behavior = Some(value);
                self
            }
            #[doc = "The visibility of the new file. This parameter is only relevant when convert=false."]
            pub fn visibility(
                mut self,
                value: crate::resources::files::params::InsertVisibility,
            ) -> Self {
                self.visibility = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            fn _simple_upload_path(&self) -> String {
                let mut output = "https://www.googleapis.com/".to_owned();
                output.push_str("upload/drive/v2.1beta/files");
                output
            }
            pub fn upload<T, R>(
                mut self,
                content: R,
                mime_type: ::mime::Mime,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
                R: ::std::io::Read + ::std::io::Seek + Send + 'static,
            {
                if self.fields.is_none() {
                    self.fields = Some(T::field_selector());
                }
                let req = self._request(&self._simple_upload_path());
                let req = req.query(&[("uploadType", "multipart")]);
                use crate::multipart::{Part, RelatedMultiPart};
                let mut multipart = RelatedMultiPart::new();
                let request_json = ::serde_json::to_vec(&self.request)?;
                multipart.new_part(Part::new(
                    ::mime::APPLICATION_JSON,
                    Box::new(::std::io::Cursor::new(request_json)),
                ));
                multipart.new_part(Part::new(mime_type, Box::new(content)));
                let req = req.header(
                    ::reqwest::header::CONTENT_TYPE,
                    format!("multipart/related; boundary={}", multipart.boundary()),
                );
                let req = req.body(reqwest::Body::new(multipart.into_reader()));
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _resumable_upload_path(&self) -> String {
                let mut output = "https://www.googleapis.com/".to_owned();
                output.push_str("resumable/upload/drive/v2.1beta/files");
                output
            }
            pub fn start_resumable_upload(
                self,
                mime_type: ::mime::Mime,
            ) -> Result<crate::ResumableUpload, Box<dyn ::std::error::Error>> {
                let req = self._request(&self._resumable_upload_path());
                let req = req.query(&[("uploadType", "resumable")]);
                let req = req.header(
                    ::reqwest::header::HeaderName::from_static("x-upload-content-type"),
                    mime_type.to_string(),
                );
                let req = req.json(&self.request);
                let resp = req.send()?.error_for_status()?;
                let location_header =
                    resp.headers()
                        .get(::reqwest::header::LOCATION)
                        .ok_or_else(|| {
                            format!("No LOCATION header returned when initiating resumable upload")
                        })?;
                let upload_url = ::std::str::from_utf8(location_header.as_bytes())?.to_owned();
                Ok(crate::ResumableUpload::new(
                    self.reqwest.clone(),
                    upload_url,
                ))
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::File, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::File, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                let req = req.json(&self.request);
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files");
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::POST, path);
                let req = req.query(&[("convert", &self.convert)]);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[(
                    "includeMetadataForCategories",
                    &self.include_metadata_for_categories,
                )]);
                let req = req.query(&[(
                    "includePermissionsForView",
                    &self.include_permissions_for_view,
                )]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("ocr", &self.ocr)]);
                let req = req.query(&[("ocrLanguage", &self.ocr_language)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("pinned", &self.pinned)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("storagePolicy", &self.storage_policy)]);
                let req = req.query(&[("supportsAllDrives", &self.supports_all_drives)]);
                let req = req.query(&[("supportsTeamDrives", &self.supports_team_drives)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("timedTextLanguage", &self.timed_text_language)]);
                let req = req.query(&[("timedTextTrackName", &self.timed_text_track_name)]);
                let req = req.query(&[("updateViewedDate", &self.update_viewed_date)]);
                let req = req.query(&[(
                    "useContentAsIndexableText",
                    &self.use_content_as_indexable_text,
                )]);
                let req = req.query(&[(
                    "useLegacyDomainPermissionBehavior",
                    &self.use_legacy_domain_permission_behavior,
                )]);
                let req = req.query(&[("visibility", &self.visibility)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct ListRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            all_properties: Option<bool>,
            app_data_filter: Option<crate::resources::files::params::ListAppDataFilter>,
            corpora: Option<String>,
            corpus: Option<crate::resources::files::params::ListCorpus>,
            drive_id: Option<String>,
            embed_origin: Option<String>,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            file_scope_app_ids: Option<String>,
            include_embeds: Option<bool>,
            include_items_from_all_drives: Option<bool>,
            include_metadata_for_categories: Option<String>,
            include_permissions_for_view: Option<String>,
            include_team_drive_items: Option<bool>,
            include_unsubscribed: Option<bool>,
            max_results: Option<i32>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            order_by: Option<String>,
            page_token: Option<String>,
            projection: Option<crate::resources::files::params::ListProjection>,
            q: Option<String>,
            raw_user_query: Option<String>,
            reason: Option<String>,
            reject_inefficient_requests: Option<bool>,
            return_efficiency_info: Option<bool>,
            reverse_sort: Option<bool>,
            search_session_data: Option<String>,
            secondary_sort_by: Option<String>,
            sort_by: Option<crate::resources::files::params::ListSortBy>,
            sources: Option<String>,
            spaces: Option<String>,
            supports_all_drives: Option<bool>,
            supports_team_drives: Option<bool>,
            sync_type: Option<i32>,
            team_drive_id: Option<String>,
            use_legacy_domain_permission_behavior: Option<bool>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> ListRequestBuilder<'a, A> {
            #[doc = "Whether to retrieve all properties, not just those visible to the app."]
            pub fn all_properties(mut self, value: bool) -> Self {
                self.all_properties = Some(value);
                self
            }
            #[doc = "Deprecated: use 'spaces' instead. Specifies whether to return App Data, non-App Data, or both in query results."]
            pub fn app_data_filter(
                mut self,
                value: crate::resources::files::params::ListAppDataFilter,
            ) -> Self {
                self.app_data_filter = Some(value);
                self
            }
            #[doc = "Bodies of items (files/documents) to which the query applies. Supported bodies are 'default', 'domain', 'drive' and 'allDrives'. Prefer 'default' or 'drive' to 'allDrives' for efficiency."]
            pub fn corpora(mut self, value: impl Into<String>) -> Self {
                self.corpora = Some(value.into());
                self
            }
            #[doc = "The body of items (files/documents) to which the query applies. Deprecated: use 'corpora' instead."]
            pub fn corpus(mut self, value: crate::resources::files::params::ListCorpus) -> Self {
                self.corpus = Some(value);
                self
            }
            #[doc = "ID of shared drive to search."]
            pub fn drive_id(mut self, value: impl Into<String>) -> Self {
                self.drive_id = Some(value.into());
                self
            }
            #[doc = "The origin in which the sharing widget will be embedded. This should be supplied when requesting the shareLink field."]
            pub fn embed_origin(mut self, value: impl Into<String>) -> Self {
                self.embed_origin = Some(value.into());
                self
            }
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "A comma separated list of app IDs. If set, the list will also include files inside the app data folder that could be opened with any of the given apps with drive.appdata scope. Requires the ALL_APPDATA scope."]
            pub fn file_scope_app_ids(mut self, value: impl Into<String>) -> Self {
                self.file_scope_app_ids = Some(value.into());
                self
            }
            #[doc = "Whether to include items embedded in a package in the results."]
            pub fn include_embeds(mut self, value: bool) -> Self {
                self.include_embeds = Some(value);
                self
            }
            #[doc = "Deprecated - Whether both My Drive and shared drive items should be included in results. This parameter will only be effective until June 1, 2020. Afterwards shared drive items will be included in the results."]
            pub fn include_items_from_all_drives(mut self, value: bool) -> Self {
                self.include_items_from_all_drives = Some(value);
                self
            }
            #[doc = "A comma-separated list of names of Categories to include in the response."]
            pub fn include_metadata_for_categories(mut self, value: impl Into<String>) -> Self {
                self.include_metadata_for_categories = Some(value.into());
                self
            }
            #[doc = "Specifies which additional view's permissions to include in the response. Only 'published' is supported."]
            pub fn include_permissions_for_view(mut self, value: impl Into<String>) -> Self {
                self.include_permissions_for_view = Some(value.into());
                self
            }
            #[doc = "Deprecated use includeItemsFromAllDrives instead."]
            pub fn include_team_drive_items(mut self, value: bool) -> Self {
                self.include_team_drive_items = Some(value);
                self
            }
            #[doc = "For Cello, allow fetching unsubscribed children to complete backfill."]
            pub fn include_unsubscribed(mut self, value: bool) -> Self {
                self.include_unsubscribed = Some(value);
                self
            }
            #[doc = "The maximum number of files to return per page. Partial or empty result pages are possible even before the end of the files list has been reached."]
            pub fn max_results(mut self, value: i32) -> Self {
                self.max_results = Some(value);
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "A comma-separated list of sort keys. Valid keys are 'createdDate', 'folder', 'lastViewedByMeDate', 'modifiedByMeDate', 'modifiedDate', 'quotaBytesUsed', 'recursiveFileCount', 'recursiveFileSize', 'recursiveQuotaBytesUsed', 'recency', 'sharedWithMeDate', 'starred', 'title', 'title_natural', and 'trashedDate'. Each key sorts ascending by default, but may be reversed with the 'desc' modifier. Example usage: ?orderBy=folder,modifiedDate desc,title. Please note that there is a current limitation for users with approximately one million files in which the requested sort order is ignored."]
            pub fn order_by(mut self, value: impl Into<String>) -> Self {
                self.order_by = Some(value.into());
                self
            }
            #[doc = "Page token for files."]
            pub fn page_token(mut self, value: impl Into<String>) -> Self {
                self.page_token = Some(value.into());
                self
            }
            #[doc = "This parameter is deprecated and has no function."]
            pub fn projection(
                mut self,
                value: crate::resources::files::params::ListProjection,
            ) -> Self {
                self.projection = Some(value);
                self
            }
            #[doc = "Query string for searching files."]
            pub fn q(mut self, value: impl Into<String>) -> Self {
                self.q = Some(value.into());
                self
            }
            #[doc = "The unmodified user-specified query string."]
            pub fn raw_user_query(mut self, value: impl Into<String>) -> Self {
                self.raw_user_query = Some(value.into());
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request should be rejected if it would generate an inefficient query."]
            pub fn reject_inefficient_requests(mut self, value: bool) -> Self {
                self.reject_inefficient_requests = Some(value);
                self
            }
            #[doc = "Whether the request should return efficiency info."]
            pub fn return_efficiency_info(mut self, value: bool) -> Self {
                self.return_efficiency_info = Some(value);
                self
            }
            #[doc = "DEPRECATED; use orderBy instead. Whether to reverse the order of the results if sortBy is set."]
            pub fn reverse_sort(mut self, value: bool) -> Self {
                self.reverse_sort = Some(value);
                self
            }
            #[doc = "Opaque search session data from apps search quality."]
            pub fn search_session_data(mut self, value: impl Into<String>) -> Self {
                self.search_session_data = Some(value.into());
                self
            }
            #[doc = "DEPRECATED; use orderBy instead. The list of sort orders to apply after sortBy."]
            pub fn secondary_sort_by(mut self, value: impl Into<String>) -> Self {
                self.secondary_sort_by = Some(value.into());
                self
            }
            #[doc = "DEPRECATED; use orderBy instead. The sort order for returned files."]
            pub fn sort_by(mut self, value: crate::resources::files::params::ListSortBy) -> Self {
                self.sort_by = Some(value);
                self
            }
            #[doc = "Deprecated: use 'spaces' instead. A comma-separated list of sources to query. Supported values are 'GOOGLE_PHOTOS' and 'ANDROID_BACKUP'."]
            pub fn sources(mut self, value: impl Into<String>) -> Self {
                self.sources = Some(value.into());
                self
            }
            #[doc = "A comma-separated list of spaces to query. Supported values are 'drive', 'appContent', 'appDataFolder', 'photos' and 'androidBackup'."]
            pub fn spaces(mut self, value: impl Into<String>) -> Self {
                self.spaces = Some(value.into());
                self
            }
            #[doc = "Deprecated - Whether the requesting application supports both My Drives and shared drives. This parameter will only be effective until June 1, 2020. Afterwards all applications are assumed to support shared drives."]
            pub fn supports_all_drives(mut self, value: bool) -> Self {
                self.supports_all_drives = Some(value);
                self
            }
            #[doc = "Deprecated use supportsAllDrives instead."]
            pub fn supports_team_drives(mut self, value: bool) -> Self {
                self.supports_team_drives = Some(value);
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "Deprecated use driveId instead."]
            pub fn team_drive_id(mut self, value: impl Into<String>) -> Self {
                self.team_drive_id = Some(value.into());
                self
            }
            #[doc = "If true, Permissions with type Audience are represented with Domain type."]
            pub fn use_legacy_domain_permission_behavior(mut self, value: bool) -> Self {
                self.use_legacy_domain_permission_behavior = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Return an iterator that iterates over all `#prop_ident`. The"]
            #[doc = r" items yielded by the iterator are chosen by the caller of this"]
            #[doc = r" method and must implement `Deserialize` and `FieldSelector`. The"]
            #[doc = r" populated fields in the yielded items will be determined by the"]
            #[doc = r" `FieldSelector` implementation."]
            pub fn iter_items<T>(mut self) -> crate::iter::PageItemIter<Self, T>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let mut fields = concat!("nextPageToken,", "items").to_owned();
                let items_fields = T::field_selector();
                if !items_fields.is_empty() {
                    fields.push_str("(");
                    fields.push_str(&items_fields);
                    fields.push_str(")");
                }
                self.fields = Some(fields);
                crate::iter::PageItemIter::new(self, "items")
            }
            #[doc = r" Return an iterator that iterates over all `#prop_ident`. The"]
            #[doc = r" items yielded by the iterator are `#items_type`. The populated"]
            #[doc = r" fields in `#items_type` will be the default fields populated by"]
            #[doc = r" the server."]
            pub fn iter_items_standard(
                mut self,
            ) -> crate::iter::PageItemIter<Self, crate::schemas::File> {
                self.fields = Some(concat!("nextPageToken,", "items").to_owned());
                crate::iter::PageItemIter::new(self, "items")
            }
            #[doc = r" Return an iterator that iterates over all `#prop_ident`. The"]
            #[doc = r" items yielded by the iterator are `#items_type`. The populated"]
            #[doc = r" fields in `#items_type` will be all fields available. This should"]
            #[doc = r" primarily be used during developement and debugging as fetching"]
            #[doc = r" all fields can be expensive both in bandwidth and server"]
            #[doc = r" resources."]
            pub fn iter_items_debug(
                mut self,
            ) -> crate::iter::PageItemIter<Self, crate::schemas::File> {
                self.fields = Some(concat!("nextPageToken,", "items", "(*)").to_owned());
                crate::iter::PageItemIter::new(self, "items")
            }
            #[doc = r" Return an iterator that iterates over all `#prop_ident`. The"]
            #[doc = r" items yielded by the iterator are chosen by the caller of this"]
            #[doc = r" method and must implement `Deserialize` and `FieldSelector`. The"]
            #[doc = r" populated fields in the yielded items will be determined by the"]
            #[doc = r" `FieldSelector` implementation."]
            pub fn iter_suggested_nlp_queries<T>(mut self) -> crate::iter::PageItemIter<Self, T>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let mut fields = concat!("nextPageToken,", "suggestedNlpQueries").to_owned();
                let items_fields = T::field_selector();
                if !items_fields.is_empty() {
                    fields.push_str("(");
                    fields.push_str(&items_fields);
                    fields.push_str(")");
                }
                self.fields = Some(fields);
                crate::iter::PageItemIter::new(self, "suggestedNlpQueries")
            }
            #[doc = r" Return an iterator that iterates over all `#prop_ident`. The"]
            #[doc = r" items yielded by the iterator are `#items_type`. The populated"]
            #[doc = r" fields in `#items_type` will be the default fields populated by"]
            #[doc = r" the server."]
            pub fn iter_suggested_nlp_queries_standard(
                mut self,
            ) -> crate::iter::PageItemIter<Self, String> {
                self.fields = Some(concat!("nextPageToken,", "suggestedNlpQueries").to_owned());
                crate::iter::PageItemIter::new(self, "suggestedNlpQueries")
            }
            #[doc = r" Return an iterator that iterates over all `#prop_ident`. The"]
            #[doc = r" items yielded by the iterator are `#items_type`. The populated"]
            #[doc = r" fields in `#items_type` will be all fields available. This should"]
            #[doc = r" primarily be used during developement and debugging as fetching"]
            #[doc = r" all fields can be expensive both in bandwidth and server"]
            #[doc = r" resources."]
            pub fn iter_suggested_nlp_queries_debug(
                mut self,
            ) -> crate::iter::PageItemIter<Self, String> {
                self.fields =
                    Some(concat!("nextPageToken,", "suggestedNlpQueries", "(*)").to_owned());
                crate::iter::PageItemIter::new(self, "suggestedNlpQueries")
            }
            pub fn iter<T>(mut self) -> crate::iter::PageIter<Self, T>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let mut fields = T::field_selector();
                if !fields.is_empty() {
                    match fields.chars().rev().nth(0) {
                        Some(',') | None => {}
                        _ => fields.push_str(","),
                    }
                    fields.push_str("nextPageToken");
                    self.fields = Some(fields);
                }
                crate::iter::PageIter::new(self)
            }
            pub fn iter_standard(self) -> crate::iter::PageIter<Self, crate::schemas::FileList> {
                crate::iter::PageIter::new(self)
            }
            pub fn iter_debug(mut self) -> crate::iter::PageIter<Self, crate::schemas::FileList> {
                self.fields = Some("*".to_owned());
                crate::iter::PageIter::new(self)
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::FileList, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::FileList, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files");
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::GET, path);
                let req = req.query(&[("allProperties", &self.all_properties)]);
                let req = req.query(&[("appDataFilter", &self.app_data_filter)]);
                let req = req.query(&[("corpora", &self.corpora)]);
                let req = req.query(&[("corpus", &self.corpus)]);
                let req = req.query(&[("driveId", &self.drive_id)]);
                let req = req.query(&[("embedOrigin", &self.embed_origin)]);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("fileScopeAppIds", &self.file_scope_app_ids)]);
                let req = req.query(&[("includeEmbeds", &self.include_embeds)]);
                let req = req.query(&[(
                    "includeItemsFromAllDrives",
                    &self.include_items_from_all_drives,
                )]);
                let req = req.query(&[(
                    "includeMetadataForCategories",
                    &self.include_metadata_for_categories,
                )]);
                let req = req.query(&[(
                    "includePermissionsForView",
                    &self.include_permissions_for_view,
                )]);
                let req = req.query(&[("includeTeamDriveItems", &self.include_team_drive_items)]);
                let req = req.query(&[("includeUnsubscribed", &self.include_unsubscribed)]);
                let req = req.query(&[("maxResults", &self.max_results)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("orderBy", &self.order_by)]);
                let req = req.query(&[("pageToken", &self.page_token)]);
                let req = req.query(&[("projection", &self.projection)]);
                let req = req.query(&[("q", &self.q)]);
                let req = req.query(&[("rawUserQuery", &self.raw_user_query)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[(
                    "rejectInefficientRequests",
                    &self.reject_inefficient_requests,
                )]);
                let req = req.query(&[("returnEfficiencyInfo", &self.return_efficiency_info)]);
                let req = req.query(&[("reverseSort", &self.reverse_sort)]);
                let req = req.query(&[("searchSessionData", &self.search_session_data)]);
                let req = req.query(&[("secondarySortBy", &self.secondary_sort_by)]);
                let req = req.query(&[("sortBy", &self.sort_by)]);
                let req = req.query(&[("sources", &self.sources)]);
                let req = req.query(&[("spaces", &self.spaces)]);
                let req = req.query(&[("supportsAllDrives", &self.supports_all_drives)]);
                let req = req.query(&[("supportsTeamDrives", &self.supports_team_drives)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("teamDriveId", &self.team_drive_id)]);
                let req = req.query(&[(
                    "useLegacyDomainPermissionBehavior",
                    &self.use_legacy_domain_permission_behavior,
                )]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive.apps.readonly"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        impl<'a, A: yup_oauth2::GetToken> crate::iter::IterableMethod for ListRequestBuilder<'a, A> {
            fn set_page_token(&mut self, value: String) {
                self.page_token = value.into();
            }
            fn execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                self._execute()
            }
        }
        #[derive(Debug, Clone)]
        pub struct ListCategoryMetadataRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            file_id: String,
            max_results: Option<i32>,
            page_token: Option<String>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> ListCategoryMetadataRequestBuilder<'a, A> {
            #[doc = "The maximum number of categories to return per page. When not set, at most 100 results will be returned."]
            pub fn max_results(mut self, value: i32) -> Self {
                self.max_results = Some(value);
                self
            }
            #[doc = "The token for continuing a previous list request on the next page. This should be set to the value of 'nextPageToken' from the previous response."]
            pub fn page_token(mut self, value: impl Into<String>) -> Self {
                self.page_token = Some(value.into());
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Return an iterator that iterates over all `#prop_ident`. The"]
            #[doc = r" items yielded by the iterator are chosen by the caller of this"]
            #[doc = r" method and must implement `Deserialize` and `FieldSelector`. The"]
            #[doc = r" populated fields in the yielded items will be determined by the"]
            #[doc = r" `FieldSelector` implementation."]
            pub fn iter_items<T>(mut self) -> crate::iter::PageItemIter<Self, T>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let mut fields = concat!("nextPageToken,", "items").to_owned();
                let items_fields = T::field_selector();
                if !items_fields.is_empty() {
                    fields.push_str("(");
                    fields.push_str(&items_fields);
                    fields.push_str(")");
                }
                self.fields = Some(fields);
                crate::iter::PageItemIter::new(self, "items")
            }
            #[doc = r" Return an iterator that iterates over all `#prop_ident`. The"]
            #[doc = r" items yielded by the iterator are `#items_type`. The populated"]
            #[doc = r" fields in `#items_type` will be the default fields populated by"]
            #[doc = r" the server."]
            pub fn iter_items_standard(
                mut self,
            ) -> crate::iter::PageItemIter<Self, crate::schemas::CategoryMetadata> {
                self.fields = Some(concat!("nextPageToken,", "items").to_owned());
                crate::iter::PageItemIter::new(self, "items")
            }
            #[doc = r" Return an iterator that iterates over all `#prop_ident`. The"]
            #[doc = r" items yielded by the iterator are `#items_type`. The populated"]
            #[doc = r" fields in `#items_type` will be all fields available. This should"]
            #[doc = r" primarily be used during developement and debugging as fetching"]
            #[doc = r" all fields can be expensive both in bandwidth and server"]
            #[doc = r" resources."]
            pub fn iter_items_debug(
                mut self,
            ) -> crate::iter::PageItemIter<Self, crate::schemas::CategoryMetadata> {
                self.fields = Some(concat!("nextPageToken,", "items", "(*)").to_owned());
                crate::iter::PageItemIter::new(self, "items")
            }
            pub fn iter<T>(mut self) -> crate::iter::PageIter<Self, T>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let mut fields = T::field_selector();
                if !fields.is_empty() {
                    match fields.chars().rev().nth(0) {
                        Some(',') | None => {}
                        _ => fields.push_str(","),
                    }
                    fields.push_str("nextPageToken");
                    self.fields = Some(fields);
                }
                crate::iter::PageIter::new(self)
            }
            pub fn iter_standard(
                self,
            ) -> crate::iter::PageIter<Self, crate::schemas::CategoryMetadataList> {
                crate::iter::PageIter::new(self)
            }
            pub fn iter_debug(
                mut self,
            ) -> crate::iter::PageIter<Self, crate::schemas::CategoryMetadataList> {
                self.fields = Some("*".to_owned());
                crate::iter::PageIter::new(self)
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::CategoryMetadataList, Box<dyn ::std::error::Error>>
            {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::CategoryMetadataList, Box<dyn ::std::error::Error>>
            {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files/");
                {
                    let var_as_str = &self.file_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/listCategoryMetadata");
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::GET, path);
                let req = req.query(&[("maxResults", &self.max_results)]);
                let req = req.query(&[("pageToken", &self.page_token)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec![
                    "https://www.googleapis.com/auth/drive.metadata.readonly",
                ]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        impl<'a, A: yup_oauth2::GetToken> crate::iter::IterableMethod
            for ListCategoryMetadataRequestBuilder<'a, A>
        {
            fn set_page_token(&mut self, value: String) {
                self.page_token = value.into();
            }
            fn execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                self._execute()
            }
        }
        #[derive(Debug, Clone)]
        pub struct MigrateToDrivePreFlightRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            request: crate::schemas::MigrateToDrivePreFlightRequest,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            reason: Option<String>,
            sync_type: Option<i32>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> MigrateToDrivePreFlightRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::MigrateToDrivePreFlightResponse, Box<dyn ::std::error::Error>>
            {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::MigrateToDrivePreFlightResponse, Box<dyn ::std::error::Error>>
            {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                let req = req.json(&self.request);
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("admin/files/migrateToDrivePreFlight");
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::POST, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct MigrateToTeamDrivePreFlightRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            request: crate::schemas::MigrateToTeamDrivePreFlightRequest,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            reason: Option<String>,
            sync_type: Option<i32>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> MigrateToTeamDrivePreFlightRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<
                crate::schemas::MigrateToTeamDrivePreFlightResponse,
                Box<dyn ::std::error::Error>,
            > {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<
                crate::schemas::MigrateToTeamDrivePreFlightResponse,
                Box<dyn ::std::error::Error>,
            > {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                let req = req.json(&self.request);
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("admin/files/migrateToTeamDrivePreFlight");
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::POST, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct PatchRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            request: crate::schemas::File,
            file_id: String,
            add_parents: Option<String>,
            base_revision: Option<String>,
            confirmed: Option<bool>,
            convert: Option<bool>,
            error_recovery: Option<bool>,
            expected_parent_ids: Option<String>,
            feature_label: Option<String>,
            include_metadata_for_categories: Option<String>,
            include_permissions_for_view: Option<String>,
            language_code: Option<String>,
            modified_date_behavior:
                Option<crate::resources::files::params::PatchModifiedDateBehavior>,
            mutation_precondition: Option<bool>,
            new_revision: Option<bool>,
            ocr: Option<bool>,
            ocr_language: Option<String>,
            open_drive: Option<bool>,
            pinned: Option<bool>,
            precondition: Option<String>,
            reason: Option<String>,
            remove_parents: Option<String>,
            set_modified_date: Option<bool>,
            storage_policy: Option<String>,
            supports_all_drives: Option<bool>,
            supports_team_drives: Option<bool>,
            sync_type: Option<i32>,
            timed_text_language: Option<String>,
            timed_text_track_name: Option<String>,
            update_viewed_date: Option<bool>,
            use_content_as_indexable_text: Option<bool>,
            use_domain_admin_access: Option<bool>,
            use_legacy_domain_permission_behavior: Option<bool>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> PatchRequestBuilder<'a, A> {
            #[doc = "Comma-separated list of parent IDs to add."]
            pub fn add_parents(mut self, value: impl Into<String>) -> Self {
                self.add_parents = Some(value.into());
                self
            }
            #[doc = "Base revision to use when uploading using partial updates."]
            pub fn base_revision(mut self, value: impl Into<String>) -> Self {
                self.base_revision = Some(value.into());
                self
            }
            #[doc = "Whether the user has confirmed any warnings for the update."]
            pub fn confirmed(mut self, value: bool) -> Self {
                self.confirmed = Some(value);
                self
            }
            #[doc = "Whether to convert this file to the corresponding Google Docs format."]
            pub fn convert(mut self, value: bool) -> Self {
                self.convert = Some(value);
                self
            }
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "A comma-separated list of parent IDs that have already been discovered by the requesting user. Parent filtering is prevented for parents on this list."]
            pub fn expected_parent_ids(mut self, value: impl Into<String>) -> Self {
                self.expected_parent_ids = Some(value.into());
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "A comma-separated list of names of Categories to include in the response."]
            pub fn include_metadata_for_categories(mut self, value: impl Into<String>) -> Self {
                self.include_metadata_for_categories = Some(value.into());
                self
            }
            #[doc = "Specifies which additional view's permissions to include in the response. Only 'published' is supported."]
            pub fn include_permissions_for_view(mut self, value: impl Into<String>) -> Self {
                self.include_permissions_for_view = Some(value.into());
                self
            }
            #[doc = "A language or locale code, as defined by BCP 47, with some extensions from Unicode's LDML format (http://www.unicode.org/reports/tr35/)."]
            pub fn language_code(mut self, value: impl Into<String>) -> Self {
                self.language_code = Some(value.into());
                self
            }
            #[doc = "The behavior of the last modified date. This overrides setModifiedDate."]
            pub fn modified_date_behavior(
                mut self,
                value: crate::resources::files::params::PatchModifiedDateBehavior,
            ) -> Self {
                self.modified_date_behavior = Some(value);
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether a blob upload should create a new revision. If false, the blob data in the current head revision is replaced. If true or not set, a new blob is created as head revision, and previous unpinned revisions are preserved for a short period of time. Pinned revisions are stored indefinitely, using additional storage quota, up to a maximum of 200 revisions."]
            pub fn new_revision(mut self, value: bool) -> Self {
                self.new_revision = Some(value);
                self
            }
            #[doc = "Whether to attempt OCR on .jpg, .png, .gif, or .pdf uploads."]
            pub fn ocr(mut self, value: bool) -> Self {
                self.ocr = Some(value);
                self
            }
            #[doc = "If ocr is true, hints at the language to use. Valid values are ISO 639-1 codes."]
            pub fn ocr_language(mut self, value: impl Into<String>) -> Self {
                self.ocr_language = Some(value.into());
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "Whether to pin the new revision."]
            pub fn pinned(mut self, value: bool) -> Self {
                self.pinned = Some(value);
                self
            }
            #[doc = "Query string for file update preconditions."]
            pub fn precondition(mut self, value: impl Into<String>) -> Self {
                self.precondition = Some(value.into());
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Comma-separated list of parent IDs to remove."]
            pub fn remove_parents(mut self, value: impl Into<String>) -> Self {
                self.remove_parents = Some(value.into());
                self
            }
            #[doc = "Whether to set the modified date with the supplied modified date."]
            pub fn set_modified_date(mut self, value: bool) -> Self {
                self.set_modified_date = Some(value);
                self
            }
            #[doc = "For eligible files (e.g. image and video) whether to store the data at original compressed high-quality resolution. Valid values are 'original' and 'highQuality'"]
            pub fn storage_policy(mut self, value: impl Into<String>) -> Self {
                self.storage_policy = Some(value.into());
                self
            }
            #[doc = "Deprecated - Whether the requesting application supports both My Drives and shared drives. This parameter will only be effective until June 1, 2020. Afterwards all applications are assumed to support shared drives."]
            pub fn supports_all_drives(mut self, value: bool) -> Self {
                self.supports_all_drives = Some(value);
                self
            }
            #[doc = "Deprecated use supportsAllDrives instead."]
            pub fn supports_team_drives(mut self, value: bool) -> Self {
                self.supports_team_drives = Some(value);
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "The language of the timed text."]
            pub fn timed_text_language(mut self, value: impl Into<String>) -> Self {
                self.timed_text_language = Some(value.into());
                self
            }
            #[doc = "The timed text track name."]
            pub fn timed_text_track_name(mut self, value: impl Into<String>) -> Self {
                self.timed_text_track_name = Some(value.into());
                self
            }
            #[doc = "Whether to update the view date after successfully updating the file."]
            pub fn update_viewed_date(mut self, value: bool) -> Self {
                self.update_viewed_date = Some(value);
                self
            }
            #[doc = "Whether to use the content as indexable text."]
            pub fn use_content_as_indexable_text(mut self, value: bool) -> Self {
                self.use_content_as_indexable_text = Some(value);
                self
            }
            #[doc = "Issue the request as a domain administrator; if set to true, then the requester will be granted access if they are an administrator of the domain to which the item belongs. This feature is only available to whitelisted apps."]
            pub fn use_domain_admin_access(mut self, value: bool) -> Self {
                self.use_domain_admin_access = Some(value);
                self
            }
            #[doc = "If true, Permissions with type Audience are represented with Domain type."]
            pub fn use_legacy_domain_permission_behavior(mut self, value: bool) -> Self {
                self.use_legacy_domain_permission_behavior = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::File, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::File, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                let req = req.json(&self.request);
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files/");
                {
                    let var_as_str = &self.file_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::PATCH, path);
                let req = req.query(&[("addParents", &self.add_parents)]);
                let req = req.query(&[("baseRevision", &self.base_revision)]);
                let req = req.query(&[("confirmed", &self.confirmed)]);
                let req = req.query(&[("convert", &self.convert)]);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("expectedParentIds", &self.expected_parent_ids)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[(
                    "includeMetadataForCategories",
                    &self.include_metadata_for_categories,
                )]);
                let req = req.query(&[(
                    "includePermissionsForView",
                    &self.include_permissions_for_view,
                )]);
                let req = req.query(&[("languageCode", &self.language_code)]);
                let req = req.query(&[("modifiedDateBehavior", &self.modified_date_behavior)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("newRevision", &self.new_revision)]);
                let req = req.query(&[("ocr", &self.ocr)]);
                let req = req.query(&[("ocrLanguage", &self.ocr_language)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("pinned", &self.pinned)]);
                let req = req.query(&[("precondition", &self.precondition)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("removeParents", &self.remove_parents)]);
                let req = req.query(&[("setModifiedDate", &self.set_modified_date)]);
                let req = req.query(&[("storagePolicy", &self.storage_policy)]);
                let req = req.query(&[("supportsAllDrives", &self.supports_all_drives)]);
                let req = req.query(&[("supportsTeamDrives", &self.supports_team_drives)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("timedTextLanguage", &self.timed_text_language)]);
                let req = req.query(&[("timedTextTrackName", &self.timed_text_track_name)]);
                let req = req.query(&[("updateViewedDate", &self.update_viewed_date)]);
                let req = req.query(&[(
                    "useContentAsIndexableText",
                    &self.use_content_as_indexable_text,
                )]);
                let req = req.query(&[("useDomainAdminAccess", &self.use_domain_admin_access)]);
                let req = req.query(&[(
                    "useLegacyDomainPermissionBehavior",
                    &self.use_legacy_domain_permission_behavior,
                )]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct PreviewRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            file_id: String,
            file_name: Option<String>,
            file_size: Option<i64>,
            mime_type: Option<String>,
            origin: Option<crate::resources::files::params::PreviewOrigin>,
            quota_bytes: Option<i64>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> PreviewRequestBuilder<'a, A> {
            #[doc = "The name of the archive file to be previewed. Required when origin is GMAIL"]
            pub fn file_name(mut self, value: impl Into<String>) -> Self {
                self.file_name = Some(value.into());
                self
            }
            #[doc = "The size of the archive file to be previewed. Required when origin is GMAIL"]
            pub fn file_size(mut self, value: i64) -> Self {
                self.file_size = Some(value);
                self
            }
            #[doc = "The mime type of the archive file to be previewed. Required when origin is GMAIL"]
            pub fn mime_type(mut self, value: impl Into<String>) -> Self {
                self.mime_type = Some(value.into());
                self
            }
            #[doc = "The origin of the file preview request."]
            pub fn origin(mut self, value: crate::resources::files::params::PreviewOrigin) -> Self {
                self.origin = Some(value);
                self
            }
            #[doc = "The user's available quota, in bytes."]
            pub fn quota_bytes(mut self, value: i64) -> Self {
                self.quota_bytes = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::FilePreview, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::FilePreview, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files/");
                {
                    let var_as_str = &self.file_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/preview");
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::GET, path);
                let req = req.query(&[("fileName", &self.file_name)]);
                let req = req.query(&[("fileSize", &self.file_size)]);
                let req = req.query(&[("mimeType", &self.mime_type)]);
                let req = req.query(&[("origin", &self.origin)]);
                let req = req.query(&[("quotaBytes", &self.quota_bytes)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive.readonly"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct RemoveRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            file_id: String,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            include_metadata_for_categories: Option<String>,
            include_permissions_for_view: Option<String>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            parent_id: Option<String>,
            reason: Option<String>,
            sync_type: Option<i32>,
            use_legacy_domain_permission_behavior: Option<bool>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> RemoveRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "A comma-separated list of names of Categories to include in the response."]
            pub fn include_metadata_for_categories(mut self, value: impl Into<String>) -> Self {
                self.include_metadata_for_categories = Some(value.into());
                self
            }
            #[doc = "Specifies which additional view's permissions to include in the response. Only 'published' is supported."]
            pub fn include_permissions_for_view(mut self, value: impl Into<String>) -> Self {
                self.include_permissions_for_view = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The ID of the folder from which to remove the file."]
            pub fn parent_id(mut self, value: impl Into<String>) -> Self {
                self.parent_id = Some(value.into());
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "If true, Permissions with type Audience are represented with Domain type."]
            pub fn use_legacy_domain_permission_behavior(mut self, value: bool) -> Self {
                self.use_legacy_domain_permission_behavior = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::File, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::File, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files/");
                {
                    let var_as_str = &self.file_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/remove");
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::POST, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[(
                    "includeMetadataForCategories",
                    &self.include_metadata_for_categories,
                )]);
                let req = req.query(&[(
                    "includePermissionsForView",
                    &self.include_permissions_for_view,
                )]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("parentId", &self.parent_id)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[(
                    "useLegacyDomainPermissionBehavior",
                    &self.use_legacy_domain_permission_behavior,
                )]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct RequestAccessRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            file_id: String,
            email_message: Option<String>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> RequestAccessRequestBuilder<'a, A> {
            #[doc = "An optional plain text custom message to include in notification emails."]
            pub fn email_message(mut self, value: impl Into<String>) -> Self {
                self.email_message = Some(value.into());
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            pub fn execute(self) -> Result<(), Box<dyn ::std::error::Error>> {
                let req = self._request(&self._path());
                req.send()?.error_for_status()?;
                Ok(())
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files/");
                {
                    let var_as_str = &self.file_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/requestAccess");
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::POST, path);
                let req = req.query(&[("emailMessage", &self.email_message)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct SendAccessRequestRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            request: crate::schemas::SendAccessRequest,
            file_id: String,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> SendAccessRequestRequestBuilder<'a, A> {
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            pub fn execute(self) -> Result<(), Box<dyn ::std::error::Error>> {
                let req = self._request(&self._path());
                let req = req.json(&self.request);
                req.send()?.error_for_status()?;
                Ok(())
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files/");
                {
                    let var_as_str = &self.file_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/sendAccessRequest");
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::POST, path);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct SendShareNotificationRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            request: crate::schemas::ShareNotificationRequest,
            file_id: String,
            language_code: Option<String>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> SendShareNotificationRequestBuilder<'a, A> {
            #[doc = "A language or locale code, as defined by BCP 47, with some extensions from Unicode's LDML format (http://www.unicode.org/reports/tr35/)."]
            pub fn language_code(mut self, value: impl Into<String>) -> Self {
                self.language_code = Some(value.into());
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            pub fn execute(self) -> Result<(), Box<dyn ::std::error::Error>> {
                let req = self._request(&self._path());
                let req = req.json(&self.request);
                req.send()?.error_for_status()?;
                Ok(())
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files/");
                {
                    let var_as_str = &self.file_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/sendShareNotification");
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::POST, path);
                let req = req.query(&[("languageCode", &self.language_code)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct SyncPhotoWithSha1RequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            request: crate::schemas::SyncPhotoWithSha1Request,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            include_metadata_for_categories: Option<String>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            reason: Option<String>,
            sync_type: Option<i32>,
            use_legacy_domain_permission_behavior: Option<bool>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> SyncPhotoWithSha1RequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "A comma-separated list of names of Categories to include in the response."]
            pub fn include_metadata_for_categories(mut self, value: impl Into<String>) -> Self {
                self.include_metadata_for_categories = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "If true, Permissions with type Audience are represented with Domain type."]
            pub fn use_legacy_domain_permission_behavior(mut self, value: bool) -> Self {
                self.use_legacy_domain_permission_behavior = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::File, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::File, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                let req = req.json(&self.request);
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files/syncPhotoWithSha1");
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::POST, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[(
                    "includeMetadataForCategories",
                    &self.include_metadata_for_categories,
                )]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[(
                    "useLegacyDomainPermissionBehavior",
                    &self.use_legacy_domain_permission_behavior,
                )]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct TouchRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            file_id: String,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            include_metadata_for_categories: Option<String>,
            include_permissions_for_view: Option<String>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            reason: Option<String>,
            supports_all_drives: Option<bool>,
            supports_team_drives: Option<bool>,
            sync_type: Option<i32>,
            use_legacy_domain_permission_behavior: Option<bool>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> TouchRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "A comma-separated list of names of Categories to include in the response."]
            pub fn include_metadata_for_categories(mut self, value: impl Into<String>) -> Self {
                self.include_metadata_for_categories = Some(value.into());
                self
            }
            #[doc = "Specifies which additional view's permissions to include in the response. Only 'published' is supported."]
            pub fn include_permissions_for_view(mut self, value: impl Into<String>) -> Self {
                self.include_permissions_for_view = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Deprecated - Whether the requesting application supports both My Drives and shared drives. This parameter will only be effective until June 1, 2020. Afterwards all applications are assumed to support shared drives."]
            pub fn supports_all_drives(mut self, value: bool) -> Self {
                self.supports_all_drives = Some(value);
                self
            }
            #[doc = "Deprecated use supportsAllDrives instead."]
            pub fn supports_team_drives(mut self, value: bool) -> Self {
                self.supports_team_drives = Some(value);
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "If true, Permissions with type Audience are represented with Domain type."]
            pub fn use_legacy_domain_permission_behavior(mut self, value: bool) -> Self {
                self.use_legacy_domain_permission_behavior = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::File, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::File, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files/");
                {
                    let var_as_str = &self.file_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/touch");
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::POST, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[(
                    "includeMetadataForCategories",
                    &self.include_metadata_for_categories,
                )]);
                let req = req.query(&[(
                    "includePermissionsForView",
                    &self.include_permissions_for_view,
                )]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("supportsAllDrives", &self.supports_all_drives)]);
                let req = req.query(&[("supportsTeamDrives", &self.supports_team_drives)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[(
                    "useLegacyDomainPermissionBehavior",
                    &self.use_legacy_domain_permission_behavior,
                )]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct TrashRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            file_id: String,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            include_metadata_for_categories: Option<String>,
            include_permissions_for_view: Option<String>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            reason: Option<String>,
            supports_all_drives: Option<bool>,
            supports_team_drives: Option<bool>,
            sync_type: Option<i32>,
            use_legacy_domain_permission_behavior: Option<bool>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> TrashRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "A comma-separated list of names of Categories to include in the response."]
            pub fn include_metadata_for_categories(mut self, value: impl Into<String>) -> Self {
                self.include_metadata_for_categories = Some(value.into());
                self
            }
            #[doc = "Specifies which additional view's permissions to include in the response. Only 'published' is supported."]
            pub fn include_permissions_for_view(mut self, value: impl Into<String>) -> Self {
                self.include_permissions_for_view = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Deprecated - Whether the requesting application supports both My Drives and shared drives. This parameter will only be effective until June 1, 2020. Afterwards all applications are assumed to support shared drives."]
            pub fn supports_all_drives(mut self, value: bool) -> Self {
                self.supports_all_drives = Some(value);
                self
            }
            #[doc = "Deprecated use supportsAllDrives instead."]
            pub fn supports_team_drives(mut self, value: bool) -> Self {
                self.supports_team_drives = Some(value);
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "If true, Permissions with type Audience are represented with Domain type."]
            pub fn use_legacy_domain_permission_behavior(mut self, value: bool) -> Self {
                self.use_legacy_domain_permission_behavior = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::File, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::File, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files/");
                {
                    let var_as_str = &self.file_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/trash");
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::POST, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[(
                    "includeMetadataForCategories",
                    &self.include_metadata_for_categories,
                )]);
                let req = req.query(&[(
                    "includePermissionsForView",
                    &self.include_permissions_for_view,
                )]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("supportsAllDrives", &self.supports_all_drives)]);
                let req = req.query(&[("supportsTeamDrives", &self.supports_team_drives)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[(
                    "useLegacyDomainPermissionBehavior",
                    &self.use_legacy_domain_permission_behavior,
                )]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct UntrashRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            file_id: String,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            include_metadata_for_categories: Option<String>,
            include_permissions_for_view: Option<String>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            reason: Option<String>,
            supports_all_drives: Option<bool>,
            supports_team_drives: Option<bool>,
            sync_type: Option<i32>,
            use_legacy_domain_permission_behavior: Option<bool>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> UntrashRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "A comma-separated list of names of Categories to include in the response."]
            pub fn include_metadata_for_categories(mut self, value: impl Into<String>) -> Self {
                self.include_metadata_for_categories = Some(value.into());
                self
            }
            #[doc = "Specifies which additional view's permissions to include in the response. Only 'published' is supported."]
            pub fn include_permissions_for_view(mut self, value: impl Into<String>) -> Self {
                self.include_permissions_for_view = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Deprecated - Whether the requesting application supports both My Drives and shared drives. This parameter will only be effective until June 1, 2020. Afterwards all applications are assumed to support shared drives."]
            pub fn supports_all_drives(mut self, value: bool) -> Self {
                self.supports_all_drives = Some(value);
                self
            }
            #[doc = "Deprecated use supportsAllDrives instead."]
            pub fn supports_team_drives(mut self, value: bool) -> Self {
                self.supports_team_drives = Some(value);
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "If true, Permissions with type Audience are represented with Domain type."]
            pub fn use_legacy_domain_permission_behavior(mut self, value: bool) -> Self {
                self.use_legacy_domain_permission_behavior = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::File, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::File, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files/");
                {
                    let var_as_str = &self.file_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/untrash");
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::POST, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[(
                    "includeMetadataForCategories",
                    &self.include_metadata_for_categories,
                )]);
                let req = req.query(&[(
                    "includePermissionsForView",
                    &self.include_permissions_for_view,
                )]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("supportsAllDrives", &self.supports_all_drives)]);
                let req = req.query(&[("supportsTeamDrives", &self.supports_team_drives)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[(
                    "useLegacyDomainPermissionBehavior",
                    &self.use_legacy_domain_permission_behavior,
                )]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct UpdateRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            request: crate::schemas::File,
            file_id: String,
            add_parents: Option<String>,
            add_workspaces: Option<String>,
            base_revision: Option<String>,
            confirmed: Option<bool>,
            convert: Option<bool>,
            error_recovery: Option<bool>,
            expected_parent_ids: Option<String>,
            feature_label: Option<String>,
            include_metadata_for_categories: Option<String>,
            include_permissions_for_view: Option<String>,
            language_code: Option<String>,
            modified_date_behavior:
                Option<crate::resources::files::params::UpdateModifiedDateBehavior>,
            mutation_precondition: Option<bool>,
            new_revision: Option<bool>,
            ocr: Option<bool>,
            ocr_language: Option<String>,
            open_drive: Option<bool>,
            pinned: Option<bool>,
            precondition: Option<String>,
            reason: Option<String>,
            remove_parents: Option<String>,
            remove_workspaces: Option<String>,
            set_modified_date: Option<bool>,
            storage_policy: Option<String>,
            supports_all_drives: Option<bool>,
            supports_team_drives: Option<bool>,
            sync_type: Option<i32>,
            timed_text_language: Option<String>,
            timed_text_track_name: Option<String>,
            update_viewed_date: Option<bool>,
            use_content_as_indexable_text: Option<bool>,
            use_domain_admin_access: Option<bool>,
            use_legacy_domain_permission_behavior: Option<bool>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> UpdateRequestBuilder<'a, A> {
            #[doc = "Comma-separated list of parent IDs to add."]
            pub fn add_parents(mut self, value: impl Into<String>) -> Self {
                self.add_parents = Some(value.into());
                self
            }
            #[doc = "Comma-separated list of Workspace IDs to add; file will be added to all associated Workspaces."]
            pub fn add_workspaces(mut self, value: impl Into<String>) -> Self {
                self.add_workspaces = Some(value.into());
                self
            }
            #[doc = "Base revision to use when uploading using partial updates."]
            pub fn base_revision(mut self, value: impl Into<String>) -> Self {
                self.base_revision = Some(value.into());
                self
            }
            #[doc = "Whether the user has confirmed any warnings for the update."]
            pub fn confirmed(mut self, value: bool) -> Self {
                self.confirmed = Some(value);
                self
            }
            #[doc = "Whether to convert this file to the corresponding Google Docs format."]
            pub fn convert(mut self, value: bool) -> Self {
                self.convert = Some(value);
                self
            }
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "A comma-separated list of parent IDs that have already been discovered by the requesting user. Parent filtering is prevented for parents on this list."]
            pub fn expected_parent_ids(mut self, value: impl Into<String>) -> Self {
                self.expected_parent_ids = Some(value.into());
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "A comma-separated list of names of Categories to include in the response."]
            pub fn include_metadata_for_categories(mut self, value: impl Into<String>) -> Self {
                self.include_metadata_for_categories = Some(value.into());
                self
            }
            #[doc = "Specifies which additional view's permissions to include in the response. Only 'published' is supported."]
            pub fn include_permissions_for_view(mut self, value: impl Into<String>) -> Self {
                self.include_permissions_for_view = Some(value.into());
                self
            }
            #[doc = "A language or locale code, as defined by BCP 47, with some extensions from Unicode's LDML format (http://www.unicode.org/reports/tr35/)."]
            pub fn language_code(mut self, value: impl Into<String>) -> Self {
                self.language_code = Some(value.into());
                self
            }
            #[doc = "The behavior of the last modified date. This overrides setModifiedDate."]
            pub fn modified_date_behavior(
                mut self,
                value: crate::resources::files::params::UpdateModifiedDateBehavior,
            ) -> Self {
                self.modified_date_behavior = Some(value);
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether a blob upload should create a new revision. If false, the blob data in the current head revision is replaced. If true or not set, a new blob is created as head revision, and previous unpinned revisions are preserved for a short period of time. Pinned revisions are stored indefinitely, using additional storage quota, up to a maximum of 200 revisions."]
            pub fn new_revision(mut self, value: bool) -> Self {
                self.new_revision = Some(value);
                self
            }
            #[doc = "Whether to attempt OCR on .jpg, .png, .gif, or .pdf uploads."]
            pub fn ocr(mut self, value: bool) -> Self {
                self.ocr = Some(value);
                self
            }
            #[doc = "If ocr is true, hints at the language to use. Valid values are ISO 639-1 codes."]
            pub fn ocr_language(mut self, value: impl Into<String>) -> Self {
                self.ocr_language = Some(value.into());
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "Whether to pin the new revision."]
            pub fn pinned(mut self, value: bool) -> Self {
                self.pinned = Some(value);
                self
            }
            #[doc = "Query string for file update preconditions."]
            pub fn precondition(mut self, value: impl Into<String>) -> Self {
                self.precondition = Some(value.into());
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Comma-separated list of parent IDs to remove."]
            pub fn remove_parents(mut self, value: impl Into<String>) -> Self {
                self.remove_parents = Some(value.into());
                self
            }
            #[doc = "Comma-separated list of Workspace IDs to remove; file will be removed from all associated Workspaces."]
            pub fn remove_workspaces(mut self, value: impl Into<String>) -> Self {
                self.remove_workspaces = Some(value.into());
                self
            }
            #[doc = "Whether to set the modified date with the supplied modified date."]
            pub fn set_modified_date(mut self, value: bool) -> Self {
                self.set_modified_date = Some(value);
                self
            }
            #[doc = "For eligible files (e.g. image and video) whether to store the data at original compressed high-quality resolution. Valid values are 'original' and 'highQuality'"]
            pub fn storage_policy(mut self, value: impl Into<String>) -> Self {
                self.storage_policy = Some(value.into());
                self
            }
            #[doc = "Deprecated - Whether the requesting application supports both My Drives and shared drives. This parameter will only be effective until June 1, 2020. Afterwards all applications are assumed to support shared drives."]
            pub fn supports_all_drives(mut self, value: bool) -> Self {
                self.supports_all_drives = Some(value);
                self
            }
            #[doc = "Deprecated use supportsAllDrives instead."]
            pub fn supports_team_drives(mut self, value: bool) -> Self {
                self.supports_team_drives = Some(value);
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "The language of the timed text."]
            pub fn timed_text_language(mut self, value: impl Into<String>) -> Self {
                self.timed_text_language = Some(value.into());
                self
            }
            #[doc = "The timed text track name."]
            pub fn timed_text_track_name(mut self, value: impl Into<String>) -> Self {
                self.timed_text_track_name = Some(value.into());
                self
            }
            #[doc = "Whether to update the view date after successfully updating the file."]
            pub fn update_viewed_date(mut self, value: bool) -> Self {
                self.update_viewed_date = Some(value);
                self
            }
            #[doc = "Whether to use the content as indexable text."]
            pub fn use_content_as_indexable_text(mut self, value: bool) -> Self {
                self.use_content_as_indexable_text = Some(value);
                self
            }
            #[doc = "Issue the request as a domain administrator; if set to true, then the requester will be granted access if they are an administrator of the domain to which the item belongs. This feature is only available to whitelisted apps."]
            pub fn use_domain_admin_access(mut self, value: bool) -> Self {
                self.use_domain_admin_access = Some(value);
                self
            }
            #[doc = "If true, Permissions with type Audience are represented with Domain type."]
            pub fn use_legacy_domain_permission_behavior(mut self, value: bool) -> Self {
                self.use_legacy_domain_permission_behavior = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            fn _download_path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/download/".to_owned();
                output.push_str("files/");
                {
                    let var_as_str = &self.file_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output
            }
            pub fn download<W>(
                mut self,
                output: &mut W,
            ) -> Result<u64, Box<dyn ::std::error::Error>>
            where
                W: ::std::io::Write + ?Sized,
            {
                self.alt = Some(crate::params::Alt::Media);
                Ok(self
                    ._request(&self._path())
                    .send()?
                    .error_for_status()?
                    .copy_to(output)?)
            }
            fn _simple_upload_path(&self) -> String {
                let mut output = "https://www.googleapis.com/".to_owned();
                output.push_str("upload/drive/v2.1beta/files/");
                {
                    let var_as_str = &self.file_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output
            }
            pub fn upload<T, R>(
                mut self,
                content: R,
                mime_type: ::mime::Mime,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
                R: ::std::io::Read + ::std::io::Seek + Send + 'static,
            {
                if self.fields.is_none() {
                    self.fields = Some(T::field_selector());
                }
                let req = self._request(&self._simple_upload_path());
                let req = req.query(&[("uploadType", "multipart")]);
                use crate::multipart::{Part, RelatedMultiPart};
                let mut multipart = RelatedMultiPart::new();
                let request_json = ::serde_json::to_vec(&self.request)?;
                multipart.new_part(Part::new(
                    ::mime::APPLICATION_JSON,
                    Box::new(::std::io::Cursor::new(request_json)),
                ));
                multipart.new_part(Part::new(mime_type, Box::new(content)));
                let req = req.header(
                    ::reqwest::header::CONTENT_TYPE,
                    format!("multipart/related; boundary={}", multipart.boundary()),
                );
                let req = req.body(reqwest::Body::new(multipart.into_reader()));
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _resumable_upload_path(&self) -> String {
                let mut output = "https://www.googleapis.com/".to_owned();
                output.push_str("resumable/upload/drive/v2.1beta/files/");
                {
                    let var_as_str = &self.file_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output
            }
            pub fn start_resumable_upload(
                self,
                mime_type: ::mime::Mime,
            ) -> Result<crate::ResumableUpload, Box<dyn ::std::error::Error>> {
                let req = self._request(&self._resumable_upload_path());
                let req = req.query(&[("uploadType", "resumable")]);
                let req = req.header(
                    ::reqwest::header::HeaderName::from_static("x-upload-content-type"),
                    mime_type.to_string(),
                );
                let req = req.json(&self.request);
                let resp = req.send()?.error_for_status()?;
                let location_header =
                    resp.headers()
                        .get(::reqwest::header::LOCATION)
                        .ok_or_else(|| {
                            format!("No LOCATION header returned when initiating resumable upload")
                        })?;
                let upload_url = ::std::str::from_utf8(location_header.as_bytes())?.to_owned();
                Ok(crate::ResumableUpload::new(
                    self.reqwest.clone(),
                    upload_url,
                ))
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::File, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::File, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                let req = req.json(&self.request);
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files/");
                {
                    let var_as_str = &self.file_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::PUT, path);
                let req = req.query(&[("addParents", &self.add_parents)]);
                let req = req.query(&[("addWorkspaces", &self.add_workspaces)]);
                let req = req.query(&[("baseRevision", &self.base_revision)]);
                let req = req.query(&[("confirmed", &self.confirmed)]);
                let req = req.query(&[("convert", &self.convert)]);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("expectedParentIds", &self.expected_parent_ids)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[(
                    "includeMetadataForCategories",
                    &self.include_metadata_for_categories,
                )]);
                let req = req.query(&[(
                    "includePermissionsForView",
                    &self.include_permissions_for_view,
                )]);
                let req = req.query(&[("languageCode", &self.language_code)]);
                let req = req.query(&[("modifiedDateBehavior", &self.modified_date_behavior)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("newRevision", &self.new_revision)]);
                let req = req.query(&[("ocr", &self.ocr)]);
                let req = req.query(&[("ocrLanguage", &self.ocr_language)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("pinned", &self.pinned)]);
                let req = req.query(&[("precondition", &self.precondition)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("removeParents", &self.remove_parents)]);
                let req = req.query(&[("removeWorkspaces", &self.remove_workspaces)]);
                let req = req.query(&[("setModifiedDate", &self.set_modified_date)]);
                let req = req.query(&[("storagePolicy", &self.storage_policy)]);
                let req = req.query(&[("supportsAllDrives", &self.supports_all_drives)]);
                let req = req.query(&[("supportsTeamDrives", &self.supports_team_drives)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("timedTextLanguage", &self.timed_text_language)]);
                let req = req.query(&[("timedTextTrackName", &self.timed_text_track_name)]);
                let req = req.query(&[("updateViewedDate", &self.update_viewed_date)]);
                let req = req.query(&[(
                    "useContentAsIndexableText",
                    &self.use_content_as_indexable_text,
                )]);
                let req = req.query(&[("useDomainAdminAccess", &self.use_domain_admin_access)]);
                let req = req.query(&[(
                    "useLegacyDomainPermissionBehavior",
                    &self.use_legacy_domain_permission_behavior,
                )]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct UpdateCategoryMetadataRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            request: crate::schemas::UpdateCategoryMetadata,
            file_id: String,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> UpdateCategoryMetadataRequestBuilder<'a, A> {
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::CategoryMetadataList, Box<dyn ::std::error::Error>>
            {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::CategoryMetadataList, Box<dyn ::std::error::Error>>
            {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                let req = req.json(&self.request);
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files/");
                {
                    let var_as_str = &self.file_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/updateCategoryMetadata");
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::POST, path);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct WatchRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            request: crate::schemas::Channel,
            file_id: String,
            acknowledge_abuse: Option<bool>,
            all_properties: Option<bool>,
            embed_origin: Option<String>,
            error_recovery: Option<bool>,
            expected_parent_ids: Option<String>,
            feature_label: Option<String>,
            file_scope_app_ids: Option<String>,
            include_metadata_for_categories: Option<String>,
            include_permissions_for_view: Option<String>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            projection: Option<crate::resources::files::params::WatchProjection>,
            reason: Option<String>,
            reject_inefficient_requests: Option<bool>,
            report_permission_errors: Option<bool>,
            return_efficiency_info: Option<bool>,
            revision_id: Option<String>,
            sources: Option<String>,
            supports_all_drives: Option<bool>,
            supports_team_drives: Option<bool>,
            sync_type: Option<i32>,
            update_viewed_date: Option<bool>,
            use_domain_admin_access: Option<bool>,
            use_legacy_domain_permission_behavior: Option<bool>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> WatchRequestBuilder<'a, A> {
            #[doc = "Whether the user is acknowledging the risk of downloading known malware or other abusive files."]
            pub fn acknowledge_abuse(mut self, value: bool) -> Self {
                self.acknowledge_abuse = Some(value);
                self
            }
            #[doc = "Whether to retrieve all properties, not just those visible to the app."]
            pub fn all_properties(mut self, value: bool) -> Self {
                self.all_properties = Some(value);
                self
            }
            #[doc = "The origin in which the sharing widget will be embedded. This should be supplied when requesting the shareLink field."]
            pub fn embed_origin(mut self, value: impl Into<String>) -> Self {
                self.embed_origin = Some(value.into());
                self
            }
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "A comma-separated list of parent IDs that have already been discovered by the requesting user. Parent filtering is prevented for parents on this list."]
            pub fn expected_parent_ids(mut self, value: impl Into<String>) -> Self {
                self.expected_parent_ids = Some(value.into());
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "DEPRECATED; not needed. A comma separated list of app IDs. If set the result will only include a file inside the app data folder if it could be opened by any of the specified app IDs with the drive.appdata scope. Requires the ALL_APPDATA scope."]
            pub fn file_scope_app_ids(mut self, value: impl Into<String>) -> Self {
                self.file_scope_app_ids = Some(value.into());
                self
            }
            #[doc = "A comma-separated list of names of Categories to include in the response."]
            pub fn include_metadata_for_categories(mut self, value: impl Into<String>) -> Self {
                self.include_metadata_for_categories = Some(value.into());
                self
            }
            #[doc = "Specifies which additional view's permissions to include in the response. Only 'published' is supported."]
            pub fn include_permissions_for_view(mut self, value: impl Into<String>) -> Self {
                self.include_permissions_for_view = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "This parameter is deprecated and has no function."]
            pub fn projection(
                mut self,
                value: crate::resources::files::params::WatchProjection,
            ) -> Self {
                self.projection = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request should be rejected if it would generate an inefficient query."]
            pub fn reject_inefficient_requests(mut self, value: bool) -> Self {
                self.reject_inefficient_requests = Some(value);
                self
            }
            #[doc = "Whether the request should return 403 instead 404 if the file exists but the user doesn't have read access. This option is not compatible with the deprecated updateViewedDate parameter. If set for any item in a batch, it will be set for all."]
            pub fn report_permission_errors(mut self, value: bool) -> Self {
                self.report_permission_errors = Some(value);
                self
            }
            #[doc = "Whether the request should return efficiency info."]
            pub fn return_efficiency_info(mut self, value: bool) -> Self {
                self.return_efficiency_info = Some(value);
                self
            }
            #[doc = "Specifies the Revision ID that should be downloaded. Ignored unless alt=media is specified."]
            pub fn revision_id(mut self, value: impl Into<String>) -> Self {
                self.revision_id = Some(value.into());
                self
            }
            #[doc = "Deprecated. This parameter is no longer necessary."]
            pub fn sources(mut self, value: impl Into<String>) -> Self {
                self.sources = Some(value.into());
                self
            }
            #[doc = "Deprecated - Whether the requesting application supports both My Drives and shared drives. This parameter will only be effective until June 1, 2020. Afterwards all applications are assumed to support shared drives."]
            pub fn supports_all_drives(mut self, value: bool) -> Self {
                self.supports_all_drives = Some(value);
                self
            }
            #[doc = "Deprecated - use supportsAllDrives instead."]
            pub fn supports_team_drives(mut self, value: bool) -> Self {
                self.supports_team_drives = Some(value);
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "Deprecated: Use files.update with modifiedDateBehavior=noChange, updateViewedDate=true and an empty request body."]
            pub fn update_viewed_date(mut self, value: bool) -> Self {
                self.update_viewed_date = Some(value);
                self
            }
            #[doc = "Issue the request as a domain administrator; if set to true, then the requester will be granted access if they are an administrator of the domain to which the item belongs."]
            pub fn use_domain_admin_access(mut self, value: bool) -> Self {
                self.use_domain_admin_access = Some(value);
                self
            }
            #[doc = "If true, Permissions with type Audience are represented with Domain type."]
            pub fn use_legacy_domain_permission_behavior(mut self, value: bool) -> Self {
                self.use_legacy_domain_permission_behavior = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            fn _download_path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/download/".to_owned();
                output.push_str("files/");
                {
                    let var_as_str = &self.file_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/watch");
                output
            }
            pub fn download<W>(
                mut self,
                output: &mut W,
            ) -> Result<u64, Box<dyn ::std::error::Error>>
            where
                W: ::std::io::Write + ?Sized,
            {
                self.alt = Some(crate::params::Alt::Media);
                Ok(self
                    ._request(&self._path())
                    .send()?
                    .error_for_status()?
                    .copy_to(output)?)
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::Channel, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::Channel, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                let req = req.json(&self.request);
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files/");
                {
                    let var_as_str = &self.file_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/watch");
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::POST, path);
                let req = req.query(&[("acknowledgeAbuse", &self.acknowledge_abuse)]);
                let req = req.query(&[("allProperties", &self.all_properties)]);
                let req = req.query(&[("embedOrigin", &self.embed_origin)]);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("expectedParentIds", &self.expected_parent_ids)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("fileScopeAppIds", &self.file_scope_app_ids)]);
                let req = req.query(&[(
                    "includeMetadataForCategories",
                    &self.include_metadata_for_categories,
                )]);
                let req = req.query(&[(
                    "includePermissionsForView",
                    &self.include_permissions_for_view,
                )]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("projection", &self.projection)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[(
                    "rejectInefficientRequests",
                    &self.reject_inefficient_requests,
                )]);
                let req = req.query(&[("reportPermissionErrors", &self.report_permission_errors)]);
                let req = req.query(&[("returnEfficiencyInfo", &self.return_efficiency_info)]);
                let req = req.query(&[("revisionId", &self.revision_id)]);
                let req = req.query(&[("sources", &self.sources)]);
                let req = req.query(&[("supportsAllDrives", &self.supports_all_drives)]);
                let req = req.query(&[("supportsTeamDrives", &self.supports_team_drives)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("updateViewedDate", &self.update_viewed_date)]);
                let req = req.query(&[("useDomainAdminAccess", &self.use_domain_admin_access)]);
                let req = req.query(&[(
                    "useLegacyDomainPermissionBehavior",
                    &self.use_legacy_domain_permission_behavior,
                )]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
    }
    pub mod nextdocpredictions {
        pub mod params {}
        pub struct NextdocpredictionsActions<'a, A> {
            pub(crate) reqwest: &'a reqwest::Client,
            pub(crate) auth: &'a std::sync::Mutex<A>,
        }
        impl<'a, A: yup_oauth2::GetToken> NextdocpredictionsActions<'a, A> {
            #[doc = "Lists predictions for the documents the user will open."]
            pub fn list(&self) -> ListRequestBuilder<A> {
                ListRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    corpora: None,
                    drive_id: None,
                    language_code: None,
                    max_results: None,
                    team_drive_id: None,
                }
            }
        }
        #[derive(Debug, Clone)]
        pub struct ListRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            corpora: Option<String>,
            drive_id: Option<String>,
            language_code: Option<String>,
            max_results: Option<i32>,
            team_drive_id: Option<String>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> ListRequestBuilder<'a, A> {
            #[doc = "Comma-separated list of corpora under which to predict documents. Supported options are 'default' and 'drive'. Currently leaving this blank implies 'default'."]
            pub fn corpora(mut self, value: impl Into<String>) -> Self {
                self.corpora = Some(value.into());
                self
            }
            #[doc = "ID for a shared drive under which to predict documents."]
            pub fn drive_id(mut self, value: impl Into<String>) -> Self {
                self.drive_id = Some(value.into());
                self
            }
            #[doc = "The locale to use for any localization."]
            pub fn language_code(mut self, value: impl Into<String>) -> Self {
                self.language_code = Some(value.into());
                self
            }
            #[doc = "Maximum number of predictions to return."]
            pub fn max_results(mut self, value: i32) -> Self {
                self.max_results = Some(value);
                self
            }
            #[doc = "Deprecated use driveId instead."]
            pub fn team_drive_id(mut self, value: impl Into<String>) -> Self {
                self.team_drive_id = Some(value.into());
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::NextDocPredictionList, Box<dyn ::std::error::Error>>
            {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::NextDocPredictionList, Box<dyn ::std::error::Error>>
            {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("nextdocpredictions");
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::GET, path);
                let req = req.query(&[("corpora", &self.corpora)]);
                let req = req.query(&[("driveId", &self.drive_id)]);
                let req = req.query(&[("languageCode", &self.language_code)]);
                let req = req.query(&[("maxResults", &self.max_results)]);
                let req = req.query(&[("teamDriveId", &self.team_drive_id)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
    }
    pub mod notifications {
        pub mod params {}
        pub struct NotificationsActions<'a, A> {
            pub(crate) reqwest: &'a reqwest::Client,
            pub(crate) auth: &'a std::sync::Mutex<A>,
        }
        impl<'a, A: yup_oauth2::GetToken> NotificationsActions<'a, A> {
            #[doc = "Gets a notification by ID."]
            pub fn get(&self, notification_id: impl Into<String>) -> GetRequestBuilder<A> {
                GetRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    notification_id: notification_id.into(),
                    locale: None,
                }
            }
            #[doc = "Subscribe to notifications"]
            pub fn watch(&self, request: crate::schemas::Channel) -> WatchRequestBuilder<A> {
                WatchRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    request,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                }
            }
        }
        #[derive(Debug, Clone)]
        pub struct GetRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            notification_id: String,
            locale: Option<String>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> GetRequestBuilder<'a, A> {
            #[doc = "Locale in which to localize messages."]
            pub fn locale(mut self, value: impl Into<String>) -> Self {
                self.locale = Some(value.into());
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::Notification, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::Notification, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("notifications/");
                {
                    let var_as_str = &self.notification_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::GET, path);
                let req = req.query(&[("locale", &self.locale)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec![
                    "https://www.googleapis.com/auth/drive.activity.readonly",
                ]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct WatchRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            request: crate::schemas::Channel,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> WatchRequestBuilder<'a, A> {
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::Channel, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::Channel, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                let req = req.json(&self.request);
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("notifications/watch");
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::POST, path);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/activity"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
    }
    pub mod parents {
        pub mod params {}
        pub struct ParentsActions<'a, A> {
            pub(crate) reqwest: &'a reqwest::Client,
            pub(crate) auth: &'a std::sync::Mutex<A>,
        }
        impl<'a, A: yup_oauth2::GetToken> ParentsActions<'a, A> {
            #[doc = "Removes a parent from a file."]
            pub fn delete(
                &self,
                file_id: impl Into<String>,
                parent_id: impl Into<String>,
            ) -> DeleteRequestBuilder<A> {
                DeleteRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    file_id: file_id.into(),
                    parent_id: parent_id.into(),
                    error_recovery: None,
                    feature_label: None,
                    mutation_precondition: None,
                    open_drive: None,
                    reason: None,
                    sync_type: None,
                }
            }
            #[doc = "Gets a specific parent reference."]
            pub fn get(
                &self,
                file_id: impl Into<String>,
                parent_id: impl Into<String>,
            ) -> GetRequestBuilder<A> {
                GetRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    file_id: file_id.into(),
                    parent_id: parent_id.into(),
                    error_recovery: None,
                    feature_label: None,
                    mutation_precondition: None,
                    open_drive: None,
                    reason: None,
                    sync_type: None,
                }
            }
            #[doc = "Adds a parent folder for a file."]
            pub fn insert(
                &self,
                request: crate::schemas::ParentReference,
                file_id: impl Into<String>,
            ) -> InsertRequestBuilder<A> {
                InsertRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    request,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    file_id: file_id.into(),
                    error_recovery: None,
                    feature_label: None,
                    mutation_precondition: None,
                    open_drive: None,
                    reason: None,
                    supports_all_drives: None,
                    supports_team_drives: None,
                    sync_type: None,
                }
            }
            #[doc = "Lists a file's parents."]
            pub fn list(&self, file_id: impl Into<String>) -> ListRequestBuilder<A> {
                ListRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    file_id: file_id.into(),
                    error_recovery: None,
                    feature_label: None,
                    mutation_precondition: None,
                    open_drive: None,
                    reason: None,
                    sync_type: None,
                }
            }
        }
        #[derive(Debug, Clone)]
        pub struct DeleteRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            file_id: String,
            parent_id: String,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            reason: Option<String>,
            sync_type: Option<i32>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> DeleteRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            pub fn execute(self) -> Result<(), Box<dyn ::std::error::Error>> {
                let req = self._request(&self._path());
                req.send()?.error_for_status()?;
                Ok(())
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files/");
                {
                    let var_as_str = &self.file_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/parents/");
                {
                    let var_as_str = &self.parent_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::DELETE, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct GetRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            file_id: String,
            parent_id: String,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            reason: Option<String>,
            sync_type: Option<i32>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> GetRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::ParentReference, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::ParentReference, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files/");
                {
                    let var_as_str = &self.file_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/parents/");
                {
                    let var_as_str = &self.parent_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::GET, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec![
                    "https://www.googleapis.com/auth/drive.metadata.readonly",
                ]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct InsertRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            request: crate::schemas::ParentReference,
            file_id: String,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            reason: Option<String>,
            supports_all_drives: Option<bool>,
            supports_team_drives: Option<bool>,
            sync_type: Option<i32>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> InsertRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Deprecated - Whether the requesting application supports both My Drives and shared drives. This parameter will only be effective until June 1, 2020. Afterwards all applications are assumed to support shared drives."]
            pub fn supports_all_drives(mut self, value: bool) -> Self {
                self.supports_all_drives = Some(value);
                self
            }
            #[doc = "Deprecated use supportsAllDrives instead."]
            pub fn supports_team_drives(mut self, value: bool) -> Self {
                self.supports_team_drives = Some(value);
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::ParentReference, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::ParentReference, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                let req = req.json(&self.request);
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files/");
                {
                    let var_as_str = &self.file_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/parents");
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::POST, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("supportsAllDrives", &self.supports_all_drives)]);
                let req = req.query(&[("supportsTeamDrives", &self.supports_team_drives)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct ListRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            file_id: String,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            reason: Option<String>,
            sync_type: Option<i32>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> ListRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::ParentList, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::ParentList, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files/");
                {
                    let var_as_str = &self.file_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/parents");
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::GET, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec![
                    "https://www.googleapis.com/auth/drive.metadata.readonly",
                ]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
    }
    pub mod permissions {
        pub mod params {}
        pub struct PermissionsActions<'a, A> {
            pub(crate) reqwest: &'a reqwest::Client,
            pub(crate) auth: &'a std::sync::Mutex<A>,
        }
        impl<'a, A: yup_oauth2::GetToken> PermissionsActions<'a, A> {
            #[doc = "Deletes a permission from a file or shared drive."]
            pub fn delete(
                &self,
                file_id: impl Into<String>,
                permission_id: impl Into<String>,
            ) -> DeleteRequestBuilder<A> {
                DeleteRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    file_id: file_id.into(),
                    permission_id: permission_id.into(),
                    confirmed: None,
                    error_recovery: None,
                    feature_label: None,
                    language_code: None,
                    mutation_precondition: None,
                    open_drive: None,
                    reason: None,
                    supports_all_drives: None,
                    supports_team_drives: None,
                    sync_type: None,
                    use_domain_admin_access: None,
                }
            }
            #[doc = "Gets a permission by ID."]
            pub fn get(
                &self,
                file_id: impl Into<String>,
                permission_id: impl Into<String>,
            ) -> GetRequestBuilder<A> {
                GetRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    file_id: file_id.into(),
                    permission_id: permission_id.into(),
                    error_recovery: None,
                    feature_label: None,
                    language_code: None,
                    mutation_precondition: None,
                    open_drive: None,
                    reason: None,
                    supports_all_drives: None,
                    supports_team_drives: None,
                    sync_type: None,
                    use_domain_admin_access: None,
                    use_legacy_domain_permission_behavior: None,
                }
            }
            #[doc = "Returns the permission ID for an email address."]
            pub fn get_id_for_email(
                &self,
                email: impl Into<String>,
            ) -> GetIdForEmailRequestBuilder<A> {
                GetIdForEmailRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    email: email.into(),
                    error_recovery: None,
                    feature_label: None,
                    mutation_precondition: None,
                    open_drive: None,
                    reason: None,
                    sync_type: None,
                }
            }
            #[doc = "Inserts a permission for a file or shared drive."]
            pub fn insert(
                &self,
                request: crate::schemas::Permission,
                file_id: impl Into<String>,
            ) -> InsertRequestBuilder<A> {
                InsertRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    request,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    file_id: file_id.into(),
                    confirmed: None,
                    email_message: None,
                    error_recovery: None,
                    feature_label: None,
                    language_code: None,
                    mutation_precondition: None,
                    open_drive: None,
                    reason: None,
                    send_notification_emails: None,
                    supports_all_drives: None,
                    supports_team_drives: None,
                    sync_type: None,
                    use_domain_admin_access: None,
                    use_legacy_domain_permission_behavior: None,
                }
            }
            #[doc = "Lists a file's or shared drive's permissions."]
            pub fn list(&self, file_id: impl Into<String>) -> ListRequestBuilder<A> {
                ListRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    file_id: file_id.into(),
                    error_recovery: None,
                    feature_label: None,
                    include_permissions_for_view: None,
                    language_code: None,
                    max_results: None,
                    mutation_precondition: None,
                    open_drive: None,
                    page_token: None,
                    reason: None,
                    supports_all_drives: None,
                    supports_team_drives: None,
                    sync_type: None,
                    use_domain_admin_access: None,
                    use_legacy_domain_permission_behavior: None,
                }
            }
            #[doc = "Updates a permission using patch semantics."]
            pub fn patch(
                &self,
                request: crate::schemas::Permission,
                file_id: impl Into<String>,
                permission_id: impl Into<String>,
            ) -> PatchRequestBuilder<A> {
                PatchRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    request,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    file_id: file_id.into(),
                    permission_id: permission_id.into(),
                    clear_expiration: None,
                    confirmed: None,
                    error_recovery: None,
                    feature_label: None,
                    language_code: None,
                    mutation_precondition: None,
                    open_drive: None,
                    reason: None,
                    remove_expiration: None,
                    supports_all_drives: None,
                    supports_team_drives: None,
                    sync_type: None,
                    transfer_ownership: None,
                    use_domain_admin_access: None,
                    use_legacy_domain_permission_behavior: None,
                }
            }
            #[doc = "Updates a permission."]
            pub fn update(
                &self,
                request: crate::schemas::Permission,
                file_id: impl Into<String>,
                permission_id: impl Into<String>,
            ) -> UpdateRequestBuilder<A> {
                UpdateRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    request,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    file_id: file_id.into(),
                    permission_id: permission_id.into(),
                    clear_expiration: None,
                    confirmed: None,
                    error_recovery: None,
                    feature_label: None,
                    language_code: None,
                    mutation_precondition: None,
                    open_drive: None,
                    reason: None,
                    remove_expiration: None,
                    supports_all_drives: None,
                    supports_team_drives: None,
                    sync_type: None,
                    transfer_ownership: None,
                    use_domain_admin_access: None,
                    use_legacy_domain_permission_behavior: None,
                }
            }
        }
        #[derive(Debug, Clone)]
        pub struct DeleteRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            file_id: String,
            permission_id: String,
            confirmed: Option<bool>,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            language_code: Option<String>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            reason: Option<String>,
            supports_all_drives: Option<bool>,
            supports_team_drives: Option<bool>,
            sync_type: Option<i32>,
            use_domain_admin_access: Option<bool>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> DeleteRequestBuilder<'a, A> {
            #[doc = "Whether the user has confirmed the permission delete request."]
            pub fn confirmed(mut self, value: bool) -> Self {
                self.confirmed = Some(value);
                self
            }
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "A language or locale code, as defined by BCP 47, with some extensions from Unicode's LDML format (http://www.unicode.org/reports/tr35/)."]
            pub fn language_code(mut self, value: impl Into<String>) -> Self {
                self.language_code = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Deprecated - Whether the requesting application supports both My Drives and shared drives. This parameter will only be effective until June 1, 2020. Afterwards all applications are assumed to support shared drives."]
            pub fn supports_all_drives(mut self, value: bool) -> Self {
                self.supports_all_drives = Some(value);
                self
            }
            #[doc = "Deprecated use supportsAllDrives instead."]
            pub fn supports_team_drives(mut self, value: bool) -> Self {
                self.supports_team_drives = Some(value);
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "Issue the request as a domain administrator; if set to true, then the requester will be granted access if the file ID parameter refers to a shared drive and the requester is an administrator of the domain to which the shared drive belongs."]
            pub fn use_domain_admin_access(mut self, value: bool) -> Self {
                self.use_domain_admin_access = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            pub fn execute(self) -> Result<(), Box<dyn ::std::error::Error>> {
                let req = self._request(&self._path());
                req.send()?.error_for_status()?;
                Ok(())
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files/");
                {
                    let var_as_str = &self.file_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/permissions/");
                {
                    let var_as_str = &self.permission_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::DELETE, path);
                let req = req.query(&[("confirmed", &self.confirmed)]);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("languageCode", &self.language_code)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("supportsAllDrives", &self.supports_all_drives)]);
                let req = req.query(&[("supportsTeamDrives", &self.supports_team_drives)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("useDomainAdminAccess", &self.use_domain_admin_access)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct GetRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            file_id: String,
            permission_id: String,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            language_code: Option<String>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            reason: Option<String>,
            supports_all_drives: Option<bool>,
            supports_team_drives: Option<bool>,
            sync_type: Option<i32>,
            use_domain_admin_access: Option<bool>,
            use_legacy_domain_permission_behavior: Option<bool>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> GetRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "A language or locale code, as defined by BCP 47, with some extensions from Unicode's LDML format (http://www.unicode.org/reports/tr35/)."]
            pub fn language_code(mut self, value: impl Into<String>) -> Self {
                self.language_code = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Deprecated - Whether the requesting application supports both My Drives and shared drives. This parameter will only be effective until June 1, 2020. Afterwards all applications are assumed to support shared drives."]
            pub fn supports_all_drives(mut self, value: bool) -> Self {
                self.supports_all_drives = Some(value);
                self
            }
            #[doc = "Deprecated use supportsAllDrives instead."]
            pub fn supports_team_drives(mut self, value: bool) -> Self {
                self.supports_team_drives = Some(value);
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "Issue the request as a domain administrator; if set to true, then the requester will be granted access if the file ID parameter refers to a shared drive and the requester is an administrator of the domain to which the shared drive belongs."]
            pub fn use_domain_admin_access(mut self, value: bool) -> Self {
                self.use_domain_admin_access = Some(value);
                self
            }
            #[doc = "If true, Permissions with type Audience are represented with Domain type."]
            pub fn use_legacy_domain_permission_behavior(mut self, value: bool) -> Self {
                self.use_legacy_domain_permission_behavior = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::Permission, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::Permission, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files/");
                {
                    let var_as_str = &self.file_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/permissions/");
                {
                    let var_as_str = &self.permission_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::GET, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("languageCode", &self.language_code)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("supportsAllDrives", &self.supports_all_drives)]);
                let req = req.query(&[("supportsTeamDrives", &self.supports_team_drives)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("useDomainAdminAccess", &self.use_domain_admin_access)]);
                let req = req.query(&[(
                    "useLegacyDomainPermissionBehavior",
                    &self.use_legacy_domain_permission_behavior,
                )]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec![
                    "https://www.googleapis.com/auth/drive.metadata.readonly",
                ]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct GetIdForEmailRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            email: String,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            reason: Option<String>,
            sync_type: Option<i32>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> GetIdForEmailRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::PermissionId, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::PermissionId, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("permissionIds/");
                {
                    let var_as_str = &self.email;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::GET, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive.apps.readonly"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct InsertRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            request: crate::schemas::Permission,
            file_id: String,
            confirmed: Option<bool>,
            email_message: Option<String>,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            language_code: Option<String>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            reason: Option<String>,
            send_notification_emails: Option<bool>,
            supports_all_drives: Option<bool>,
            supports_team_drives: Option<bool>,
            sync_type: Option<i32>,
            use_domain_admin_access: Option<bool>,
            use_legacy_domain_permission_behavior: Option<bool>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> InsertRequestBuilder<'a, A> {
            #[doc = "Whether the user has confirmed the sharing request."]
            pub fn confirmed(mut self, value: bool) -> Self {
                self.confirmed = Some(value);
                self
            }
            #[doc = "A plain text custom message to include in notification emails."]
            pub fn email_message(mut self, value: impl Into<String>) -> Self {
                self.email_message = Some(value.into());
                self
            }
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "A language or locale code, as defined by BCP 47, with some extensions from Unicode's LDML format (http://www.unicode.org/reports/tr35/)."]
            pub fn language_code(mut self, value: impl Into<String>) -> Self {
                self.language_code = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether to send notification emails when sharing to users or groups."]
            pub fn send_notification_emails(mut self, value: bool) -> Self {
                self.send_notification_emails = Some(value);
                self
            }
            #[doc = "Deprecated - Whether the requesting application supports both My Drives and shared drives. This parameter will only be effective until June 1, 2020. Afterwards all applications are assumed to support shared drives."]
            pub fn supports_all_drives(mut self, value: bool) -> Self {
                self.supports_all_drives = Some(value);
                self
            }
            #[doc = "Deprecated use supportsAllDrives instead."]
            pub fn supports_team_drives(mut self, value: bool) -> Self {
                self.supports_team_drives = Some(value);
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "Issue the request as a domain administrator; if set to true, then the requester will be granted access if the file ID parameter refers to a shared drive and the requester is an administrator of the domain to which the shared drive belongs."]
            pub fn use_domain_admin_access(mut self, value: bool) -> Self {
                self.use_domain_admin_access = Some(value);
                self
            }
            #[doc = "If true, Permissions with type Audience are represented with Domain type."]
            pub fn use_legacy_domain_permission_behavior(mut self, value: bool) -> Self {
                self.use_legacy_domain_permission_behavior = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::Permission, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::Permission, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                let req = req.json(&self.request);
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files/");
                {
                    let var_as_str = &self.file_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/permissions");
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::POST, path);
                let req = req.query(&[("confirmed", &self.confirmed)]);
                let req = req.query(&[("emailMessage", &self.email_message)]);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("languageCode", &self.language_code)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("sendNotificationEmails", &self.send_notification_emails)]);
                let req = req.query(&[("supportsAllDrives", &self.supports_all_drives)]);
                let req = req.query(&[("supportsTeamDrives", &self.supports_team_drives)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("useDomainAdminAccess", &self.use_domain_admin_access)]);
                let req = req.query(&[(
                    "useLegacyDomainPermissionBehavior",
                    &self.use_legacy_domain_permission_behavior,
                )]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct ListRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            file_id: String,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            include_permissions_for_view: Option<String>,
            language_code: Option<String>,
            max_results: Option<i32>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            page_token: Option<String>,
            reason: Option<String>,
            supports_all_drives: Option<bool>,
            supports_team_drives: Option<bool>,
            sync_type: Option<i32>,
            use_domain_admin_access: Option<bool>,
            use_legacy_domain_permission_behavior: Option<bool>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> ListRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "Specifies which additional view's permissions to include in the response. Only 'published' is supported."]
            pub fn include_permissions_for_view(mut self, value: impl Into<String>) -> Self {
                self.include_permissions_for_view = Some(value.into());
                self
            }
            #[doc = "A language or locale code, as defined by BCP 47, with some extensions from Unicode's LDML format (http://www.unicode.org/reports/tr35/)."]
            pub fn language_code(mut self, value: impl Into<String>) -> Self {
                self.language_code = Some(value.into());
                self
            }
            #[doc = "The maximum number of permissions to return per page. When not set for files in a shared drive, at most 100 results will be returned. When not set for files that are not in a shared drive, the entire list will be returned."]
            pub fn max_results(mut self, value: i32) -> Self {
                self.max_results = Some(value);
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The token for continuing a previous list request on the next page. This should be set to the value of 'nextPageToken' from the previous response."]
            pub fn page_token(mut self, value: impl Into<String>) -> Self {
                self.page_token = Some(value.into());
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Deprecated - Whether the requesting application supports both My Drives and shared drives. This parameter will only be effective until June 1, 2020. Afterwards all applications are assumed to support shared drives."]
            pub fn supports_all_drives(mut self, value: bool) -> Self {
                self.supports_all_drives = Some(value);
                self
            }
            #[doc = "Deprecated use supportsAllDrives instead."]
            pub fn supports_team_drives(mut self, value: bool) -> Self {
                self.supports_team_drives = Some(value);
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "Issue the request as a domain administrator; if set to true, then the requester will be granted access if the file ID parameter refers to a shared drive and the requester is an administrator of the domain to which the shared drive belongs."]
            pub fn use_domain_admin_access(mut self, value: bool) -> Self {
                self.use_domain_admin_access = Some(value);
                self
            }
            #[doc = "If true, Permissions with type Audience are represented with Domain type."]
            pub fn use_legacy_domain_permission_behavior(mut self, value: bool) -> Self {
                self.use_legacy_domain_permission_behavior = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Return an iterator that iterates over all `#prop_ident`. The"]
            #[doc = r" items yielded by the iterator are chosen by the caller of this"]
            #[doc = r" method and must implement `Deserialize` and `FieldSelector`. The"]
            #[doc = r" populated fields in the yielded items will be determined by the"]
            #[doc = r" `FieldSelector` implementation."]
            pub fn iter_items<T>(mut self) -> crate::iter::PageItemIter<Self, T>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let mut fields = concat!("nextPageToken,", "items").to_owned();
                let items_fields = T::field_selector();
                if !items_fields.is_empty() {
                    fields.push_str("(");
                    fields.push_str(&items_fields);
                    fields.push_str(")");
                }
                self.fields = Some(fields);
                crate::iter::PageItemIter::new(self, "items")
            }
            #[doc = r" Return an iterator that iterates over all `#prop_ident`. The"]
            #[doc = r" items yielded by the iterator are `#items_type`. The populated"]
            #[doc = r" fields in `#items_type` will be the default fields populated by"]
            #[doc = r" the server."]
            pub fn iter_items_standard(
                mut self,
            ) -> crate::iter::PageItemIter<Self, crate::schemas::Permission> {
                self.fields = Some(concat!("nextPageToken,", "items").to_owned());
                crate::iter::PageItemIter::new(self, "items")
            }
            #[doc = r" Return an iterator that iterates over all `#prop_ident`. The"]
            #[doc = r" items yielded by the iterator are `#items_type`. The populated"]
            #[doc = r" fields in `#items_type` will be all fields available. This should"]
            #[doc = r" primarily be used during developement and debugging as fetching"]
            #[doc = r" all fields can be expensive both in bandwidth and server"]
            #[doc = r" resources."]
            pub fn iter_items_debug(
                mut self,
            ) -> crate::iter::PageItemIter<Self, crate::schemas::Permission> {
                self.fields = Some(concat!("nextPageToken,", "items", "(*)").to_owned());
                crate::iter::PageItemIter::new(self, "items")
            }
            pub fn iter<T>(mut self) -> crate::iter::PageIter<Self, T>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let mut fields = T::field_selector();
                if !fields.is_empty() {
                    match fields.chars().rev().nth(0) {
                        Some(',') | None => {}
                        _ => fields.push_str(","),
                    }
                    fields.push_str("nextPageToken");
                    self.fields = Some(fields);
                }
                crate::iter::PageIter::new(self)
            }
            pub fn iter_standard(
                self,
            ) -> crate::iter::PageIter<Self, crate::schemas::PermissionList> {
                crate::iter::PageIter::new(self)
            }
            pub fn iter_debug(
                mut self,
            ) -> crate::iter::PageIter<Self, crate::schemas::PermissionList> {
                self.fields = Some("*".to_owned());
                crate::iter::PageIter::new(self)
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::PermissionList, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::PermissionList, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files/");
                {
                    let var_as_str = &self.file_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/permissions");
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::GET, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[(
                    "includePermissionsForView",
                    &self.include_permissions_for_view,
                )]);
                let req = req.query(&[("languageCode", &self.language_code)]);
                let req = req.query(&[("maxResults", &self.max_results)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("pageToken", &self.page_token)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("supportsAllDrives", &self.supports_all_drives)]);
                let req = req.query(&[("supportsTeamDrives", &self.supports_team_drives)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("useDomainAdminAccess", &self.use_domain_admin_access)]);
                let req = req.query(&[(
                    "useLegacyDomainPermissionBehavior",
                    &self.use_legacy_domain_permission_behavior,
                )]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec![
                    "https://www.googleapis.com/auth/drive.metadata.readonly",
                ]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        impl<'a, A: yup_oauth2::GetToken> crate::iter::IterableMethod for ListRequestBuilder<'a, A> {
            fn set_page_token(&mut self, value: String) {
                self.page_token = value.into();
            }
            fn execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                self._execute()
            }
        }
        #[derive(Debug, Clone)]
        pub struct PatchRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            request: crate::schemas::Permission,
            file_id: String,
            permission_id: String,
            clear_expiration: Option<bool>,
            confirmed: Option<bool>,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            language_code: Option<String>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            reason: Option<String>,
            remove_expiration: Option<bool>,
            supports_all_drives: Option<bool>,
            supports_team_drives: Option<bool>,
            sync_type: Option<i32>,
            transfer_ownership: Option<bool>,
            use_domain_admin_access: Option<bool>,
            use_legacy_domain_permission_behavior: Option<bool>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> PatchRequestBuilder<'a, A> {
            #[doc = "DO NOT USE. USE removeExpiration."]
            pub fn clear_expiration(mut self, value: bool) -> Self {
                self.clear_expiration = Some(value);
                self
            }
            #[doc = "Whether the user has confirmed the permission patch request."]
            pub fn confirmed(mut self, value: bool) -> Self {
                self.confirmed = Some(value);
                self
            }
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "A language or locale code, as defined by BCP 47, with some extensions from Unicode's LDML format (http://www.unicode.org/reports/tr35/)."]
            pub fn language_code(mut self, value: impl Into<String>) -> Self {
                self.language_code = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether to remove the expiration date."]
            pub fn remove_expiration(mut self, value: bool) -> Self {
                self.remove_expiration = Some(value);
                self
            }
            #[doc = "Deprecated - Whether the requesting application supports both My Drives and shared drives. This parameter will only be effective until June 1, 2020. Afterwards all applications are assumed to support shared drives."]
            pub fn supports_all_drives(mut self, value: bool) -> Self {
                self.supports_all_drives = Some(value);
                self
            }
            #[doc = "Deprecated use supportsAllDrives instead."]
            pub fn supports_team_drives(mut self, value: bool) -> Self {
                self.supports_team_drives = Some(value);
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "Whether changing a role to 'owner' downgrades the current owners to writers. Does nothing if the specified role is not 'owner'."]
            pub fn transfer_ownership(mut self, value: bool) -> Self {
                self.transfer_ownership = Some(value);
                self
            }
            #[doc = "Issue the request as a domain administrator; if set to true, then the requester will be granted access if the file ID parameter refers to a shared drive and the requester is an administrator of the domain to which the shared drive belongs."]
            pub fn use_domain_admin_access(mut self, value: bool) -> Self {
                self.use_domain_admin_access = Some(value);
                self
            }
            #[doc = "If true, Permissions with type Audience are represented with Domain type."]
            pub fn use_legacy_domain_permission_behavior(mut self, value: bool) -> Self {
                self.use_legacy_domain_permission_behavior = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::Permission, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::Permission, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                let req = req.json(&self.request);
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files/");
                {
                    let var_as_str = &self.file_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/permissions/");
                {
                    let var_as_str = &self.permission_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::PATCH, path);
                let req = req.query(&[("clearExpiration", &self.clear_expiration)]);
                let req = req.query(&[("confirmed", &self.confirmed)]);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("languageCode", &self.language_code)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("removeExpiration", &self.remove_expiration)]);
                let req = req.query(&[("supportsAllDrives", &self.supports_all_drives)]);
                let req = req.query(&[("supportsTeamDrives", &self.supports_team_drives)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("transferOwnership", &self.transfer_ownership)]);
                let req = req.query(&[("useDomainAdminAccess", &self.use_domain_admin_access)]);
                let req = req.query(&[(
                    "useLegacyDomainPermissionBehavior",
                    &self.use_legacy_domain_permission_behavior,
                )]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct UpdateRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            request: crate::schemas::Permission,
            file_id: String,
            permission_id: String,
            clear_expiration: Option<bool>,
            confirmed: Option<bool>,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            language_code: Option<String>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            reason: Option<String>,
            remove_expiration: Option<bool>,
            supports_all_drives: Option<bool>,
            supports_team_drives: Option<bool>,
            sync_type: Option<i32>,
            transfer_ownership: Option<bool>,
            use_domain_admin_access: Option<bool>,
            use_legacy_domain_permission_behavior: Option<bool>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> UpdateRequestBuilder<'a, A> {
            #[doc = "DO NOT USE. USE removeExpiration"]
            pub fn clear_expiration(mut self, value: bool) -> Self {
                self.clear_expiration = Some(value);
                self
            }
            #[doc = "Whether the user has confirmed the permission update request."]
            pub fn confirmed(mut self, value: bool) -> Self {
                self.confirmed = Some(value);
                self
            }
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "A language or locale code, as defined by BCP 47, with some extensions from Unicode's LDML format (http://www.unicode.org/reports/tr35/)."]
            pub fn language_code(mut self, value: impl Into<String>) -> Self {
                self.language_code = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether to remove the expiration date."]
            pub fn remove_expiration(mut self, value: bool) -> Self {
                self.remove_expiration = Some(value);
                self
            }
            #[doc = "Deprecated - Whether the requesting application supports both My Drives and shared drives. This parameter will only be effective until June 1, 2020. Afterwards all applications are assumed to support shared drives."]
            pub fn supports_all_drives(mut self, value: bool) -> Self {
                self.supports_all_drives = Some(value);
                self
            }
            #[doc = "Deprecated use supportsAllDrives instead."]
            pub fn supports_team_drives(mut self, value: bool) -> Self {
                self.supports_team_drives = Some(value);
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "Whether changing a role to 'owner' downgrades the current owners to writers. Does nothing if the specified role is not 'owner'."]
            pub fn transfer_ownership(mut self, value: bool) -> Self {
                self.transfer_ownership = Some(value);
                self
            }
            #[doc = "Issue the request as a domain administrator; if set to true, then the requester will be granted access if the file ID parameter refers to a shared drive and the requester is an administrator of the domain to which the shared drive belongs."]
            pub fn use_domain_admin_access(mut self, value: bool) -> Self {
                self.use_domain_admin_access = Some(value);
                self
            }
            #[doc = "If true, Permissions with type Audience are represented with Domain type."]
            pub fn use_legacy_domain_permission_behavior(mut self, value: bool) -> Self {
                self.use_legacy_domain_permission_behavior = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::Permission, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::Permission, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                let req = req.json(&self.request);
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files/");
                {
                    let var_as_str = &self.file_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/permissions/");
                {
                    let var_as_str = &self.permission_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::PUT, path);
                let req = req.query(&[("clearExpiration", &self.clear_expiration)]);
                let req = req.query(&[("confirmed", &self.confirmed)]);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("languageCode", &self.language_code)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("removeExpiration", &self.remove_expiration)]);
                let req = req.query(&[("supportsAllDrives", &self.supports_all_drives)]);
                let req = req.query(&[("supportsTeamDrives", &self.supports_team_drives)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("transferOwnership", &self.transfer_ownership)]);
                let req = req.query(&[("useDomainAdminAccess", &self.use_domain_admin_access)]);
                let req = req.query(&[(
                    "useLegacyDomainPermissionBehavior",
                    &self.use_legacy_domain_permission_behavior,
                )]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
    }
    pub mod properties {
        pub mod params {}
        pub struct PropertiesActions<'a, A> {
            pub(crate) reqwest: &'a reqwest::Client,
            pub(crate) auth: &'a std::sync::Mutex<A>,
        }
        impl<'a, A: yup_oauth2::GetToken> PropertiesActions<'a, A> {
            #[doc = "Deletes a property."]
            pub fn delete(
                &self,
                file_id: impl Into<String>,
                property_key: impl Into<String>,
            ) -> DeleteRequestBuilder<A> {
                DeleteRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    file_id: file_id.into(),
                    property_key: property_key.into(),
                    error_recovery: None,
                    feature_label: None,
                    mutation_precondition: None,
                    open_drive: None,
                    reason: None,
                    sync_type: None,
                    visibility: None,
                }
            }
            #[doc = "Gets a property by its key."]
            pub fn get(
                &self,
                file_id: impl Into<String>,
                property_key: impl Into<String>,
            ) -> GetRequestBuilder<A> {
                GetRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    file_id: file_id.into(),
                    property_key: property_key.into(),
                    error_recovery: None,
                    feature_label: None,
                    mutation_precondition: None,
                    open_drive: None,
                    reason: None,
                    sync_type: None,
                    visibility: None,
                }
            }
            #[doc = "Adds a property to a file."]
            pub fn insert(
                &self,
                request: crate::schemas::Property,
                file_id: impl Into<String>,
            ) -> InsertRequestBuilder<A> {
                InsertRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    request,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    file_id: file_id.into(),
                    error_recovery: None,
                    feature_label: None,
                    mutation_precondition: None,
                    open_drive: None,
                    reason: None,
                    sync_type: None,
                }
            }
            #[doc = "Lists a file's properties."]
            pub fn list(&self, file_id: impl Into<String>) -> ListRequestBuilder<A> {
                ListRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    file_id: file_id.into(),
                    all_properties: None,
                    error_recovery: None,
                    feature_label: None,
                    mutation_precondition: None,
                    open_drive: None,
                    reason: None,
                    sync_type: None,
                }
            }
            #[doc = "Updates a property."]
            pub fn patch(
                &self,
                request: crate::schemas::Property,
                file_id: impl Into<String>,
                property_key: impl Into<String>,
            ) -> PatchRequestBuilder<A> {
                PatchRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    request,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    file_id: file_id.into(),
                    property_key: property_key.into(),
                    error_recovery: None,
                    feature_label: None,
                    mutation_precondition: None,
                    open_drive: None,
                    reason: None,
                    sync_type: None,
                    visibility: None,
                }
            }
            #[doc = "Updates a property."]
            pub fn update(
                &self,
                request: crate::schemas::Property,
                file_id: impl Into<String>,
                property_key: impl Into<String>,
            ) -> UpdateRequestBuilder<A> {
                UpdateRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    request,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    file_id: file_id.into(),
                    property_key: property_key.into(),
                    error_recovery: None,
                    feature_label: None,
                    mutation_precondition: None,
                    open_drive: None,
                    reason: None,
                    sync_type: None,
                    visibility: None,
                }
            }
        }
        #[derive(Debug, Clone)]
        pub struct DeleteRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            file_id: String,
            property_key: String,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            reason: Option<String>,
            sync_type: Option<i32>,
            visibility: Option<String>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> DeleteRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "The visibility of the property."]
            pub fn visibility(mut self, value: impl Into<String>) -> Self {
                self.visibility = Some(value.into());
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            pub fn execute(self) -> Result<(), Box<dyn ::std::error::Error>> {
                let req = self._request(&self._path());
                req.send()?.error_for_status()?;
                Ok(())
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files/");
                {
                    let var_as_str = &self.file_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/properties/");
                {
                    let var_as_str = &self.property_key;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::DELETE, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("visibility", &self.visibility)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct GetRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            file_id: String,
            property_key: String,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            reason: Option<String>,
            sync_type: Option<i32>,
            visibility: Option<String>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> GetRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "The visibility of the property."]
            pub fn visibility(mut self, value: impl Into<String>) -> Self {
                self.visibility = Some(value.into());
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::Property, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::Property, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files/");
                {
                    let var_as_str = &self.file_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/properties/");
                {
                    let var_as_str = &self.property_key;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::GET, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("visibility", &self.visibility)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec![
                    "https://www.googleapis.com/auth/drive.metadata.readonly",
                ]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct InsertRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            request: crate::schemas::Property,
            file_id: String,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            reason: Option<String>,
            sync_type: Option<i32>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> InsertRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::Property, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::Property, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                let req = req.json(&self.request);
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files/");
                {
                    let var_as_str = &self.file_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/properties");
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::POST, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct ListRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            file_id: String,
            all_properties: Option<bool>,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            reason: Option<String>,
            sync_type: Option<i32>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> ListRequestBuilder<'a, A> {
            #[doc = "Whether to retrieve all properties, not just those visible to the app."]
            pub fn all_properties(mut self, value: bool) -> Self {
                self.all_properties = Some(value);
                self
            }
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::PropertyList, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::PropertyList, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files/");
                {
                    let var_as_str = &self.file_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/properties");
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::GET, path);
                let req = req.query(&[("allProperties", &self.all_properties)]);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec![
                    "https://www.googleapis.com/auth/drive.metadata.readonly",
                ]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct PatchRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            request: crate::schemas::Property,
            file_id: String,
            property_key: String,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            reason: Option<String>,
            sync_type: Option<i32>,
            visibility: Option<String>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> PatchRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "The visibility of the property. Allowed values are PRIVATE and PUBLIC. (Default: PRIVATE)"]
            pub fn visibility(mut self, value: impl Into<String>) -> Self {
                self.visibility = Some(value.into());
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::Property, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::Property, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                let req = req.json(&self.request);
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files/");
                {
                    let var_as_str = &self.file_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/properties/");
                {
                    let var_as_str = &self.property_key;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::PATCH, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("visibility", &self.visibility)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct UpdateRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            request: crate::schemas::Property,
            file_id: String,
            property_key: String,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            reason: Option<String>,
            sync_type: Option<i32>,
            visibility: Option<String>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> UpdateRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "The visibility of the property. Allowed values are PRIVATE and PUBLIC. (Default: PRIVATE)"]
            pub fn visibility(mut self, value: impl Into<String>) -> Self {
                self.visibility = Some(value.into());
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::Property, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::Property, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                let req = req.json(&self.request);
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files/");
                {
                    let var_as_str = &self.file_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/properties/");
                {
                    let var_as_str = &self.property_key;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::PUT, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("visibility", &self.visibility)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
    }
    pub mod realtime {
        pub mod params {}
        pub struct RealtimeActions<'a, A> {
            pub(crate) reqwest: &'a reqwest::Client,
            pub(crate) auth: &'a std::sync::Mutex<A>,
        }
        impl<'a, A: yup_oauth2::GetToken> RealtimeActions<'a, A> {
            #[doc = "Exports the contents of the Realtime API data model associated with this file as JSON."]
            pub fn get(&self, file_id: impl Into<String>) -> GetRequestBuilder<A> {
                GetRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    file_id: file_id.into(),
                    revision: None,
                }
            }
            #[doc = "Overwrites the Realtime API data model associated with this file with the provided JSON data model."]
            pub fn update(&self, file_id: impl Into<String>) -> UpdateRequestBuilder<A> {
                UpdateRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    file_id: file_id.into(),
                    base_revision: None,
                }
            }
        }
        #[derive(Debug, Clone)]
        pub struct GetRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            file_id: String,
            revision: Option<i32>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> GetRequestBuilder<'a, A> {
            #[doc = "The revision of the Realtime API data model to export. Revisions start at 1 (the initial empty data model) and are incremented with each change. If this parameter is excluded, the most recent data model will be returned."]
            pub fn revision(mut self, value: i32) -> Self {
                self.revision = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            fn _download_path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/download/".to_owned();
                output.push_str("files/");
                {
                    let var_as_str = &self.file_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/realtime");
                output
            }
            pub fn download<W>(
                mut self,
                output: &mut W,
            ) -> Result<u64, Box<dyn ::std::error::Error>>
            where
                W: ::std::io::Write + ?Sized,
            {
                self.alt = Some(crate::params::Alt::Media);
                Ok(self
                    ._request(&self._path())
                    .send()?
                    .error_for_status()?
                    .copy_to(output)?)
            }
            pub fn execute(self) -> Result<(), Box<dyn ::std::error::Error>> {
                let req = self._request(&self._path());
                req.send()?.error_for_status()?;
                Ok(())
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files/");
                {
                    let var_as_str = &self.file_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/realtime");
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::GET, path);
                let req = req.query(&[("revision", &self.revision)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive.readonly"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct UpdateRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            file_id: String,
            base_revision: Option<String>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> UpdateRequestBuilder<'a, A> {
            #[doc = "The revision of the model to diff the uploaded model against. If set, the uploaded model is diffed against the provided revision and those differences are merged with any changes made to the model after the provided revision. If not set, the uploaded model replaces the current model on the server."]
            pub fn base_revision(mut self, value: impl Into<String>) -> Self {
                self.base_revision = Some(value.into());
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            fn _simple_upload_path(&self) -> String {
                let mut output = "https://www.googleapis.com/".to_owned();
                output.push_str("upload/drive/v2.1beta/files/");
                {
                    let var_as_str = &self.file_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/realtime");
                output
            }
            pub fn upload<R>(
                self,
                content: R,
                mime_type: ::mime::Mime,
            ) -> Result<(), Box<dyn ::std::error::Error>>
            where
                R: ::std::io::Read + ::std::io::Seek + Send + 'static,
            {
                let req = self._request(&self._simple_upload_path());
                let req = req.query(&[("uploadType", "multipart")]);
                use crate::multipart::{Part, RelatedMultiPart};
                let mut multipart = RelatedMultiPart::new();
                multipart.new_part(Part::new(mime_type, Box::new(content)));
                let req = req.header(
                    ::reqwest::header::CONTENT_TYPE,
                    format!("multipart/related; boundary={}", multipart.boundary()),
                );
                let req = req.body(reqwest::Body::new(multipart.into_reader()));
                req.send()?.error_for_status()?;
                Ok(())
            }
            fn _resumable_upload_path(&self) -> String {
                let mut output = "https://www.googleapis.com/".to_owned();
                output.push_str("resumable/upload/drive/v2.1beta/files/");
                {
                    let var_as_str = &self.file_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/realtime");
                output
            }
            pub fn start_resumable_upload(
                self,
                mime_type: ::mime::Mime,
            ) -> Result<crate::ResumableUpload, Box<dyn ::std::error::Error>> {
                let req = self._request(&self._resumable_upload_path());
                let req = req.query(&[("uploadType", "resumable")]);
                let req = req.header(
                    ::reqwest::header::HeaderName::from_static("x-upload-content-type"),
                    mime_type.to_string(),
                );
                let resp = req.send()?.error_for_status()?;
                let location_header =
                    resp.headers()
                        .get(::reqwest::header::LOCATION)
                        .ok_or_else(|| {
                            format!("No LOCATION header returned when initiating resumable upload")
                        })?;
                let upload_url = ::std::str::from_utf8(location_header.as_bytes())?.to_owned();
                Ok(crate::ResumableUpload::new(
                    self.reqwest.clone(),
                    upload_url,
                ))
            }
            pub fn execute(self) -> Result<(), Box<dyn ::std::error::Error>> {
                let req = self._request(&self._path());
                req.send()?.error_for_status()?;
                Ok(())
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files/");
                {
                    let var_as_str = &self.file_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/realtime");
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::PUT, path);
                let req = req.query(&[("baseRevision", &self.base_revision)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
    }
    pub mod replies {
        pub mod params {}
        pub struct RepliesActions<'a, A> {
            pub(crate) reqwest: &'a reqwest::Client,
            pub(crate) auth: &'a std::sync::Mutex<A>,
        }
        impl<'a, A: yup_oauth2::GetToken> RepliesActions<'a, A> {
            #[doc = "Deletes a reply."]
            pub fn delete(
                &self,
                file_id: impl Into<String>,
                comment_id: impl Into<String>,
                reply_id: impl Into<String>,
            ) -> DeleteRequestBuilder<A> {
                DeleteRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    file_id: file_id.into(),
                    comment_id: comment_id.into(),
                    reply_id: reply_id.into(),
                }
            }
            #[doc = "Gets a reply."]
            pub fn get(
                &self,
                file_id: impl Into<String>,
                comment_id: impl Into<String>,
                reply_id: impl Into<String>,
            ) -> GetRequestBuilder<A> {
                GetRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    file_id: file_id.into(),
                    comment_id: comment_id.into(),
                    reply_id: reply_id.into(),
                    include_deleted: None,
                }
            }
            #[doc = "Creates a new reply to the given comment."]
            pub fn insert(
                &self,
                request: crate::schemas::CommentReply,
                file_id: impl Into<String>,
                comment_id: impl Into<String>,
            ) -> InsertRequestBuilder<A> {
                InsertRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    request,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    file_id: file_id.into(),
                    comment_id: comment_id.into(),
                }
            }
            #[doc = "Lists all of the replies to a comment."]
            pub fn list(
                &self,
                file_id: impl Into<String>,
                comment_id: impl Into<String>,
            ) -> ListRequestBuilder<A> {
                ListRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    file_id: file_id.into(),
                    comment_id: comment_id.into(),
                    include_deleted: None,
                    max_results: None,
                    page_token: None,
                }
            }
            #[doc = "Updates an existing reply. This method supports patch semantics."]
            pub fn patch(
                &self,
                request: crate::schemas::CommentReply,
                file_id: impl Into<String>,
                comment_id: impl Into<String>,
                reply_id: impl Into<String>,
            ) -> PatchRequestBuilder<A> {
                PatchRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    request,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    file_id: file_id.into(),
                    comment_id: comment_id.into(),
                    reply_id: reply_id.into(),
                }
            }
            #[doc = "Updates an existing reply."]
            pub fn update(
                &self,
                request: crate::schemas::CommentReply,
                file_id: impl Into<String>,
                comment_id: impl Into<String>,
                reply_id: impl Into<String>,
            ) -> UpdateRequestBuilder<A> {
                UpdateRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    request,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    file_id: file_id.into(),
                    comment_id: comment_id.into(),
                    reply_id: reply_id.into(),
                }
            }
        }
        #[derive(Debug, Clone)]
        pub struct DeleteRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            file_id: String,
            comment_id: String,
            reply_id: String,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> DeleteRequestBuilder<'a, A> {
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            pub fn execute(self) -> Result<(), Box<dyn ::std::error::Error>> {
                let req = self._request(&self._path());
                req.send()?.error_for_status()?;
                Ok(())
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files/");
                {
                    let var_as_str = &self.file_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/comments/");
                {
                    let var_as_str = &self.comment_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/replies/");
                {
                    let var_as_str = &self.reply_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::DELETE, path);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct GetRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            file_id: String,
            comment_id: String,
            reply_id: String,
            include_deleted: Option<bool>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> GetRequestBuilder<'a, A> {
            #[doc = "If set, this will succeed when retrieving a deleted reply."]
            pub fn include_deleted(mut self, value: bool) -> Self {
                self.include_deleted = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::CommentReply, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::CommentReply, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files/");
                {
                    let var_as_str = &self.file_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/comments/");
                {
                    let var_as_str = &self.comment_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/replies/");
                {
                    let var_as_str = &self.reply_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::GET, path);
                let req = req.query(&[("includeDeleted", &self.include_deleted)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive.readonly"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct InsertRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            request: crate::schemas::CommentReply,
            file_id: String,
            comment_id: String,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> InsertRequestBuilder<'a, A> {
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::CommentReply, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::CommentReply, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                let req = req.json(&self.request);
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files/");
                {
                    let var_as_str = &self.file_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/comments/");
                {
                    let var_as_str = &self.comment_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/replies");
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::POST, path);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct ListRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            file_id: String,
            comment_id: String,
            include_deleted: Option<bool>,
            max_results: Option<i32>,
            page_token: Option<String>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> ListRequestBuilder<'a, A> {
            #[doc = "If set, all replies, including deleted replies (with content stripped) will be returned."]
            pub fn include_deleted(mut self, value: bool) -> Self {
                self.include_deleted = Some(value);
                self
            }
            #[doc = "The maximum number of replies to include in the response, used for paging."]
            pub fn max_results(mut self, value: i32) -> Self {
                self.max_results = Some(value);
                self
            }
            #[doc = "The continuation token, used to page through large result sets. To get the next page of results, set this parameter to the value of \"nextPageToken\" from the previous response."]
            pub fn page_token(mut self, value: impl Into<String>) -> Self {
                self.page_token = Some(value.into());
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Return an iterator that iterates over all `#prop_ident`. The"]
            #[doc = r" items yielded by the iterator are chosen by the caller of this"]
            #[doc = r" method and must implement `Deserialize` and `FieldSelector`. The"]
            #[doc = r" populated fields in the yielded items will be determined by the"]
            #[doc = r" `FieldSelector` implementation."]
            pub fn iter_items<T>(mut self) -> crate::iter::PageItemIter<Self, T>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let mut fields = concat!("nextPageToken,", "items").to_owned();
                let items_fields = T::field_selector();
                if !items_fields.is_empty() {
                    fields.push_str("(");
                    fields.push_str(&items_fields);
                    fields.push_str(")");
                }
                self.fields = Some(fields);
                crate::iter::PageItemIter::new(self, "items")
            }
            #[doc = r" Return an iterator that iterates over all `#prop_ident`. The"]
            #[doc = r" items yielded by the iterator are `#items_type`. The populated"]
            #[doc = r" fields in `#items_type` will be the default fields populated by"]
            #[doc = r" the server."]
            pub fn iter_items_standard(
                mut self,
            ) -> crate::iter::PageItemIter<Self, crate::schemas::CommentReply> {
                self.fields = Some(concat!("nextPageToken,", "items").to_owned());
                crate::iter::PageItemIter::new(self, "items")
            }
            #[doc = r" Return an iterator that iterates over all `#prop_ident`. The"]
            #[doc = r" items yielded by the iterator are `#items_type`. The populated"]
            #[doc = r" fields in `#items_type` will be all fields available. This should"]
            #[doc = r" primarily be used during developement and debugging as fetching"]
            #[doc = r" all fields can be expensive both in bandwidth and server"]
            #[doc = r" resources."]
            pub fn iter_items_debug(
                mut self,
            ) -> crate::iter::PageItemIter<Self, crate::schemas::CommentReply> {
                self.fields = Some(concat!("nextPageToken,", "items", "(*)").to_owned());
                crate::iter::PageItemIter::new(self, "items")
            }
            pub fn iter<T>(mut self) -> crate::iter::PageIter<Self, T>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let mut fields = T::field_selector();
                if !fields.is_empty() {
                    match fields.chars().rev().nth(0) {
                        Some(',') | None => {}
                        _ => fields.push_str(","),
                    }
                    fields.push_str("nextPageToken");
                    self.fields = Some(fields);
                }
                crate::iter::PageIter::new(self)
            }
            pub fn iter_standard(
                self,
            ) -> crate::iter::PageIter<Self, crate::schemas::CommentReplyList> {
                crate::iter::PageIter::new(self)
            }
            pub fn iter_debug(
                mut self,
            ) -> crate::iter::PageIter<Self, crate::schemas::CommentReplyList> {
                self.fields = Some("*".to_owned());
                crate::iter::PageIter::new(self)
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::CommentReplyList, Box<dyn ::std::error::Error>>
            {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::CommentReplyList, Box<dyn ::std::error::Error>>
            {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files/");
                {
                    let var_as_str = &self.file_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/comments/");
                {
                    let var_as_str = &self.comment_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/replies");
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::GET, path);
                let req = req.query(&[("includeDeleted", &self.include_deleted)]);
                let req = req.query(&[("maxResults", &self.max_results)]);
                let req = req.query(&[("pageToken", &self.page_token)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive.readonly"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        impl<'a, A: yup_oauth2::GetToken> crate::iter::IterableMethod for ListRequestBuilder<'a, A> {
            fn set_page_token(&mut self, value: String) {
                self.page_token = value.into();
            }
            fn execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                self._execute()
            }
        }
        #[derive(Debug, Clone)]
        pub struct PatchRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            request: crate::schemas::CommentReply,
            file_id: String,
            comment_id: String,
            reply_id: String,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> PatchRequestBuilder<'a, A> {
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::CommentReply, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::CommentReply, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                let req = req.json(&self.request);
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files/");
                {
                    let var_as_str = &self.file_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/comments/");
                {
                    let var_as_str = &self.comment_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/replies/");
                {
                    let var_as_str = &self.reply_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::PATCH, path);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct UpdateRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            request: crate::schemas::CommentReply,
            file_id: String,
            comment_id: String,
            reply_id: String,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> UpdateRequestBuilder<'a, A> {
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::CommentReply, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::CommentReply, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                let req = req.json(&self.request);
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files/");
                {
                    let var_as_str = &self.file_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/comments/");
                {
                    let var_as_str = &self.comment_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/replies/");
                {
                    let var_as_str = &self.reply_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::PUT, path);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
    }
    pub mod revisions {
        pub mod params {}
        pub struct RevisionsActions<'a, A> {
            pub(crate) reqwest: &'a reqwest::Client,
            pub(crate) auth: &'a std::sync::Mutex<A>,
        }
        impl<'a, A: yup_oauth2::GetToken> RevisionsActions<'a, A> {
            #[doc = "Removes a revision."]
            pub fn delete(
                &self,
                file_id: impl Into<String>,
                revision_id: impl Into<String>,
            ) -> DeleteRequestBuilder<A> {
                DeleteRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    file_id: file_id.into(),
                    revision_id: revision_id.into(),
                    error_recovery: None,
                    feature_label: None,
                    mutation_precondition: None,
                    open_drive: None,
                    reason: None,
                    sync_type: None,
                }
            }
            #[doc = "Gets a specific revision."]
            pub fn get(
                &self,
                file_id: impl Into<String>,
                revision_id: impl Into<String>,
            ) -> GetRequestBuilder<A> {
                GetRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    file_id: file_id.into(),
                    revision_id: revision_id.into(),
                    error_recovery: None,
                    feature_label: None,
                    mutation_precondition: None,
                    open_drive: None,
                    reason: None,
                    sync_type: None,
                }
            }
            #[doc = "Lists a file's revisions."]
            pub fn list(&self, file_id: impl Into<String>) -> ListRequestBuilder<A> {
                ListRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    file_id: file_id.into(),
                    error_recovery: None,
                    feature_label: None,
                    max_results: None,
                    mutation_precondition: None,
                    open_drive: None,
                    page_token: None,
                    reason: None,
                    sync_type: None,
                }
            }
            #[doc = "Updates a revision. This method supports patch semantics."]
            pub fn patch(
                &self,
                request: crate::schemas::Revision,
                file_id: impl Into<String>,
                revision_id: impl Into<String>,
            ) -> PatchRequestBuilder<A> {
                PatchRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    request,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    file_id: file_id.into(),
                    revision_id: revision_id.into(),
                    error_recovery: None,
                    feature_label: None,
                    mutation_precondition: None,
                    open_drive: None,
                    reason: None,
                    sync_type: None,
                }
            }
            #[doc = "Updates a revision."]
            pub fn update(
                &self,
                request: crate::schemas::Revision,
                file_id: impl Into<String>,
                revision_id: impl Into<String>,
            ) -> UpdateRequestBuilder<A> {
                UpdateRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    request,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    file_id: file_id.into(),
                    revision_id: revision_id.into(),
                    error_recovery: None,
                    feature_label: None,
                    mutation_precondition: None,
                    open_drive: None,
                    reason: None,
                    sync_type: None,
                }
            }
        }
        #[derive(Debug, Clone)]
        pub struct DeleteRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            file_id: String,
            revision_id: String,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            reason: Option<String>,
            sync_type: Option<i32>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> DeleteRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            pub fn execute(self) -> Result<(), Box<dyn ::std::error::Error>> {
                let req = self._request(&self._path());
                req.send()?.error_for_status()?;
                Ok(())
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files/");
                {
                    let var_as_str = &self.file_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/revisions/");
                {
                    let var_as_str = &self.revision_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::DELETE, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct GetRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            file_id: String,
            revision_id: String,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            reason: Option<String>,
            sync_type: Option<i32>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> GetRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::Revision, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::Revision, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files/");
                {
                    let var_as_str = &self.file_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/revisions/");
                {
                    let var_as_str = &self.revision_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::GET, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec![
                    "https://www.googleapis.com/auth/drive.metadata.readonly",
                ]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct ListRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            file_id: String,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            max_results: Option<i32>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            page_token: Option<String>,
            reason: Option<String>,
            sync_type: Option<i32>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> ListRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "Maximum number of revisions to return."]
            pub fn max_results(mut self, value: i32) -> Self {
                self.max_results = Some(value);
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "Page token for revisions. To get the next page of results, set this parameter to the value of \"nextPageToken\" from the previous response."]
            pub fn page_token(mut self, value: impl Into<String>) -> Self {
                self.page_token = Some(value.into());
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Return an iterator that iterates over all `#prop_ident`. The"]
            #[doc = r" items yielded by the iterator are chosen by the caller of this"]
            #[doc = r" method and must implement `Deserialize` and `FieldSelector`. The"]
            #[doc = r" populated fields in the yielded items will be determined by the"]
            #[doc = r" `FieldSelector` implementation."]
            pub fn iter_items<T>(mut self) -> crate::iter::PageItemIter<Self, T>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let mut fields = concat!("nextPageToken,", "items").to_owned();
                let items_fields = T::field_selector();
                if !items_fields.is_empty() {
                    fields.push_str("(");
                    fields.push_str(&items_fields);
                    fields.push_str(")");
                }
                self.fields = Some(fields);
                crate::iter::PageItemIter::new(self, "items")
            }
            #[doc = r" Return an iterator that iterates over all `#prop_ident`. The"]
            #[doc = r" items yielded by the iterator are `#items_type`. The populated"]
            #[doc = r" fields in `#items_type` will be the default fields populated by"]
            #[doc = r" the server."]
            pub fn iter_items_standard(
                mut self,
            ) -> crate::iter::PageItemIter<Self, crate::schemas::Revision> {
                self.fields = Some(concat!("nextPageToken,", "items").to_owned());
                crate::iter::PageItemIter::new(self, "items")
            }
            #[doc = r" Return an iterator that iterates over all `#prop_ident`. The"]
            #[doc = r" items yielded by the iterator are `#items_type`. The populated"]
            #[doc = r" fields in `#items_type` will be all fields available. This should"]
            #[doc = r" primarily be used during developement and debugging as fetching"]
            #[doc = r" all fields can be expensive both in bandwidth and server"]
            #[doc = r" resources."]
            pub fn iter_items_debug(
                mut self,
            ) -> crate::iter::PageItemIter<Self, crate::schemas::Revision> {
                self.fields = Some(concat!("nextPageToken,", "items", "(*)").to_owned());
                crate::iter::PageItemIter::new(self, "items")
            }
            pub fn iter<T>(mut self) -> crate::iter::PageIter<Self, T>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let mut fields = T::field_selector();
                if !fields.is_empty() {
                    match fields.chars().rev().nth(0) {
                        Some(',') | None => {}
                        _ => fields.push_str(","),
                    }
                    fields.push_str("nextPageToken");
                    self.fields = Some(fields);
                }
                crate::iter::PageIter::new(self)
            }
            pub fn iter_standard(
                self,
            ) -> crate::iter::PageIter<Self, crate::schemas::RevisionList> {
                crate::iter::PageIter::new(self)
            }
            pub fn iter_debug(
                mut self,
            ) -> crate::iter::PageIter<Self, crate::schemas::RevisionList> {
                self.fields = Some("*".to_owned());
                crate::iter::PageIter::new(self)
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::RevisionList, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::RevisionList, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files/");
                {
                    let var_as_str = &self.file_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/revisions");
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::GET, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("maxResults", &self.max_results)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("pageToken", &self.page_token)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec![
                    "https://www.googleapis.com/auth/drive.metadata.readonly",
                ]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        impl<'a, A: yup_oauth2::GetToken> crate::iter::IterableMethod for ListRequestBuilder<'a, A> {
            fn set_page_token(&mut self, value: String) {
                self.page_token = value.into();
            }
            fn execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                self._execute()
            }
        }
        #[derive(Debug, Clone)]
        pub struct PatchRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            request: crate::schemas::Revision,
            file_id: String,
            revision_id: String,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            reason: Option<String>,
            sync_type: Option<i32>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> PatchRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::Revision, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::Revision, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                let req = req.json(&self.request);
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files/");
                {
                    let var_as_str = &self.file_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/revisions/");
                {
                    let var_as_str = &self.revision_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::PATCH, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct UpdateRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            request: crate::schemas::Revision,
            file_id: String,
            revision_id: String,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            reason: Option<String>,
            sync_type: Option<i32>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> UpdateRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::Revision, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::Revision, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                let req = req.json(&self.request);
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("files/");
                {
                    let var_as_str = &self.file_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/revisions/");
                {
                    let var_as_str = &self.revision_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::PUT, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
    }
    pub mod settings {
        pub mod params {}
        pub struct SettingsActions<'a, A> {
            pub(crate) reqwest: &'a reqwest::Client,
            pub(crate) auth: &'a std::sync::Mutex<A>,
        }
        impl<'a, A: yup_oauth2::GetToken> SettingsActions<'a, A> {
            #[doc = "Deletes a setting."]
            pub fn delete(&self, keyname: impl Into<String>) -> DeleteRequestBuilder<A> {
                DeleteRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    keyname: keyname.into(),
                    error_recovery: None,
                    feature_label: None,
                    mutation_precondition: None,
                    namespace: None,
                    open_drive: None,
                    reason: None,
                    sync_type: None,
                }
            }
            #[doc = "Gets a setting by its key."]
            pub fn get(&self, keyname: impl Into<String>) -> GetRequestBuilder<A> {
                GetRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    keyname: keyname.into(),
                    error_recovery: None,
                    feature_label: None,
                    mutation_precondition: None,
                    namespace: None,
                    open_drive: None,
                    reason: None,
                    sync_type: None,
                }
            }
            #[doc = "Adds a setting for a user."]
            pub fn insert(&self, request: crate::schemas::Setting) -> InsertRequestBuilder<A> {
                InsertRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    request,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    error_recovery: None,
                    feature_label: None,
                    mutation_precondition: None,
                    namespace: None,
                    open_drive: None,
                    reason: None,
                    sync_type: None,
                }
            }
            #[doc = "Lists a user's settings."]
            pub fn list(&self) -> ListRequestBuilder<A> {
                ListRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    error_recovery: None,
                    feature_label: None,
                    mutation_precondition: None,
                    namespace: None,
                    open_drive: None,
                    reason: None,
                    sync_type: None,
                }
            }
            #[doc = "Updates a setting. This method supports patch semantics."]
            pub fn patch(
                &self,
                request: crate::schemas::Setting,
                keyname: impl Into<String>,
            ) -> PatchRequestBuilder<A> {
                PatchRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    request,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    keyname: keyname.into(),
                    error_recovery: None,
                    feature_label: None,
                    mutation_precondition: None,
                    namespace: None,
                    open_drive: None,
                    reason: None,
                    sync_type: None,
                }
            }
            #[doc = "Updates a setting."]
            pub fn update(
                &self,
                request: crate::schemas::Setting,
                keyname: impl Into<String>,
            ) -> UpdateRequestBuilder<A> {
                UpdateRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    request,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    keyname: keyname.into(),
                    error_recovery: None,
                    feature_label: None,
                    mutation_precondition: None,
                    namespace: None,
                    open_drive: None,
                    reason: None,
                    sync_type: None,
                }
            }
        }
        #[derive(Debug, Clone)]
        pub struct DeleteRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            keyname: String,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            mutation_precondition: Option<bool>,
            namespace: Option<String>,
            open_drive: Option<bool>,
            reason: Option<String>,
            sync_type: Option<i32>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> DeleteRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "The namespace of the setting."]
            pub fn namespace(mut self, value: impl Into<String>) -> Self {
                self.namespace = Some(value.into());
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            pub fn execute(self) -> Result<(), Box<dyn ::std::error::Error>> {
                let req = self._request(&self._path());
                req.send()?.error_for_status()?;
                Ok(())
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("settings/");
                {
                    let var_as_str = &self.keyname;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::DELETE, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("namespace", &self.namespace)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct GetRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            keyname: String,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            mutation_precondition: Option<bool>,
            namespace: Option<String>,
            open_drive: Option<bool>,
            reason: Option<String>,
            sync_type: Option<i32>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> GetRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "The namespace of the setting."]
            pub fn namespace(mut self, value: impl Into<String>) -> Self {
                self.namespace = Some(value.into());
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::Setting, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::Setting, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("settings/");
                {
                    let var_as_str = &self.keyname;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::GET, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("namespace", &self.namespace)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec![
                    "https://www.googleapis.com/auth/drive.metadata.readonly",
                ]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct InsertRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            request: crate::schemas::Setting,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            mutation_precondition: Option<bool>,
            namespace: Option<String>,
            open_drive: Option<bool>,
            reason: Option<String>,
            sync_type: Option<i32>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> InsertRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "The namespace of the created setting."]
            pub fn namespace(mut self, value: impl Into<String>) -> Self {
                self.namespace = Some(value.into());
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::Setting, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::Setting, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                let req = req.json(&self.request);
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("settings");
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::POST, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("namespace", &self.namespace)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct ListRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            mutation_precondition: Option<bool>,
            namespace: Option<Vec<String>>,
            open_drive: Option<bool>,
            reason: Option<String>,
            sync_type: Option<i32>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> ListRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "The namespace of the settings."]
            pub fn namespace(mut self, value: impl Into<Vec<String>>) -> Self {
                self.namespace = Some(value.into());
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::SettingList, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::SettingList, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("settings");
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::GET, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("namespace", &self.namespace)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec![
                    "https://www.googleapis.com/auth/drive.metadata.readonly",
                ]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct PatchRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            request: crate::schemas::Setting,
            keyname: String,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            mutation_precondition: Option<bool>,
            namespace: Option<String>,
            open_drive: Option<bool>,
            reason: Option<String>,
            sync_type: Option<i32>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> PatchRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "The namespace of the setting."]
            pub fn namespace(mut self, value: impl Into<String>) -> Self {
                self.namespace = Some(value.into());
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::Setting, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::Setting, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                let req = req.json(&self.request);
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("settings/");
                {
                    let var_as_str = &self.keyname;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::PATCH, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("namespace", &self.namespace)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct UpdateRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            request: crate::schemas::Setting,
            keyname: String,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            mutation_precondition: Option<bool>,
            namespace: Option<String>,
            open_drive: Option<bool>,
            reason: Option<String>,
            sync_type: Option<i32>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> UpdateRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "The namespace of the setting."]
            pub fn namespace(mut self, value: impl Into<String>) -> Self {
                self.namespace = Some(value.into());
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::Setting, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::Setting, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                let req = req.json(&self.request);
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("settings/");
                {
                    let var_as_str = &self.keyname;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::PUT, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("namespace", &self.namespace)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
    }
    pub mod teamdrives {
        pub mod params {}
        pub struct TeamdrivesActions<'a, A> {
            pub(crate) reqwest: &'a reqwest::Client,
            pub(crate) auth: &'a std::sync::Mutex<A>,
        }
        impl<'a, A: yup_oauth2::GetToken> TeamdrivesActions<'a, A> {
            #[doc = "Allows adding, removing, and updating references to Categories on a Team Drive."]
            pub fn change_category_references(
                &self,
                request: crate::schemas::TeamDriveCategoryChangeRequest,
                team_drive_id: impl Into<String>,
            ) -> ChangeCategoryReferencesRequestBuilder<A> {
                ChangeCategoryReferencesRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    request,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    team_drive_id: team_drive_id.into(),
                    error_recovery: None,
                    feature_label: None,
                    mutation_precondition: None,
                    open_drive: None,
                    reason: None,
                    sync_type: None,
                    use_domain_admin_access: None,
                }
            }
            #[doc = "Permanently deletes a Team Drive for which the user is an organizer. The Team Drive cannot contain any untrashed items."]
            pub fn delete(&self, team_drive_id: impl Into<String>) -> DeleteRequestBuilder<A> {
                DeleteRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    team_drive_id: team_drive_id.into(),
                    error_recovery: None,
                    feature_label: None,
                    mutation_precondition: None,
                    open_drive: None,
                    reason: None,
                    sync_type: None,
                }
            }
            #[doc = "Gets a Team Drive's metadata by ID."]
            pub fn get(&self, team_drive_id: impl Into<String>) -> GetRequestBuilder<A> {
                GetRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    team_drive_id: team_drive_id.into(),
                    error_recovery: None,
                    feature_label: None,
                    mutation_precondition: None,
                    open_drive: None,
                    reason: None,
                    sync_type: None,
                    use_domain_admin_access: None,
                }
            }
            #[doc = "Hides a Team Drive from the default view."]
            pub fn hide(&self, team_drive_id: impl Into<String>) -> HideRequestBuilder<A> {
                HideRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    team_drive_id: team_drive_id.into(),
                    error_recovery: None,
                    feature_label: None,
                    mutation_precondition: None,
                    open_drive: None,
                    reason: None,
                    sync_type: None,
                }
            }
            #[doc = "Creates a new Team Drive."]
            pub fn insert(
                &self,
                request: crate::schemas::TeamDrive,
                request_id: impl Into<String>,
            ) -> InsertRequestBuilder<A> {
                InsertRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    request,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    request_id: request_id.into(),
                    error_recovery: None,
                    feature_label: None,
                    mutation_precondition: None,
                    open_drive: None,
                    reason: None,
                    sync_type: None,
                }
            }
            #[doc = "Lists the user's Team Drives."]
            pub fn list(&self) -> ListRequestBuilder<A> {
                ListRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    error_recovery: None,
                    feature_label: None,
                    max_results: None,
                    mutation_precondition: None,
                    open_drive: None,
                    page_token: None,
                    q: None,
                    reason: None,
                    sync_type: None,
                    use_domain_admin_access: None,
                }
            }
            #[doc = "Restores a Team Drive to the default view."]
            pub fn unhide(&self, team_drive_id: impl Into<String>) -> UnhideRequestBuilder<A> {
                UnhideRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    team_drive_id: team_drive_id.into(),
                    error_recovery: None,
                    feature_label: None,
                    mutation_precondition: None,
                    open_drive: None,
                    reason: None,
                    sync_type: None,
                }
            }
            #[doc = "Updates a Team Drive's metadata"]
            pub fn update(
                &self,
                request: crate::schemas::TeamDrive,
                team_drive_id: impl Into<String>,
            ) -> UpdateRequestBuilder<A> {
                UpdateRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    request,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    team_drive_id: team_drive_id.into(),
                    error_recovery: None,
                    feature_label: None,
                    mutation_precondition: None,
                    open_drive: None,
                    reason: None,
                    sync_type: None,
                    use_domain_admin_access: None,
                }
            }
        }
        #[derive(Debug, Clone)]
        pub struct ChangeCategoryReferencesRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            request: crate::schemas::TeamDriveCategoryChangeRequest,
            team_drive_id: String,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            reason: Option<String>,
            sync_type: Option<i32>,
            use_domain_admin_access: Option<bool>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> ChangeCategoryReferencesRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "Issue the request as a domain administrator; if set to true, then the requester will be granted access if they are an administrator of the domain to which the Team Drive belongs."]
            pub fn use_domain_admin_access(mut self, value: bool) -> Self {
                self.use_domain_admin_access = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::TeamDrive, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::TeamDrive, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                let req = req.json(&self.request);
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("teamdrives/");
                {
                    let var_as_str = &self.team_drive_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/changeCategoryReferences");
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::POST, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("useDomainAdminAccess", &self.use_domain_admin_access)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct DeleteRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            team_drive_id: String,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            reason: Option<String>,
            sync_type: Option<i32>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> DeleteRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            pub fn execute(self) -> Result<(), Box<dyn ::std::error::Error>> {
                let req = self._request(&self._path());
                req.send()?.error_for_status()?;
                Ok(())
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("teamdrives/");
                {
                    let var_as_str = &self.team_drive_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::DELETE, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct GetRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            team_drive_id: String,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            reason: Option<String>,
            sync_type: Option<i32>,
            use_domain_admin_access: Option<bool>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> GetRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "Issue the request as a domain administrator; if set to true, then the requester will be granted access if they are an administrator of the domain to which the Team Drive belongs."]
            pub fn use_domain_admin_access(mut self, value: bool) -> Self {
                self.use_domain_admin_access = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::TeamDrive, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::TeamDrive, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("teamdrives/");
                {
                    let var_as_str = &self.team_drive_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::GET, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("useDomainAdminAccess", &self.use_domain_admin_access)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive.readonly"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct HideRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            team_drive_id: String,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            reason: Option<String>,
            sync_type: Option<i32>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> HideRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::TeamDrive, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::TeamDrive, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("teamdrives/");
                {
                    let var_as_str = &self.team_drive_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/hide");
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::POST, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct InsertRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            request: crate::schemas::TeamDrive,
            request_id: String,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            reason: Option<String>,
            sync_type: Option<i32>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> InsertRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::TeamDrive, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::TeamDrive, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                let req = req.json(&self.request);
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("teamdrives/");
                {
                    let var_as_str = &self.request_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::POST, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct ListRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            max_results: Option<i32>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            page_token: Option<String>,
            q: Option<String>,
            reason: Option<String>,
            sync_type: Option<i32>,
            use_domain_admin_access: Option<bool>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> ListRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "Maximum number of Team Drives to return."]
            pub fn max_results(mut self, value: i32) -> Self {
                self.max_results = Some(value);
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "Page token for Team Drives."]
            pub fn page_token(mut self, value: impl Into<String>) -> Self {
                self.page_token = Some(value.into());
                self
            }
            #[doc = "Query string for searching Team Drives."]
            pub fn q(mut self, value: impl Into<String>) -> Self {
                self.q = Some(value.into());
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "Issue the request as a domain administrator; if set to true, then all Team Drives of the domain in which the requester is an administrator are returned."]
            pub fn use_domain_admin_access(mut self, value: bool) -> Self {
                self.use_domain_admin_access = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Return an iterator that iterates over all `#prop_ident`. The"]
            #[doc = r" items yielded by the iterator are chosen by the caller of this"]
            #[doc = r" method and must implement `Deserialize` and `FieldSelector`. The"]
            #[doc = r" populated fields in the yielded items will be determined by the"]
            #[doc = r" `FieldSelector` implementation."]
            pub fn iter_items<T>(mut self) -> crate::iter::PageItemIter<Self, T>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let mut fields = concat!("nextPageToken,", "items").to_owned();
                let items_fields = T::field_selector();
                if !items_fields.is_empty() {
                    fields.push_str("(");
                    fields.push_str(&items_fields);
                    fields.push_str(")");
                }
                self.fields = Some(fields);
                crate::iter::PageItemIter::new(self, "items")
            }
            #[doc = r" Return an iterator that iterates over all `#prop_ident`. The"]
            #[doc = r" items yielded by the iterator are `#items_type`. The populated"]
            #[doc = r" fields in `#items_type` will be the default fields populated by"]
            #[doc = r" the server."]
            pub fn iter_items_standard(
                mut self,
            ) -> crate::iter::PageItemIter<Self, crate::schemas::TeamDrive> {
                self.fields = Some(concat!("nextPageToken,", "items").to_owned());
                crate::iter::PageItemIter::new(self, "items")
            }
            #[doc = r" Return an iterator that iterates over all `#prop_ident`. The"]
            #[doc = r" items yielded by the iterator are `#items_type`. The populated"]
            #[doc = r" fields in `#items_type` will be all fields available. This should"]
            #[doc = r" primarily be used during developement and debugging as fetching"]
            #[doc = r" all fields can be expensive both in bandwidth and server"]
            #[doc = r" resources."]
            pub fn iter_items_debug(
                mut self,
            ) -> crate::iter::PageItemIter<Self, crate::schemas::TeamDrive> {
                self.fields = Some(concat!("nextPageToken,", "items", "(*)").to_owned());
                crate::iter::PageItemIter::new(self, "items")
            }
            pub fn iter<T>(mut self) -> crate::iter::PageIter<Self, T>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let mut fields = T::field_selector();
                if !fields.is_empty() {
                    match fields.chars().rev().nth(0) {
                        Some(',') | None => {}
                        _ => fields.push_str(","),
                    }
                    fields.push_str("nextPageToken");
                    self.fields = Some(fields);
                }
                crate::iter::PageIter::new(self)
            }
            pub fn iter_standard(
                self,
            ) -> crate::iter::PageIter<Self, crate::schemas::TeamDriveList> {
                crate::iter::PageIter::new(self)
            }
            pub fn iter_debug(
                mut self,
            ) -> crate::iter::PageIter<Self, crate::schemas::TeamDriveList> {
                self.fields = Some("*".to_owned());
                crate::iter::PageIter::new(self)
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::TeamDriveList, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::TeamDriveList, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("teamdrives");
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::GET, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("maxResults", &self.max_results)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("pageToken", &self.page_token)]);
                let req = req.query(&[("q", &self.q)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("useDomainAdminAccess", &self.use_domain_admin_access)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive.readonly"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        impl<'a, A: yup_oauth2::GetToken> crate::iter::IterableMethod for ListRequestBuilder<'a, A> {
            fn set_page_token(&mut self, value: String) {
                self.page_token = value.into();
            }
            fn execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                self._execute()
            }
        }
        #[derive(Debug, Clone)]
        pub struct UnhideRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            team_drive_id: String,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            reason: Option<String>,
            sync_type: Option<i32>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> UnhideRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::TeamDrive, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::TeamDrive, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("teamdrives/");
                {
                    let var_as_str = &self.team_drive_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output.push_str("/unhide");
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::POST, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct UpdateRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            request: crate::schemas::TeamDrive,
            team_drive_id: String,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            reason: Option<String>,
            sync_type: Option<i32>,
            use_domain_admin_access: Option<bool>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> UpdateRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "Issue the request as a domain administrator; if set to true, then the requester will be granted access if they are an administrator of the domain to which the Team Drive belongs."]
            pub fn use_domain_admin_access(mut self, value: bool) -> Self {
                self.use_domain_admin_access = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::TeamDrive, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::TeamDrive, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                let req = req.json(&self.request);
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("teamdrives/");
                {
                    let var_as_str = &self.team_drive_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::PUT, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("useDomainAdminAccess", &self.use_domain_admin_access)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
    }
    pub mod workspaces {
        pub mod params {}
        pub struct WorkspacesActions<'a, A> {
            pub(crate) reqwest: &'a reqwest::Client,
            pub(crate) auth: &'a std::sync::Mutex<A>,
        }
        impl<'a, A: yup_oauth2::GetToken> WorkspacesActions<'a, A> {
            #[doc = "Delete the Workspace with the given ID."]
            pub fn delete(&self, workspace_id: impl Into<String>) -> DeleteRequestBuilder<A> {
                DeleteRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    workspace_id: workspace_id.into(),
                    error_recovery: None,
                    feature_label: None,
                    mutation_precondition: None,
                    open_drive: None,
                    reason: None,
                    sync_type: None,
                }
            }
            #[doc = "Retrieve the metadata of the Workspace with the given ID."]
            pub fn get(&self, workspace_id: impl Into<String>) -> GetRequestBuilder<A> {
                GetRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    workspace_id: workspace_id.into(),
                    error_recovery: None,
                    feature_label: None,
                    mutation_precondition: None,
                    open_drive: None,
                    reason: None,
                    sync_type: None,
                }
            }
            #[doc = "Inserts a new Workspace."]
            pub fn insert(&self, request: crate::schemas::Workspace) -> InsertRequestBuilder<A> {
                InsertRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    request,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    error_recovery: None,
                    feature_label: None,
                    mutation_precondition: None,
                    open_drive: None,
                    reason: None,
                    sync_type: None,
                }
            }
            #[doc = "List the user's Workspaces."]
            pub fn list(&self) -> ListRequestBuilder<A> {
                ListRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    error_recovery: None,
                    feature_label: None,
                    max_results: None,
                    mutation_precondition: None,
                    open_drive: None,
                    order_by: None,
                    page_token: None,
                    q: None,
                    reason: None,
                    sync_type: None,
                }
            }
            #[doc = "Update the metadata of the Workspace with the given ID."]
            pub fn update(
                &self,
                request: crate::schemas::Workspace,
                workspace_id: impl Into<String>,
            ) -> UpdateRequestBuilder<A> {
                UpdateRequestBuilder {
                    reqwest: &self.reqwest,
                    auth: &self.auth,
                    request,
                    alt: None,
                    fields: None,
                    key: None,
                    oauth_token: None,
                    pretty_print: None,
                    quota_user: None,
                    user_ip: None,
                    workspace_id: workspace_id.into(),
                    error_recovery: None,
                    feature_label: None,
                    mutation_precondition: None,
                    open_drive: None,
                    reason: None,
                    sync_type: None,
                }
            }
        }
        #[derive(Debug, Clone)]
        pub struct DeleteRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            workspace_id: String,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            reason: Option<String>,
            sync_type: Option<i32>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> DeleteRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            pub fn execute(self) -> Result<(), Box<dyn ::std::error::Error>> {
                let req = self._request(&self._path());
                req.send()?.error_for_status()?;
                Ok(())
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("workspaces/");
                {
                    let var_as_str = &self.workspace_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::DELETE, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct GetRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            workspace_id: String,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            reason: Option<String>,
            sync_type: Option<i32>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> GetRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::Workspace, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::Workspace, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("workspaces/");
                {
                    let var_as_str = &self.workspace_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::GET, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive.readonly"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct InsertRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            request: crate::schemas::Workspace,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            reason: Option<String>,
            sync_type: Option<i32>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> InsertRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::Workspace, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::Workspace, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                let req = req.json(&self.request);
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("workspaces");
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::POST, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        #[derive(Debug, Clone)]
        pub struct ListRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            max_results: Option<i32>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            order_by: Option<String>,
            page_token: Option<String>,
            q: Option<String>,
            reason: Option<String>,
            sync_type: Option<i32>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> ListRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "The maximum number of Workspaces to return per page. Partial or empty result pages are possible even before the end of the Workspaces list has been reached."]
            pub fn max_results(mut self, value: i32) -> Self {
                self.max_results = Some(value);
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "Valid sort keys are 'modifiedDate' and 'title'. Each key sorts ascending by default, but may be reversed with the 'desc' modifier. Example usage: ?orderBy=modifiedDate desc. Multiple sort keys are not currenly supported."]
            pub fn order_by(mut self, value: impl Into<String>) -> Self {
                self.order_by = Some(value.into());
                self
            }
            #[doc = "Page token for continuation of a paged result of Workspaces."]
            pub fn page_token(mut self, value: impl Into<String>) -> Self {
                self.page_token = Some(value.into());
                self
            }
            #[doc = "Query string for searching Workspaces."]
            pub fn q(mut self, value: impl Into<String>) -> Self {
                self.q = Some(value.into());
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Return an iterator that iterates over all `#prop_ident`. The"]
            #[doc = r" items yielded by the iterator are chosen by the caller of this"]
            #[doc = r" method and must implement `Deserialize` and `FieldSelector`. The"]
            #[doc = r" populated fields in the yielded items will be determined by the"]
            #[doc = r" `FieldSelector` implementation."]
            pub fn iter_items<T>(mut self) -> crate::iter::PageItemIter<Self, T>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let mut fields = concat!("nextPageToken,", "items").to_owned();
                let items_fields = T::field_selector();
                if !items_fields.is_empty() {
                    fields.push_str("(");
                    fields.push_str(&items_fields);
                    fields.push_str(")");
                }
                self.fields = Some(fields);
                crate::iter::PageItemIter::new(self, "items")
            }
            #[doc = r" Return an iterator that iterates over all `#prop_ident`. The"]
            #[doc = r" items yielded by the iterator are `#items_type`. The populated"]
            #[doc = r" fields in `#items_type` will be the default fields populated by"]
            #[doc = r" the server."]
            pub fn iter_items_standard(
                mut self,
            ) -> crate::iter::PageItemIter<Self, crate::schemas::Workspace> {
                self.fields = Some(concat!("nextPageToken,", "items").to_owned());
                crate::iter::PageItemIter::new(self, "items")
            }
            #[doc = r" Return an iterator that iterates over all `#prop_ident`. The"]
            #[doc = r" items yielded by the iterator are `#items_type`. The populated"]
            #[doc = r" fields in `#items_type` will be all fields available. This should"]
            #[doc = r" primarily be used during developement and debugging as fetching"]
            #[doc = r" all fields can be expensive both in bandwidth and server"]
            #[doc = r" resources."]
            pub fn iter_items_debug(
                mut self,
            ) -> crate::iter::PageItemIter<Self, crate::schemas::Workspace> {
                self.fields = Some(concat!("nextPageToken,", "items", "(*)").to_owned());
                crate::iter::PageItemIter::new(self, "items")
            }
            pub fn iter<T>(mut self) -> crate::iter::PageIter<Self, T>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let mut fields = T::field_selector();
                if !fields.is_empty() {
                    match fields.chars().rev().nth(0) {
                        Some(',') | None => {}
                        _ => fields.push_str(","),
                    }
                    fields.push_str("nextPageToken");
                    self.fields = Some(fields);
                }
                crate::iter::PageIter::new(self)
            }
            pub fn iter_standard(
                self,
            ) -> crate::iter::PageIter<Self, crate::schemas::WorkspaceList> {
                crate::iter::PageIter::new(self)
            }
            pub fn iter_debug(
                mut self,
            ) -> crate::iter::PageIter<Self, crate::schemas::WorkspaceList> {
                self.fields = Some("*".to_owned());
                crate::iter::PageIter::new(self)
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::WorkspaceList, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::WorkspaceList, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("workspaces");
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::GET, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("maxResults", &self.max_results)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("orderBy", &self.order_by)]);
                let req = req.query(&[("pageToken", &self.page_token)]);
                let req = req.query(&[("q", &self.q)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive.readonly"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
        impl<'a, A: yup_oauth2::GetToken> crate::iter::IterableMethod for ListRequestBuilder<'a, A> {
            fn set_page_token(&mut self, value: String) {
                self.page_token = value.into();
            }
            fn execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                self._execute()
            }
        }
        #[derive(Debug, Clone)]
        pub struct UpdateRequestBuilder<'a, A> {
            pub(crate) reqwest: &'a ::reqwest::Client,
            pub(crate) auth: &'a ::std::sync::Mutex<A>,
            request: crate::schemas::Workspace,
            workspace_id: String,
            error_recovery: Option<bool>,
            feature_label: Option<String>,
            mutation_precondition: Option<bool>,
            open_drive: Option<bool>,
            reason: Option<String>,
            sync_type: Option<i32>,
            alt: Option<crate::params::Alt>,
            fields: Option<String>,
            key: Option<String>,
            oauth_token: Option<String>,
            pretty_print: Option<bool>,
            quota_user: Option<String>,
            user_ip: Option<String>,
        }
        impl<'a, A: yup_oauth2::GetToken> UpdateRequestBuilder<'a, A> {
            #[doc = "Whether the request is done as a corrective measure after an earlier failed request."]
            pub fn error_recovery(mut self, value: bool) -> Self {
                self.error_recovery = Some(value);
                self
            }
            #[doc = "The label associated with a tracked feature rollout."]
            pub fn feature_label(mut self, value: impl Into<String>) -> Self {
                self.feature_label = Some(value.into());
                self
            }
            #[doc = "Whether the request is done prior to a mutation to verify that data is in an expected/desired/supported state."]
            pub fn mutation_precondition(mut self, value: bool) -> Self {
                self.mutation_precondition = Some(value);
                self
            }
            #[doc = "Whether the request is a part of initializing the app/website data when the user begins a session."]
            pub fn open_drive(mut self, value: bool) -> Self {
                self.open_drive = Some(value);
                self
            }
            #[doc = "The user action or internal event that triggered the request."]
            pub fn reason(mut self, value: impl Into<String>) -> Self {
                self.reason = Some(value.into());
                self
            }
            #[doc = "Whether the request is blocking a user action or not."]
            pub fn sync_type(mut self, value: i32) -> Self {
                self.sync_type = Some(value);
                self
            }
            #[doc = "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."]
            pub fn key(mut self, value: impl Into<String>) -> Self {
                self.key = Some(value.into());
                self
            }
            #[doc = "OAuth 2.0 token for the current user."]
            pub fn oauth_token(mut self, value: impl Into<String>) -> Self {
                self.oauth_token = Some(value.into());
                self
            }
            #[doc = "Returns response with indentations and line breaks."]
            pub fn pretty_print(mut self, value: bool) -> Self {
                self.pretty_print = Some(value);
                self
            }
            #[doc = "An opaque string that represents a user for quota purposes. Must not exceed 40 characters."]
            pub fn quota_user(mut self, value: impl Into<String>) -> Self {
                self.quota_user = Some(value.into());
                self
            }
            #[doc = "Deprecated. Please use quotaUser instead."]
            pub fn user_ip(mut self, value: impl Into<String>) -> Self {
                self.user_ip = Some(value.into());
                self
            }
            #[doc = r" Execute the given operation. The fields requested are"]
            #[doc = r" determined by the FieldSelector attribute of the return type."]
            #[doc = r" This allows for flexible and ergonomic partial responses. See"]
            #[doc = r" `execute_standard` and `execute_debug` for interfaces that"]
            #[doc = r" are not generic over the return type and deserialize the"]
            #[doc = r" response into an auto-generated struct will all possible"]
            #[doc = r" fields."]
            pub fn execute<T>(self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned + ::field_selector::FieldSelector,
            {
                let fields = T::field_selector();
                let fields: Option<String> = if fields.is_empty() {
                    None
                } else {
                    Some(fields)
                };
                self.execute_fields(fields)
            }
            #[doc = r" Execute the given operation. This will not provide any"]
            #[doc = r" `fields` selector indicating that the server will determine"]
            #[doc = r" the fields returned. This typically includes the most common"]
            #[doc = r" fields, but it will not include every possible attribute of"]
            #[doc = r" the response resource."]
            pub fn execute_standard(
                self,
            ) -> Result<crate::schemas::Workspace, Box<dyn ::std::error::Error>> {
                self.execute_fields::<_, &str>(None)
            }
            #[doc = r" Execute the given operation. This will provide a `fields`"]
            #[doc = r" selector of `*`. This will include every attribute of the"]
            #[doc = r" response resource and should be limited to use during"]
            #[doc = r" development or debugging."]
            pub fn execute_debug(
                self,
            ) -> Result<crate::schemas::Workspace, Box<dyn ::std::error::Error>> {
                self.execute_fields(Some("*"))
            }
            #[doc = r" Execute the given operation. This will use the `fields`"]
            #[doc = r" selector provided and will deserialize the response into"]
            #[doc = r" whatever return value is provided."]
            pub fn execute_fields<T, F>(
                mut self,
                fields: Option<F>,
            ) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
                F: Into<String>,
            {
                self.fields = fields.map(Into::into);
                self._execute()
            }
            fn _execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
            where
                T: ::serde::de::DeserializeOwned,
            {
                let req = self._request(&self._path());
                let req = req.json(&self.request);
                Ok(req.send()?.error_for_status()?.json()?)
            }
            fn _path(&self) -> String {
                let mut output = "https://www.googleapis.com/drive/v2.1beta/".to_owned();
                output.push_str("workspaces/");
                {
                    let var_as_str = &self.workspace_id;
                    output.extend(::percent_encoding::utf8_percent_encode(
                        &var_as_str,
                        crate::SIMPLE,
                    ));
                }
                output
            }
            fn _request(&self, path: &str) -> ::reqwest::RequestBuilder {
                let req = self.reqwest.request(::reqwest::Method::PUT, path);
                let req = req.query(&[("errorRecovery", &self.error_recovery)]);
                let req = req.query(&[("featureLabel", &self.feature_label)]);
                let req = req.query(&[("mutationPrecondition", &self.mutation_precondition)]);
                let req = req.query(&[("openDrive", &self.open_drive)]);
                let req = req.query(&[("reason", &self.reason)]);
                let req = req.query(&[("syncType", &self.sync_type)]);
                let req = req.query(&[("alt", &self.alt)]);
                let req = req.query(&[("fields", &self.fields)]);
                let req = req.query(&[("key", &self.key)]);
                let req = req.query(&[("oauth_token", &self.oauth_token)]);
                let req = req.query(&[("prettyPrint", &self.pretty_print)]);
                let req = req.query(&[("quotaUser", &self.quota_user)]);
                let req = req.query(&[("userIp", &self.user_ip)]);
                let mut auth = self.auth.lock().unwrap();
                let fut = auth.token(vec!["https://www.googleapis.com/auth/drive"]);
                let mut runtime = ::tokio::runtime::Runtime::new().unwrap();
                let token = runtime.block_on(fut).unwrap().access_token;
                let req = req.bearer_auth(&token);
                req
            }
        }
    }
}
#[allow(dead_code)]
const SIMPLE: &::percent_encoding::AsciiSet = &::percent_encoding::NON_ALPHANUMERIC
    .remove(b'-')
    .remove(b'.')
    .remove(b'_')
    .remove(b'~');

#[allow(dead_code)]
const RESERVED: &::percent_encoding::AsciiSet = &SIMPLE
    .remove(b'%')
    .remove(b':')
    .remove(b'/')
    .remove(b'?')
    .remove(b'#')
    .remove(b'[')
    .remove(b']')
    .remove(b'@')
    .remove(b'!')
    .remove(b'$')
    .remove(b'&')
    .remove(b'\'')
    .remove(b'(')
    .remove(b')')
    .remove(b'*')
    .remove(b'+')
    .remove(b',')
    .remove(b';')
    .remove(b'=');
#[allow(dead_code)]
mod multipart {
    pub(crate) struct RelatedMultiPart {
        parts: Vec<Part>,
        boundary: String,
    }

    impl RelatedMultiPart {
        pub(crate) fn new() -> Self {
            RelatedMultiPart {
                parts: Vec::new(),
                boundary: ::textnonce::TextNonce::sized(68).unwrap().0,
            }
        }

        pub(crate) fn new_part(&mut self, part: Part) {
            self.parts.push(part);
        }

        pub(crate) fn boundary(&self) -> &str {
            &self.boundary
        }

        pub(crate) fn into_reader(self) -> RelatedMultiPartReader {
            let boundary_marker = boundary_marker(&self.boundary);
            RelatedMultiPartReader {
                state: RelatedMultiPartReaderState::WriteBoundary {
                    start: 0,
                    boundary: format!("{}\r\n", &boundary_marker),
                },
                boundary: boundary_marker,
                next_body: None,
                parts: self.parts.into_iter(),
            }
        }
    }

    pub(crate) struct Part {
        content_type: ::mime::Mime,
        body: Box<dyn ::std::io::Read + Send>,
    }

    impl Part {
        pub(crate) fn new(
            content_type: ::mime::Mime,
            body: Box<dyn ::std::io::Read + Send>,
        ) -> Part {
            Part { content_type, body }
        }
    }

    pub(crate) struct RelatedMultiPartReader {
        state: RelatedMultiPartReaderState,
        boundary: String,
        next_body: Option<Box<dyn ::std::io::Read + Send>>,
        parts: std::vec::IntoIter<Part>,
    }

    enum RelatedMultiPartReaderState {
        WriteBoundary {
            start: usize,
            boundary: String,
        },
        WriteContentType {
            start: usize,
            content_type: Vec<u8>,
        },
        WriteBody {
            body: Box<dyn ::std::io::Read + Send>,
        },
    }

    impl ::std::io::Read for RelatedMultiPartReader {
        fn read(&mut self, buf: &mut [u8]) -> ::std::io::Result<usize> {
            use RelatedMultiPartReaderState::*;
            let mut bytes_written: usize = 0;
            loop {
                let rem_buf = &mut buf[bytes_written..];
                match &mut self.state {
                    WriteBoundary { start, boundary } => {
                        let bytes_to_copy = std::cmp::min(boundary.len() - *start, rem_buf.len());
                        rem_buf[..bytes_to_copy]
                            .copy_from_slice(&boundary.as_bytes()[*start..*start + bytes_to_copy]);
                        *start += bytes_to_copy;
                        bytes_written += bytes_to_copy;
                        if *start == boundary.len() {
                            let next_part = match self.parts.next() {
                                None => break,
                                Some(part) => part,
                            };
                            self.next_body = Some(next_part.body);
                            self.state = WriteContentType {
                                start: 0,
                                content_type: format!(
                                    "Content-Type: {}\r\n\r\n",
                                    next_part.content_type
                                )
                                .into_bytes(),
                            };
                        } else {
                            break;
                        }
                    }
                    WriteContentType {
                        start,
                        content_type,
                    } => {
                        let bytes_to_copy =
                            std::cmp::min(content_type.len() - *start, rem_buf.len());
                        rem_buf[..bytes_to_copy]
                            .copy_from_slice(&content_type[*start..*start + bytes_to_copy]);
                        *start += bytes_to_copy;
                        bytes_written += bytes_to_copy;
                        if *start == content_type.len() {
                            self.state = WriteBody {
                                body: self.next_body.take().unwrap(),
                            };
                        } else {
                            break;
                        }
                    }
                    WriteBody { body } => {
                        let written = body.read(rem_buf)?;
                        bytes_written += written;
                        if written == 0 {
                            self.state = WriteBoundary {
                                start: 0,
                                boundary: format!("\r\n{}\r\n", &self.boundary),
                            };
                        } else {
                            break;
                        }
                    }
                }
            }
            Ok(bytes_written)
        }
    }

    fn boundary_marker(boundary: &str) -> String {
        let mut marker = String::with_capacity(boundary.len() + 2);
        marker.push_str("--");
        marker.push_str(boundary);
        marker
    }
}
pub struct ResumableUpload {
    reqwest: ::reqwest::Client,
    url: String,
    progress: Option<i64>,
}

impl ResumableUpload {
    pub fn new(reqwest: ::reqwest::Client, url: String) -> Self {
        ResumableUpload {
            reqwest,
            url,
            progress: None,
        }
    }

    pub fn url(&self) -> &str {
        &self.url
    }

    pub fn upload<R>(&mut self, mut reader: R) -> Result<(), Box<dyn ::std::error::Error>>
    where
        R: ::std::io::Read + ::std::io::Seek + Send + 'static,
    {
        let reader_len = {
            let start = reader.seek(::std::io::SeekFrom::Current(0))?;
            let end = reader.seek(::std::io::SeekFrom::End(0))?;
            reader.seek(::std::io::SeekFrom::Start(start))?;
            end
        };
        let progress = match self.progress {
            Some(progress) => progress,
            None => {
                let req = self.reqwest.request(::reqwest::Method::PUT, &self.url);
                let req = req.header(::reqwest::header::CONTENT_LENGTH, 0);
                let req = req.header(
                    ::reqwest::header::CONTENT_RANGE,
                    format!("bytes */{}", reader_len),
                );
                let resp = req.send()?.error_for_status()?;
                match resp.headers().get(::reqwest::header::RANGE) {
                    Some(range_header) => {
                        let (_, progress) = parse_range_header(range_header)
                            .map_err(|e| format!("invalid RANGE header: {}", e))?;
                        progress + 1
                    }
                    None => 0,
                }
            }
        };

        reader.seek(::std::io::SeekFrom::Start(progress as u64))?;
        let content_length = reader_len - progress as u64;
        let content_range = format!("bytes {}-{}/{}", progress, reader_len - 1, reader_len);
        let req = self.reqwest.request(::reqwest::Method::PUT, &self.url);
        let req = req.header(::reqwest::header::CONTENT_RANGE, content_range);
        let req = req.body(::reqwest::Body::sized(reader, content_length));
        req.send()?.error_for_status()?;
        Ok(())
    }
}

fn parse_range_header(
    range: &::reqwest::header::HeaderValue,
) -> Result<(i64, i64), Box<dyn ::std::error::Error>> {
    let range = range.to_str()?;
    if !range.starts_with("bytes ") {
        return Err(r#"does not begin with "bytes""#.to_owned().into());
    }
    let range = &range[6..];
    let slash_idx = range
        .find('/')
        .ok_or_else(|| r#"does not contain"#.to_owned())?;
    let (begin, end) = range.split_at(slash_idx);
    let end = &end[1..]; // remove '/'
    let begin: i64 = begin.parse()?;
    let end: i64 = end.parse()?;
    Ok((begin, end))
}
// A serde helper module that can be used with the `with` attribute
// to deserialize any string to a FromStr type and serialize any
// Display type to a String. Google API's encode i64, u64 values as
// strings.
#[allow(dead_code)]
mod parsed_string {
    pub fn serialize<T, S>(
        value: &Option<T>,
        serializer: S,
    ) -> ::std::result::Result<S::Ok, S::Error>
    where
        T: ::std::fmt::Display,
        S: ::serde::Serializer,
    {
        use ::serde::Serialize;
        value.as_ref().map(|x| x.to_string()).serialize(serializer)
    }

    pub fn deserialize<'de, T, D>(deserializer: D) -> ::std::result::Result<Option<T>, D::Error>
    where
        T: ::std::str::FromStr,
        T::Err: ::std::fmt::Display,
        D: ::serde::de::Deserializer<'de>,
    {
        use ::serde::Deserialize;
        match Option::<String>::deserialize(deserializer)? {
            Some(x) => Ok(Some(x.parse().map_err(::serde::de::Error::custom)?)),
            None => Ok(None),
        }
    }
}
#[allow(dead_code)]
pub mod iter {
    pub trait IterableMethod {
        fn set_page_token(&mut self, value: String);
        fn execute<T>(&mut self) -> Result<T, Box<dyn ::std::error::Error>>
        where
            T: ::serde::de::DeserializeOwned;
    }

    pub struct PageIter<M, T> {
        pub method: M,
        pub finished: bool,
        pub _phantom: ::std::marker::PhantomData<T>,
    }

    impl<M, T> PageIter<M, T>
    where
        M: IterableMethod,
        T: ::serde::de::DeserializeOwned,
    {
        pub(crate) fn new(method: M) -> Self {
            PageIter {
                method,
                finished: false,
                _phantom: ::std::marker::PhantomData,
            }
        }
    }

    impl<M, T> Iterator for PageIter<M, T>
    where
        M: IterableMethod,
        T: ::serde::de::DeserializeOwned,
    {
        type Item = Result<T, Box<dyn ::std::error::Error>>;

        fn next(&mut self) -> Option<Result<T, Box<dyn ::std::error::Error>>> {
            if self.finished {
                return None;
            }
            let paginated_result: ::serde_json::Map<String, ::serde_json::Value> =
                match self.method.execute() {
                    Ok(r) => r,
                    Err(err) => return Some(Err(err)),
                };
            if let Some(next_page_token) = paginated_result
                .get("nextPageToken")
                .and_then(|t| t.as_str())
            {
                self.method.set_page_token(next_page_token.to_owned());
            } else {
                self.finished = true;
            }

            Some(
                match ::serde_json::from_value(::serde_json::Value::Object(paginated_result)) {
                    Ok(resp) => Ok(resp),
                    Err(err) => Err(err.into()),
                },
            )
        }
    }

    pub struct PageItemIter<M, T> {
        items_field: &'static str,
        page_iter: PageIter<M, ::serde_json::Map<String, ::serde_json::Value>>,
        items: ::std::vec::IntoIter<T>,
    }

    impl<M, T> PageItemIter<M, T>
    where
        M: IterableMethod,
        T: ::serde::de::DeserializeOwned,
    {
        pub(crate) fn new(method: M, items_field: &'static str) -> Self {
            PageItemIter {
                items_field,
                page_iter: PageIter::new(method),
                items: Vec::new().into_iter(),
            }
        }
    }

    impl<M, T> Iterator for PageItemIter<M, T>
    where
        M: IterableMethod,
        T: ::serde::de::DeserializeOwned,
    {
        type Item = Result<T, Box<dyn ::std::error::Error>>;

        fn next(&mut self) -> Option<Result<T, Box<dyn ::std::error::Error>>> {
            loop {
                if let Some(v) = self.items.next() {
                    return Some(Ok(v));
                }

                let next_page = self.page_iter.next();
                match next_page {
                    None => return None,
                    Some(Err(err)) => return Some(Err(err)),
                    Some(Ok(next_page)) => {
                        let mut next_page: ::serde_json::Map<String, ::serde_json::Value> =
                            next_page;
                        let items_array = match next_page.remove(self.items_field) {
                            Some(items) => items,
                            None => {
                                return Some(Err(format!(
                                    "no {} field found in iter response",
                                    self.items_field
                                )
                                .into()))
                            }
                        };
                        let items_vec: Result<Vec<T>, _> = ::serde_json::from_value(items_array);
                        match items_vec {
                            Ok(items) => self.items = items.into_iter(),
                            Err(err) => return Some(Err(err.into())),
                        }
                    }
                }
            }
        }
    }
} // Bytes in google apis are represented as urlsafe base64 encoded strings.
  // This defines a Bytes type that is a simple wrapper around a Vec<u8> used
  // internally to handle byte fields in google apis.
#[allow(dead_code)]
mod bytes {
    use radix64::URL_SAFE as BASE64_CFG;

    #[derive(Debug, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
    pub struct Bytes(Vec<u8>);

    impl ::std::convert::From<Vec<u8>> for Bytes {
        fn from(x: Vec<u8>) -> Bytes {
            Bytes(x)
        }
    }

    impl ::std::fmt::Display for Bytes {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> ::std::fmt::Result {
            ::radix64::Display::new(BASE64_CFG, &self.0).fmt(f)
        }
    }

    impl ::serde::Serialize for Bytes {
        fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            let encoded = BASE64_CFG.encode(&self.0);
            encoded.serialize(serializer)
        }
    }

    impl<'de> ::serde::Deserialize<'de> for Bytes {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Bytes, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            let encoded = String::deserialize(deserializer)?;
            let decoded = BASE64_CFG
                .decode(&encoded)
                .map_err(|_| ::serde::de::Error::custom("invalid base64 input"))?;
            Ok(Bytes(decoded))
        }
    }
}
